{% extends "base.html" %} 
{% load static %} 
{% load stock_filters %}
{% load custom_tags %}
{% block content %}

<style>

/* ========== Tablet override — paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */


@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }

.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(5)  { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 105px !important; max-width: 105px !important; }
  #order-listing th:nth-child(8)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 110px !important; max-width: 110px !important; }
  #order-listing th:nth-child(12) { min-width: 100px !important; max-width: 105px !important; }
  #order-listing th:nth-child(13) { min-width: 125px !important; max-width: 120px !important; }
  #order-listing th:nth-child(14) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(15) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(16) { min-width: 120px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }

  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 90px;
  max-width: 95px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 110px;
  max-width: 110px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 90px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 140px;
  max-width: 150px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(20) {
  min-width: 100px;
  max-width: 110px;
} /* Remarks for IS Pick Table */

@media (min-width: 600px) and (max-width: 900px) {
  #order-listing {
    table-layout: auto !important; /* Let columns auto-fit content */
    width: 100% !important;
    min-width: unset !important;
    max-width: 100vw !important;
  }
  /* Adjust width for all headings (th) and cells (td) */
  #order-listing th,
  #order-listing td {
    min-width: 90px !important;
    max-width: 90px !important;
    width: 180px !important;
  }
  #order-listing th {
    position: relative;
    padding-right: 48px !important; /* More space for filter icon */
    white-space: normal !important;
    overflow: visible !important;
    text-overflow: ellipsis;
  }
  #order-listing th .fa-filter {
    position: absolute;
    right: 18px !important;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
    background: transparent;
    pointer-events: auto;
  }
}
/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}


/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }

  /* Styling for remark tooltip close button */
  .remark-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    display: none;
    line-height: 1;
    padding: 0;
    transition: all 0.2s ease;
    z-index: 1001;
  }

  .remark-close-btn:hover {
    background: #c82333;
    transform: scale(1.05);
  }

  .remark-close-btn:active {
    transform: scale(0.95);
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}

#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}

/* Redo2.png button visibility and hover effects */
#trayScanRedoClearBtn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 24px !important;
  height: 24px !important;
  min-width: 24px !important;
  min-height: 24px !important;
  cursor: pointer !important;
  transition: transform 0.2s ease, opacity 0.2s ease !important;
  flex-shrink: 0 !important;
}

#trayScanRedoClearBtn:hover {
  transform: scale(1.15) !important;
  opacity: 0.8 !important;
}

#trayScanRedoClearBtn:active {
  transform: scale(0.95) !important;
}
</style>
 

<div class="content-wrapper">
  <!-- <h5 class="text-left mt-0 mb-3">Day Planning Pick Table</h5> -->
  
    <div class="col-12 grid-margin stretch-card">
      <div class="card">
                <div class="card-body">
              <h5 class="text-left mt-0 mb-4" style="font-weight:700;">
                Day Planning Pick Table
                <button type="button" class="btn btn-primary btn-sm ms-3" id="scanButton" 
                        style="background-color: #028084; border-color: #028084; font-weight: 600; vertical-align: middle;">
                  <i class="fa fa-qrcode" style="margin-right: 6px;"></i>
                  Scan
                </button>
                <span id="scanStatusMessage" style="display: none; margin-left: 12px; vertical-align: middle; color: #28a745; font-size: 15px; font-weight: 700;">PLEASE SCAN</span>
              </h5>
              
              <!-- Hidden input for scanner -->
              <input type="text" id="scanHiddenInput" 
                     style="position: absolute; left: 0; top: 0; width: 1px; height: 1px; 
                            border: none; background: transparent; color: transparent;
                            overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap;" 
                     autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />

            <!-- Table Section -->
            <div class="table-responsive" style="overflow: auto !important">
<table id="order-listing" class="table">
<thead>
  <tr> 
    {% for heading in visible_headings %}
      <th class="{% if not is_admin and not visible_headings|get_item:heading %}blurred-heading{% endif %}">
        {% if display_headings_map %}
          {{ display_headings_map|get_item:heading|safe }}
        {% else %}
          {{ heading }}
        {% endif %}
        <i class="fa fa-filter" aria-hidden="true"></i>
      </th>
    {% endfor %}
  </tr>
</thead>
                

<tbody>
  {% for data in master_data %}
    <tr {% if data.hold_lot %}class="row-inactive"{% endif %} 
        data-lot-id="{{ data.lot_id|default:data.batch_id }}" 
        data-batch-id="{{ data.batch_id }}"
        data-model-no="{{ data.model_stock_no__model_no }}">
      <td class="{% if not is_admin and not visible_headings|get_item:'S.No' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        <span style="display:flex; align-items:center; gap:3px;">
          {% if is_admin %}
            <label class="hold-toggle-switch" style="margin-bottom:0;">
              {% if not data.hold_lot %}
                <input type="checkbox" class="hold-toggle-btn" checked />
                <span class="hold-slider"></span>
              {% else %}
                <input type="checkbox" class="hold-toggle-btn" />
                <span class="hold-slider"></span>
              {% endif %}
            </label>
            <span class="hold-remark-icon" 
                  style="display:{% if data.hold_lot or data.release_lot %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                  title="{% if data.holding_reason %}Holding Reason: {{ data.holding_reason }}{% endif %}{% if data.holding_reason and data.release_reason %}&#10;{% endif %}{% if data.release_reason %}Release Reason: {{ data.release_reason }}{% endif %}">
              {% if data.hold_lot or data.release_lot %}
                <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
              {% endif %}
            </span>
          {% else %}
            {% if data.hold_lot or data.release_lot or data.holding_reason or data.release_reason %}
              <span class="hold-remark-icon" 
                    style="display:inline-block; cursor:pointer;" 
                    title="{% if data.holding_reason %}Holding Reason: {{ data.holding_reason }}{% endif %}{% if data.holding_reason and data.release_reason %}&#10;{% endif %}{% if data.release_reason %}Release Reason: {{ data.release_reason }}{% endif %}">
                <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:12px; height:12px;" />
              </span>
            {% endif %}
          {% endif %}
          <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
        </span>
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Last Updated' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.date_time|date:"d-M-y" }}<br>
        <span style="display:inline-block; margin-top:4px;">{{ data.date_time|date:"h:i A"  }}</span>
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Plating Stk No' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}" style="white-space:normal;word-break:break-all;">
        <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
          {{ data.plating_stk_no|highlight_plating_color|safe_html }}
          <div class="model-image-tooltip"
               style="position: absolute; left: 238%; top: 0%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 10010; display: flex; align-items: center; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s;">
            <button class="close-btn" style="position:absolute; top:8px; right:8px;">Close</button>
            <button class="info-btn" style="position:absolute; top:8px; left:8px;">Info</button>
            <button class="img-scroll-left" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8592;</button>
            <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
              <img src="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}" 
                  style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
            </div>

            <button class="img-scroll-right" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8594;</button>
          </div>
        </span>
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Polishing Stk No' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Plating Color' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.plating_color|default:"N/A" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Category' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.category|default:"N/A" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Polish Finish' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.polish_finish|default:"N/A" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Version' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.version__version_internal|default:"N/A" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Tray Cate-Capacity' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.tray_type|default:"N/A" }}-{{ data.tray_capacity|default:"0" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Source' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.location__location_name|default:"N/A" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'No of Trays' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.no_of_trays|default:"0" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Input Qty' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {{ data.total_batch_quantity|default:"0" }}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Process Status' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {% if data.Moved_to_D_Picker %}
          <div data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Tray Scan" class="d-flex align-items-center justify-content-center rounded-circle ms-1"
               style="width: 28px; height: 28px; background-color: #0c8249; color: white; font-weight: bold; cursor: pointer;">
            T
          </div>
        {% elif data.Draft_Saved %}
          <div data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Tray Scan" class="d-flex align-items-center justify-content-center rounded-circle ms-1"
               style="width: 28px; height: 28px; background: linear-gradient(to right, green 50%, #bfbfbf 50%); color: white; font-weight: bold; line-height: 20px; text-align: center; padding-top: 1px; padding-right: 1px; cursor: pointer;">
            T
          </div>
        {% else %}
          <div data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Tray Scan" class="d-flex align-items-center justify-content-center rounded-circle ms-1"
               style="width: 28px; height: 28px; background-color: #d3d2d2; color: white; font-weight: bold; cursor: pointer;">
            T
          </div>
        {% endif %}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Action' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {% if is_admin %}
          {% if not data.Moved_to_D_Picker %}
            <a href="#" class="edit-qty-btn" data-batch-id="{{ data.batch_id }}">
              <img src="{% static 'assets/icons/edit1.png' %}" alt="Edit" style="width: 24px; margin-right: 8px; height: auto"/>
            </a>
          {% else %}
            <span style="opacity:0.5; pointer-events:none; display:inline-block;">
              <img src="{% static 'assets/icons/edit1.png' %}" alt="Edit Disabled" style="width: 24px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);"/>
            </span>
          {% endif %}
          {% if not data.Moved_to_D_Picker %}
            <a href="#" title="Delete">
              <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 24px; margin-right: 8px; height: auto; cursor:pointer;" />
            </a>
          {% else %}
            <span title="Cannot delete after moved" style="opacity:0.5; pointer-events:none; display:inline-block;">
              <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 24px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5); cursor:not-allowed;" />
            </span>
          {% endif %}
        {% endif %}
        {% if not data.Moved_to_D_Picker %}
          <a href="#" class="text-primary tray-scan-btn" style="text-decoration: underline"
             data-batch-id="{{ data.batch_id }}" 
             data-model-no="{{ data.model_stock_no__model_no }}"
             data-no-of-trays="{{ data.no_of_trays }}" 
             data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
             data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}" 
             data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
             data-top-tray-qty-verified="{{ data.top_tray_qty_verified }}" 
             data-draft-saved="{{data.Draft_Saved}}"
             data-total-batch-quantity="{{ data.total_batch_quantity|default:'0' }}"
             data-model-image="{{ data.model_images.0|default:'' }}"
             data-needs-top-tray-scan="{{ data.needs_top_tray_scan|yesno:'true,false' }}"
             data-tray-scan-status="{{ data.tray_scan_status|yesno:'true,false' }}">
            {% if data.needs_top_tray_scan %}
              Set Top Tray
            {% else %}
              Tray Scan
            {% endif %}
          </a>
        {% endif %}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Lot Status' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        {% if data.hold_lot %}
          <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
               style="border: 1px solid #dc3545; background-color: #f8d7da; color: #721c24; font-size: 13px; white-space: nowrap; padding: 5px;">
            On Hold
          </div>
        {% elif data.Moved_to_D_Picker %}
          <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
               style="border: 1px solid #0d5d17; background-color: #c5f9c2; color: #2f801b; font-size: 13px; white-space: nowrap; padding: 5px;">
            Yet To Release
          </div>
        {% elif data.Draft_Saved %}
          <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
               style="border: 1px solid #4997ac; background-color: #d1f2f3; color: #03425d; font-size: 13px; white-space: nowrap; padding: 5px;">
            Draft
          </div>
        {% else %}
          <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
               style="border: 1px solid #a6a6a6; background-color: #dcdada; color: #505050; font-size: 13px; white-space: nowrap; padding: 5px;">
            Yet to Start
          </div>
        {% endif %}
      </td>
      <td class="{% if not is_admin and not visible_headings|get_item:'Current Stage' %}blurred-cell{% endif %}{% if data.hold_lot %} row-inactive-blur{% endif %}">
        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
             style="border: 1px solid #9adeed; background-color: #d1edf3; color: #033b5d; font-size: 12px; padding: 5px;">
          {% if data.last_procees_module == "DayPlanning" %}
            {{ data.last_procees_module }}
          {% else %}
            Day Planning
          {% endif %}
        </div>
      </td>
<!-- Updated Remarks Column - Replace the existing Remarks td section with this -->
<td
  {% if data.hold_lot %}
    class="row-inactive-blur"
  {% endif %}
>
    <!-- Admin users: Show audio and remark icons if not moved -->
    {% if not data.Moved_to_D_Picker %}
      <!-- VoiceRec with tooltip (audio remark) -->
                          <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                            <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                            <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                              <!-- Audio recording UI placeholder -->
                              <div style="display: flex; align-items: center; gap: 10px;">
                                <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                  <i class="fa fa-microphone"></i>
                                </button>
                                <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                                  <div style="text-align: right; margin-top: 10px;">
                                <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                  <i class="fa fa-send"></i>
                                </button>
                              </div>
                              </div>
                            
                            </div>
                          </a>

                          <a href="#" title="Add Remark" class="remark-tooltip-trigger" style="cursor: pointer;">
                            <img
                              src="{% static 'assets/icons/chat_icon.png' %}"
                              alt="Chat"
                              style="width: 20px; height: 20px; {% if data.dp_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% else %}opacity: 0.7;{% endif %}"
                            />

                            <div
                              class="remark-tooltip"
                              style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 270px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                            >
                              <!-- Close button in top-right corner -->
                              <button type="button" class="remark-close-btn" style="position: absolute; top: 8px; right: 8px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 12px; cursor: pointer; display: none; line-height: 1; padding: 0;">
                                ×
                              </button>
                              <textarea
                                placeholder="Type your remark..."
                                style="width: 75%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                {% if data.dp_pick_remarks %}readonly{% endif %}
                              >{{ data.dp_pick_remarks|default_if_none:"" }}</textarea>
                              <div style="text-align: right; margin-top: -35px">
                                {% if not data.dp_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                {% endif %}
                              </div>
                            </div>
                          </a>
    {% else %}
      <!-- Audio Remark Icon (disabled) -->
      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;">
        <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
      </span>
      <!-- Chat Remark Icon (disabled) -->
      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;">
        <img src="{% static 'assets/icons/chat_icon.png' %}" alt="Chat Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
      </span>

    {% endif %}
</td>
    </tr>
  {% empty %}
    <tr>
      <td colspan="15" class="text-center">No data available</td>
    </tr>
  {% endfor %}
</tbody>

              </table>
            <div
            id="trayScanModal"
            class="tray-scan-modal"
            id="trayScanModal"
          >
            <div class="tray-scan-modal-content">
              <span id="closeTrayScanModal" class="tray-scan-close"
                >&times;</span>

<!-- New top header container: title + user profile aligned left -->
<!-- Header Section -->
    <div class="modal-top-header">
      <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 44px; height: 44px; object-fit: cover;" />
      
      <div style="font-weight: 600; color: #222; font-size: 17px;">
        Model No:
        <span id="modalModelNo" style="color: #028084; font-weight: 700;">(Fetch Dynamically)</span>
      </div>

      <div style="font-weight: 600; color: #222; font-size: 17px;">
        Input Qty:
        <span id="modalTrayQty" style="color: #028084; font-weight: 700;">(Fetch Dynamically)</span>
      </div>
    </div>

              
                                <!-- Redo icon for clearing "tray ID" -->
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <h5 style="margin: 0; font-weight: 600; color: #595959;">Day Planning - Tray Scan</h5>
      <div style="display: flex; align-items: center; gap: 16px;">
<div id="trayScanSummary" style="font-weight: 600; font-size: 15px; color: #028084; margin-bottom: 0; display: flex; align-items: center; gap: 8px;">
  <span style="white-space: nowrap;">Qty to Scan: 0/0</span>
  <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayScanRedoClearBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;" />
</div>
      </div>
    </div>

              <!-- trayScanDetails will be a scrollable 3-column grid with headers and unlimited rows -->
              <div id="trayScanDetails" class="table-grid">
                <!-- Headers -->
                <div>S.no</div>
                <div>Tray ID</div>
                <div>Tray Quantity</div>
<div class="tray-validation-status-header">Tray Validation Status
<span style="margin-left: 10px;">
    <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
    <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
  </span>

</div>

                <!-- Example rows (replace with dynamic content) -->
              </div>
              <!-- âœ… NEW BUTTONS SECTION -->
              
              <div class="tray-scan-modal-buttons"
                style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                <button id="trayScanDraftBtn" type="button" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
                <button id="trayScanSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
                <button id="trayScanCancelBtn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">Cancel</button>
              </div>
              <div id="trayQtyErrorFooter" style="color: red; font-size: 14px; text-align: center; min-height: 10px; margin-top: 5px;"></div>
              
            </div>
            <div
              id="trayScanModal_DayPlanning"
              class="tray-scan-modal-DayPlanning"
            >
              <div class="tray-scan-modal-DayPlanning-content">
                <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly"
                  >&times;</span
                >
                <!-- New top header container: title + user profile aligned left -->
                <div
                  class="modal-top-header"
                  style="
                    display: flex;
                    align-items: center;
                    gap: 20px;
                    display: flex;
                    margin-bottom: 5px; 
                    border-bottom: 1px solid #eee;
                  "
                >
                  <div
                    class="user-profile"
                    style="display: flex; align-items: center; gap: 8px"
                  >
                    <img
                      src="/static/assets/images/imagePlaceholder.png"
                      alt="User Profile"
                      style="
                        border-radius: 50%;
                        width: 50px;
                        height: 50px;
                        object-fit: cover;
                      "
                    />
                    <span>Model No:</span>
                    <h6 id="modalModelNo_DayPlanning">(Fetch Dynamically)</h6>
                  </div>
                </div>
                <!-- Redo icon for clearing "tray ID" -->
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                  <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                    Day Planning - Tray Scan (Read Only)
                  </h5>
                  <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 13px; font-weight: 500; cursor: pointer;">
                      Tray Validate
                  </button>

                  <!-- Hidden input field - completely invisible to users -->
                  <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                </div>
                
                <!-- Error message container - initially hidden -->
                <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 14px; text-align: center;">
                  <span id="trayErrorText"></span>
                </div>
                
                <!-- trayScanDetails_DayPlanning will be a scrollable 3-column grid with headers and unlimited rows -->
                <div id="trayScanDetails_DayPlanning" class="table-grid">
                  <!-- Headers -->
                  <div>S.no</div>
                  <div>Tray ID</div>
                  <div>Tray Quantity</div>
                  <div class="tray-validation-status-header">Tray Validation Status
                    <span style="margin-left: 10px;">
            <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
            <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
                  </div>
                  <!-- Example rows (replace with dynamic content) -->
                </div>
                <!-- No buttons for read-only modal -->
              </div>
            </div>
                        <!-- End of Tray Scan Modal Window -->

            </div> 

                    <div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
            <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
              <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
              <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
              <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
              <div style="text-align:right; margin-top:10px;">
                <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
              </div>
              <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
            </div>
          </div>
        </div>

            <!-- Pagination Section -->

 <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


 
{% block script %}

<!-- Barcode Scanner - Script -->
<script nonce="{{ csp_nonce }}">
// ==========================================
// BARCODE SCANNER FUNCTIONALITY - Day Planning
// ==========================================
document.addEventListener("DOMContentLoaded", function () {
  // Handle open_batch and open_tray params for redirected scans
  const urlParams = new URLSearchParams(window.location.search);
  const openBatch = urlParams.get('open_batch');
  const openTray = urlParams.get('open_tray');
  if (openBatch && openTray) {
    // Remove the params
    urlParams.delete('open_batch');
    urlParams.delete('open_tray');
    const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
    window.history.replaceState({}, '', newUrl);
    // Open the modal
    setTimeout(() => openRowModalByBatchId(openTray, openBatch), 500); // Delay to ensure DOM is ready
  }

  const scanBtn = document.getElementById("scanButton");
  const scanInput = document.getElementById("scanHiddenInput");
  const scanStatus = document.getElementById("scanStatusMessage");
  
  let isScanning = false;
  let scanTimeout = null;
  let focusInterval = null;

  if (scanBtn && scanInput && scanStatus) {
    
    // Function to keep scanner input focused ONLY during active scanning
    function maintainScannerFocus() {
      if (isScanning && document.activeElement !== scanInput) {
        // Check if user is not actively typing in a modal input field
        const activeElement = document.activeElement;
        const isInModal = activeElement && activeElement.closest('#trayScanModal');
        
        if (!isInModal) {
          scanInput.focus();
        }
      }
    }
    
    // Handle scanner button click
    scanBtn.addEventListener("click", function () {
      console.log("🔵 [SCANNER] Scan button clicked");
      
      const modal = document.getElementById('trayScanModal');
      
      // More accurate modal detection - check if modal is actually visible and active
      const modalIsOpen = modal && (
        (modal.style.display === 'flex' && modal.style.visibility !== 'hidden' && modal.style.opacity !== '0') ||
        modal.classList.contains('open') ||
        (modal.offsetWidth > 0 && modal.offsetHeight > 0 && 
         window.getComputedStyle(modal).visibility !== 'hidden' && 
         window.getComputedStyle(modal).opacity !== '0' &&
         window.getComputedStyle(modal).display === 'flex')
      );
      
      console.log("🔍 [SCANNER] Modal element found:", !!modal);
      console.log("🔍 [SCANNER] Modal style.display:", modal ? modal.style.display : 'none');
      console.log("🔍 [SCANNER] Modal computed display:", modal ? window.getComputedStyle(modal).display : 'none');
      console.log("🔍 [SCANNER] Modal visible dimensions:", modal ? `${modal.offsetWidth}x${modal.offsetHeight}` : '0x0');
      console.log("🔍 [SCANNER] Modal is detected as open:", modalIsOpen);
      
      if (modalIsOpen) {
        console.log("🔵 [SCANNER] Modal is open, focusing modal inputs instead of hidden scanner");
        // Modal is open, focus first empty input and disable hidden scanner
        isScanning = false; // Disable hidden scanner completely
        let focusTries = 0;
        const focusIntervalId = setInterval(() => {
          const inputs = modal.querySelectorAll('.tray-id-input');
          let focused = false;
          for (let input of inputs) {
            if (!input.value.trim()) {
              input.focus();
              focused = true;
              console.log("🎯 [SCANNER] Focused first empty modal input for barcode entry");
              break;
            }
          }
          if (!focused && inputs.length > 0) {
            inputs[0].focus();
            console.log("🎯 [SCANNER] All inputs filled, focused first input");
          }
          focusTries++;
          if (focused || focusTries > 10) {
            clearInterval(focusIntervalId);
          }
        }, 30);
        scanStatus.textContent = "PLEASE SCAN";
        scanStatus.style.display = "inline-block";
        scanStatus.style.color = "#28a745";
        // Stop focus interval to prevent hidden scanner activation
        if (focusInterval) {
          clearInterval(focusInterval);
          focusInterval = null;
        }
      } else {
        console.log("🔵 [SCANNER] No modal open, activating hidden scanner input");
        // No modal, activate scanner
        isScanning = true;
        scanInput.value = "";
        scanInput.focus();
        console.log("🔵 [SCANNER] Hidden input focused, scanning active:", document.activeElement === scanInput);
        console.log("🔵 [SCANNER] Hidden input element:", scanInput);
        console.log("🔵 [SCANNER] Hidden input visible:", scanInput.offsetWidth > 0 && scanInput.offsetHeight > 0);
        scanStatus.textContent = "PLEASE SCAN";
        scanStatus.style.display = "inline-block";
        scanStatus.style.color = "#28a745";
        // Start focus maintenance
        if (focusInterval) clearInterval(focusInterval);
        focusInterval = setInterval(maintainScannerFocus, 200);
      }
    });

    // Handle barcode input - using both keydown and input events for compatibility
    function processBarcodeInput() {
      if (!isScanning) {
        console.log("🔴 [SCANNER] Input received but scanning is not active, ignoring");
        return; // Only process if scanning is active
      }
      
      const trayId = scanInput.value.trim();
      console.log("🔍 [SCANNER] Processing input:", `"${trayId}"`, "Length:", trayId.length);
      
      // Clear any existing timeout
      if (scanTimeout) {
        clearTimeout(scanTimeout);
      }
      
      // Wait for complete barcode input (typical scanner delay)
      scanTimeout = setTimeout(() => {
        console.log("🔍 [SCANNER] Timeout triggered, final value:", `"${trayId}"`, "Length:", trayId.length);
        if (trayId.length >= 8) {
          console.log("✅ [SCANNER] Valid barcode length, calling validateBarcode");
          validateBarcode(trayId);
        } else if (trayId.length > 0 && isScanning) {
          console.log("⏳ [SCANNER] Partial input, showing scanning status");
          scanStatus.style.color = "#ffc107";
          scanStatus.textContent = "Scanning...";
        } else if (trayId.length === 0) {
          console.log("⚠️ [SCANNER] Empty input received");
        }
      }, 150);
    }
    
    // Function to stop scanning mode
    function stopScanning() {
      isScanning = false;
      scanInput.value = "";
      scanStatus.style.display = "none";
      if (focusInterval) {
        clearInterval(focusInterval);
        focusInterval = null;
      }
      console.log("🔴 [SCANNER] Scanning mode deactivated");
    }
    
    // Function to validate and process barcode
    function validateBarcode(trayId) {
      console.log("🔍 [SCANNER] Processing tray ID:", trayId);
      
      // Get CSRF token for authenticated requests
      const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                       document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') ||
                       getCookie('csrftoken');
      
      // First, get the batch_id for this tray from the API
      fetch(`/dayplanning/dget_lot_id_for_tray/?tray_id=${encodeURIComponent(trayId)}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrfToken,
          'X-Requested-With': 'XMLHttpRequest'
        },
        credentials: 'include'  // Include session cookies
      })
        .then(res => {
          console.log("🔍 [SCANNER] API Response status:", res.status);
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
          return res.json();
        })
        .then(data => {
          console.log("🔍 [SCANNER] API Response data:", data);
          if (data.success && data.batch_id) {
            console.log("✅ [SCANNER] Tray found in system - ID:", trayId, "Batch:", data.batch_id, "page:", data.page);

            // Check tray capacity match
            if (data.tray_capacity && data.batch_tray_capacity && data.tray_capacity != data.batch_tray_capacity) {
              console.log("⚠️ [SCANNER] Tray capacity mismatch - Tray:", data.tray_capacity, "Batch:", data.batch_tray_capacity);
              scanStatus.style.color = "#dc3545";
              scanStatus.textContent = `Wrong tray type! Tray capacity ${data.tray_capacity} doesn't match batch capacity ${data.batch_tray_capacity}`;
              setTimeout(() => {
                stopScanning();
              }, 3000);
              return;
            }

            // Stop scanning immediately to prevent further input
            stopScanning();

            // If server returned a page number and it's not the current page, navigate to that page
            try {
              const params = new URLSearchParams(window.location.search);
              const currentPage = params.get('page') || '1';
              if (data.page && String(data.page) !== String(currentPage)) {
                // Redirect to the correct page and set open_batch and open_tray so the modal opens after reload
                params.set('page', data.page);
                params.set('open_batch', data.batch_id);
                params.set('open_tray', trayId);
                const newUrl = window.location.pathname + '?' + params.toString();
                console.log(`🔁 [SCANNER] Redirecting to page ${data.page} to open batch ${data.batch_id} with tray ${trayId}`);
                window.location.href = newUrl;
                return;
              }
            } catch (e) {
              console.log('⚠️ [SCANNER] Error checking page redirect:', e);
            }

            // Find and open the specific row that matches this batch_id
            openRowModalByBatchId(trayId, data.batch_id);
          } else {
            console.log("⚠️ [SCANNER] Tray not found in system or API returned error:", data);
            // Stop scanning for fallback
            stopScanning();
            
            // Show more specific error message
            if (data.error) {
              scanStatus.style.color = "#dc3545";
              scanStatus.textContent = `Error: ${data.error}`;
              setTimeout(() => {
                scanStatus.style.display = "none";
              }, 5000);
            } else {
              // If tray not in system, open first Draft row as fallback
              console.log("⚠️ [SCANNER] Falling back to Draft row search for:", trayId);
              openPriorityRowModal(trayId);
            }
          }
        })
        .catch((error) => {
          console.log("⚠️ [SCANNER] API error details:", error);
          // Stop scanning for error fallback
          stopScanning();
          
          // Show error message to user
          scanStatus.style.color = "#dc3545";
          scanStatus.textContent = `Scanner Error: ${error.message || error}`;
          setTimeout(() => {
            scanStatus.style.display = "none";
          }, 5000);
          
          // If API fails, open first Draft row as fallback
          console.log("⚠️ [SCANNER] API completely failed, falling back to Draft row search:", trayId);
          openPriorityRowModal(trayId);
        });
    }
    
    // Function to find and open modal for specific batch_id
    function openRowModalByBatchId(trayId, batchId) {
      console.log("🎯 [SCANNER] Finding row for batch ID:", batchId);
      
      const allDataRows = document.querySelectorAll('#order-listing tbody tr');
      
      if (allDataRows.length === 0) {
        showScanError("No data available in the table!");
        return;
      }
      
      let targetRow = null;
      
      // Look for the row with matching batch_id
      for (let i = 0; i < allDataRows.length; i++) {
        const row = allDataRows[i];
        const rowBatchId = row.getAttribute('data-batch-id');
        
        console.log(`🔍 [SCANNER] Row ${i + 1} batch_id: "${rowBatchId}"`);
        
        if (rowBatchId && rowBatchId === batchId) {
          console.log("✨ [SCANNER] Found matching batch row at position", i + 1);
          targetRow = row;
          break;
        }
      }
      
      // If no matching batch found, show error
      if (!targetRow) {
        console.log("❌ [SCANNER] No row found for batch ID:", batchId);
        showScanError(`No row found for batch ${batchId}!`);
        return;
      }
      
      // Find the tray scan button in the target row
      const trayScanBtn = targetRow.querySelector('.tray-scan-btn');
      
      if (!trayScanBtn) {
        showScanError("Tray scan button not available for the selected row!");
        return;
      }
      
      const rowIndex = Array.from(allDataRows).indexOf(targetRow) + 1;
      console.log(`🎯 [SCANNER] Opening modal for specific batch row ${rowIndex}`);
      
      // Click the tray scan button to open modal
      trayScanBtn.click();
      
      // Pre-fill the scanned tray ID in the modal
      setTimeout(() => {
        const modal = document.getElementById('trayScanModal');
        if (modal && modal.style.display === 'flex') {
          findAndFillNextEmptyTraySlot(modal, trayId);
        }
      }, 1000);
      
      scanStatus.style.color = "#28a745";
      scanStatus.textContent = `Batch ${batchId} modal opened!`;
    }
    
    // Function to find and open priority row modal (Draft first, then first available) - FALLBACK ONLY
    function openPriorityRowModal(trayId) {
      console.log("🎯 [SCANNER] Fallback: Finding priority row for tray ID:", trayId);
      
      const allDataRows = document.querySelectorAll('#order-listing tbody tr');
      
      if (allDataRows.length === 0) {
        showScanError("No data available in the table!");
        return;
      }
      
      let targetRow = null;
      let rowType = "";
      
      // Step 1: Look for the first "Draft" status row
      for (let i = 0; i < allDataRows.length; i++) {
        const row = allDataRows[i];
        const lotStatusCell = row.cells[14]; // Lot Status is the 15th column (index 14)
        
        if (lotStatusCell) {
          const statusText = lotStatusCell.textContent.trim();
          console.log(`🔍 [SCANNER] Row ${i + 1} lot status:`, statusText);
          
          if (statusText.includes('Draft')) {
            console.log("✨ [SCANNER] Found Draft row at position", i + 1);
            targetRow = row;
            rowType = "Draft";
            break;
          }
        }
      }
      
      // Step 2: If no Draft found, use the first available row
      if (!targetRow) {
        console.log("📝 [SCANNER] No Draft rows found, using first available row");
        targetRow = allDataRows[0];
        rowType = "First Available";
      }
      
      // Find the tray scan button in the target row
      const trayScanBtn = targetRow.querySelector('.tray-scan-btn');
      
      if (!trayScanBtn) {
        showScanError("Tray scan button not available for the selected row!");
        return;
      }
      
      const rowIndex = Array.from(allDataRows).indexOf(targetRow) + 1;
      console.log(`🎯 [SCANNER] Opening ${rowType} modal for row ${rowIndex}`);
      
      // Click the tray scan button to open modal
      trayScanBtn.click();
      
      // Enhanced logic for Draft rows: find next empty tray ID slot
      setTimeout(() => {
        const modal = document.getElementById('trayScanModal');
        if (modal && modal.style.display === 'flex') {
          
          if (rowType === "Draft") {
            // For Draft rows, find the next empty tray ID slot
            findAndFillNextEmptyTraySlot(modal, trayId);
          } else {
            // For non-Draft rows, use the first tray ID input
            const trayIdInput = modal.querySelector('input[placeholder="Enter Tray ID"]');
            if (trayIdInput) {
              trayIdInput.focus();
              trayIdInput.value = trayId;
              console.log("📝 [SCANNER] Pre-filled tray ID in first slot:", trayId);
              
              // Trigger input event for any validation
              trayIdInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
          }
        }
      }, 1000);
      
      scanStatus.style.color = "#28a745";
      scanStatus.textContent = `${rowType} modal opened!`;
    }

    // Function to find and fill next empty tray ID slot in Draft modals
    function findAndFillNextEmptyTraySlot(modal, trayId) {
      console.log("🔍 [DRAFT] Searching for next empty tray ID slot in Draft modal");
      
      // Look for the tray scan details grid/table in the modal (try both possible IDs)
      let trayScanDetails = modal.querySelector('#trayScanDetails_DayPlanning');
      if (!trayScanDetails) {
        trayScanDetails = modal.querySelector('#trayScanDetails');
      }
      
      if (!trayScanDetails) {
        console.log("⚠️ [DRAFT] Tray scan details container not found, searching entire modal");
      }
      
      // Find all tray ID input fields in the modal (various possible selectors)
      const trayIdInputs = modal.querySelectorAll([
        'input.tray-id-input',
        'input[placeholder*="Tray ID"]',
        'input[placeholder*="tray ID"]', 
        'input[placeholder*="Enter Tray"]',
        'input[id*="tray"]',
        'input[name*="tray"]',
        'input[data-tray-id]',
        'input[type="text"]:not([placeholder*="validation"]):not([placeholder*="info"])'
      ].join(', '));
      
      if (trayIdInputs.length === 0) {
        console.log("⚠️ [DRAFT] No tray ID inputs found, using any text input as fallback");
        const allTextInputs = modal.querySelectorAll('input[type="text"]');
        if (allTextInputs.length > 0) {
          allTextInputs[0].focus();
          allTextInputs[0].value = trayId;
          console.log("📝 [DRAFT] Used fallback text input");
          allTextInputs[0].dispatchEvent(new Event('input', { bubbles: true }));
        }
        return;
      }
      
      console.log(`🔍 [DRAFT] Found ${trayIdInputs.length} tray ID input fields`);
      
      // Check if there's a currently focused empty tray-id-input in the modal
      const activeElement = document.activeElement;
      if (activeElement && activeElement.classList.contains('tray-id-input') && activeElement.value.trim() === '' && activeElement.closest('#trayScanModal')) {
        activeElement.focus();
        activeElement.value = trayId;
        console.log(`📝 [DRAFT] Pre-filled tray ID "${trayId}" in currently focused empty slot`);
        activeElement.dispatchEvent(new Event('input', { bubbles: true }));
        activeElement.dispatchEvent(new Event('change', { bubbles: true }));
        // Update scan status
        scanStatus.textContent = `Focused slot filled!`;
        return;
      }
      
      // CORRECTED LOGIC: Find first truly empty slot, never overwrite existing data
      let targetInput = null;
      let targetSlotIndex = -1;
      
      // Search through all inputs to find the first truly empty one
      for (let i = 0; i < trayIdInputs.length; i++) {
        const input = trayIdInputs[i];
        const currentValue = input.value ? input.value.trim() : '';
        
        console.log(`🔍 [DRAFT] Checking slot ${i + 1}: "${currentValue}" (${currentValue ? 'filled' : 'empty'})`);
        
        if (!currentValue || currentValue === '') {
          targetInput = input;
          targetSlotIndex = i + 1;
          console.log(`✨ [DRAFT] Found first empty slot at position ${targetSlotIndex}`);
          break;
        }
      }
      
      // Fill the target slot or warn if all are filled
      if (targetInput) {
        targetInput.focus();
        targetInput.value = trayId;
        console.log(`📝 [DRAFT] Pre-filled tray ID "${trayId}" in slot ${targetSlotIndex}`);
        
        // Trigger input event for any validation
        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
        
        // Update scan status with slot information
        scanStatus.textContent = `Draft slot ${targetSlotIndex} filled!`;
      } else {
        // All slots are filled - warn user instead of overwriting
        console.log("⚠️ [DRAFT] All slots are filled - cannot add more tray IDs");
        scanStatus.style.color = "#dc3545";
        scanStatus.textContent = "All tray slots filled!";
        
        // Still focus on the last input for user awareness
        const lastInput = trayIdInputs[trayIdInputs.length - 1];
        if (lastInput) {
          lastInput.focus();
        }
        
        // Reset scanner status after warning
        setTimeout(() => {
          if (isScanning) {
            scanStatus.style.color = "#28a745";
            scanStatus.textContent = "PLEASE SCAN";
          }
        }, 3000);
      }
    }

    
    // Function to show scan errors
    function showScanError(message) {
      scanStatus.style.color = "#dc3545";
      scanStatus.textContent = message;
      scanInput.value = "";
      
      // Keep scanner active for retry
      if (isScanning) {
        scanInput.focus();
        
        // Reset to scanning mode after error
        setTimeout(() => {
          if (isScanning) {
            scanStatus.style.color = "#28a745";
            scanStatus.textContent = "PLEASE SCAN";
          }
        }, 3000);
      }
    }

    // Listen for Enter key (traditional scanner behavior)
    scanInput.addEventListener("keydown", function (e) {
      if (e.key === "Enter" && isScanning) {
        e.preventDefault();
        const trayId = scanInput.value.trim();
        if (trayId.length >= 4) { // Reduced minimum length for testing
          validateBarcode(trayId);
        }
      }
    });
    
    // Listen for input events (rapid typing or paste operations)
    scanInput.addEventListener("input", function (e) {
      console.log("⌨️ [SCANNER] Input event triggered, value:", `"${scanInput.value}"`, "isScanning:", isScanning);
      if (isScanning) {
        processBarcodeInput();
      }
    });
    
    // Handle paste events (some scanners simulate paste)
    scanInput.addEventListener("paste", function (e) {
      console.log("📋 [SCANNER] Paste event triggered, isScanning:", isScanning);
      if (isScanning) {
        setTimeout(() => {
          console.log("📋 [SCANNER] Processing paste, value:", `"${scanInput.value}"`);
          processBarcodeInput();
        }, 10);
      }
    });
    
    // Listen for keydown events (some scanners behave differently)
    scanInput.addEventListener("keydown", function (e) {
      if (isScanning && e.key.length === 1) { // Only log actual character keys, not special keys
        console.log("🔤 [SCANNER] Keydown event:", e.key, "Current value:", `"${scanInput.value}"`);
      }
    });
    
    // Add a global test function for debugging
    window.testScanner = function(trayId) {
      console.log("🧪 [TEST] Manual scanner test with tray ID:", trayId);
      if (isScanning) {
        console.log("🧪 [TEST] Scanner already active, processing tray ID");
        validateBarcode(trayId);
      } else {
        console.log("🧪 [TEST] Scanner not active, activating and processing");
        isScanning = true;
        scanInput.value = trayId;
        validateBarcode(trayId);
      }
    };
    
    console.log("🔧 [SCANNER] Test function available: window.testScanner('JB-A00057')");
    
    // Escape key to cancel scanning
    document.addEventListener("keydown", function (e) {
      if (e.key === "Escape" && isScanning) {
        stopScanning();
        console.log("🚫 [SCANNER] Scanning cancelled by Escape key");
      }
    });
    
    // Auto-stop scanning when modal opens (user manually clicked a button)
    document.addEventListener('click', function(e) {
      if (e.target.closest('.tray-scan-btn') && isScanning) {
        console.log("🎯 [SCANNER] Manual tray scan clicked - stopping scanner");
        stopScanning();
      }
    });
  }
});
</script>

<!-- Auto-open scanned batch modal when redirected with open_batch param -->
<script nonce="{{ csp_nonce }}">
document.addEventListener('DOMContentLoaded', function() {
  try {
    const params = new URLSearchParams(window.location.search);
    const openBatch = params.get('open_batch');
    if (openBatch) {
      // small delay to allow table rows to be rendered
      setTimeout(() => {
        console.log('🔀 [SCANNER] open_batch detected, attempting to open:', openBatch);
        const btn = document.querySelector(`.tray-scan-btn[data-batch-id="${openBatch}"]`);
        if (btn) {
          // click the button to open existing modal logic
          btn.click();
        } else {
          console.log('⚠️ [SCANNER] batch button not found on page for open_batch', openBatch);
        }

        // Remove open_batch from URL so it doesn't reopen on refresh
        params.delete('open_batch');
        const newQuery = params.toString();
        const newUrl = window.location.pathname + (newQuery ? '?' + newQuery : '');
        history.replaceState(null, '', newUrl);
      }, 600);
    }
  } catch (e) {
    console.warn('⚠️ [SCANNER] auto-open handler failed:', e);
  }
});
</script>

<script nonce="{{ csp_nonce }}">
// Complete Redo Script with Row Removal Functionality

document.addEventListener("DOMContentLoaded", function () {
  const trayIDRedoBtn = document.getElementById("trayIDRedoBtn");
  if (trayIDRedoBtn) {
    trayIDRedoBtn.addEventListener("click", function () {
      const detailsDiv = document.getElementById("trayScanDetails");
      if (!detailsDiv) return;

      // Clear all tray ID inputs
      const trayIdInputs = detailsDiv.querySelectorAll('.tray-id, .tray-id-input');
      trayIdInputs.forEach((input, index) => {
        input.value = '';
        input.style.borderColor = '';
        input.style.backgroundColor = '';
        
        // Remove any error/success messages for this input
        const errorElement = input.parentNode.querySelector('.tray-id-error, .tray-id-success');
        if (errorElement) {
          errorElement.remove();
        }
      });
      
      // Uncheck the verification checkbox if checked
      const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
      if (verifyCheckbox && verifyCheckbox.checked) {
        verifyCheckbox.checked = false;
      }
      
      const errorFooter = document.getElementById('trayQtyErrorFooter');
      if (errorFooter) {
        errorFooter.textContent = 'All tray IDs cleared';
        errorFooter.style.color = '#007bff';
      }
      
      console.log('🔄 Redo: Cleared all tray IDs and unchecked verification');
      
    
      
      // ✅ NEW: Focus on first empty tray ID input after clearing
      const firstTrayIdInput = detailsDiv.querySelector('.tray-id-input');
      if (firstTrayIdInput) {
        setTimeout(() => {
          firstTrayIdInput.focus();
          console.log('🎯 Cursor placed on first tray ID input');
        }, 100); // Small delay to ensure DOM is updated
      }
      
      // Update UI elements
      updateUIElements();
    });
  }

  // Attach click handler to the initial redo button if it exists
  const initialRedoBtn = document.getElementById("trayScanRedoClearBtn");
  if (initialRedoBtn) {
    initialRedoBtn.onclick = function() {
      console.log('✅ Initial redo button clicked!');
      let detailsDiv = document.getElementById("trayScanDetails");
      let errorFooterId = 'trayQtyErrorFooter';
      if (!detailsDiv || detailsDiv.querySelectorAll('.tray-id-input').length === 0) {
        detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
        errorFooterId = 'trayErrorMessage';
      }
      
      console.log('🔍 Using detailsDiv:', detailsDiv ? detailsDiv.id : 'not found');
      
      if (detailsDiv) {
        clearTrayIdInputs(detailsDiv, errorFooterId);
        console.log('🔄 Cleared tray IDs from modal');
      } else {
        console.log('❌ No active tray scan modal found');
      }
    };
  }
  
  // ✅ NEW: Add handler for Day Planning modal redo button
  const trayScanRedoBtn = document.getElementById("trayScanRedoBtn");
  if (trayScanRedoBtn) {
    trayScanRedoBtn.addEventListener("click", function () {
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      if (!detailsDiv) return;

      // Clear all tray ID inputs in Day Planning modal
      const trayIdInputs = detailsDiv.querySelectorAll('.tray-id, .tray-id-input');
      trayIdInputs.forEach((input, index) => {
        input.value = '';
        input.style.borderColor = '';
        input.style.backgroundColor = '';
        
        // Remove any error/success messages for this input
        const errorElement = input.parentNode.querySelector('.tray-id-error, .tray-id-success');
        if (errorElement) {
          errorElement.remove();
        }
      });
      
      // Uncheck the verification checkbox if checked
      const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
      if (verifyCheckbox && verifyCheckbox.checked) {
        verifyCheckbox.checked = false;
      }
      
      console.log('🔄 Day Planning Redo: Cleared all tray IDs and unchecked verification');

      window.currentTrayScanData = getCurrentTrayData().map(d => ({ ...d, trayId: '' }));

      
      // ✅ NEW: Clear the error footer to remove persistent verified message
      const errorFooter = document.getElementById('trayErrorMessage');
      if (errorFooter) {
        errorFooter.style.display = 'none';
        const errorText = document.getElementById('trayErrorText');
        if (errorText) {
          errorText.textContent = '';
        }
      }
      
      // ✅ NEW: Update the button's data attribute to reflect unverified state
      const currentBatchId = window.currentModalConfig?.batchId;
      if (currentBatchId) {
        const openerBtn = document.querySelector(`.tray-scan-btn[data-batch-id="${currentBatchId}"]`);
        if (openerBtn) {
          openerBtn.setAttribute('data-top-tray-qty-verified', 'False');
        }
      }
      
      // ✅ NEW: Focus on first empty tray ID input after clearing
      const firstTrayIdInput = detailsDiv.querySelector('.tray-id-input');
      if (firstTrayIdInput) {
        setTimeout(() => {
          firstTrayIdInput.focus();
          console.log('🎯 Day Planning: Cursor placed on first tray ID input');
        }, 100); // Small delay to ensure DOM is updated
      }
    });
  }
});



// Helper function to clear tray ID inputs
function clearTrayIdInputs(detailsDiv, errorFooterId) {
  try {
    // Try multiple selectors to find tray ID inputs
    let trayIdInputs = detailsDiv.querySelectorAll('input.tray-id-input');
    if (trayIdInputs.length === 0) {
      trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    }
    
    console.log('🔍 Found tray ID inputs to clear:', trayIdInputs.length);
    
    if (trayIdInputs.length === 0) {
      console.log('⚠️ No tray ID inputs found to clear');
      return;
    }
    
    trayIdInputs.forEach((input, index) => {
      try {
        console.log(`Clearing input ${index}: "${input.value}" -> ""`); 
        input.value = '';
        input.style.borderColor = '';
        input.style.backgroundColor = '';
        
        // Trigger input event so summary and submit button update correctly
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
        
        const errorElement = input.parentNode.querySelector('.tray-id-error, .tray-id-success');
        if (errorElement) {
          errorElement.remove();
        }
      } catch (e) {
        console.error('Error clearing input:', e);
      }
    });
    
    const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
    if (verifyCheckbox && verifyCheckbox.checked) {
      verifyCheckbox.checked = false;
      verifyCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
    }
      
    const errorFooter = document.getElementById(errorFooterId);
    if (errorFooter) {
      if (errorFooterId === 'trayQtyErrorFooter') {
        errorFooter.textContent = 'All tray IDs cleared';
        errorFooter.style.color = '#007bff';
      } else {
        errorFooter.style.display = 'none';
        const errorText = errorFooter.querySelector('#trayErrorText');
        if (errorText) {
          errorText.textContent = '';
        }
      }
    }

    // Final UI update
    if (typeof updateUIElements === 'function') {
      updateUIElements();
    }
    
    console.log('🔄 Cleared tray IDs from modal successfully');
  } catch (e) {
    console.error('Error in clearTrayIdInputs:', e);
  }
}
    
    const firstTrayIdInput = detailsDiv.querySelector('.tray-id-input');
    if (firstTrayIdInput) {
      setTimeout(() => {
        firstTrayIdInput.focus();
        console.log('🎯 Cursor placed on first tray ID input');
      }, 100);
    }
}


// ✅ ENHANCED: Re-attach all event listeners after rebuild
function reattachAllEventListenersAfterRebuild() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return;
  
  console.log('🔗 Re-attaching all event listeners after rebuild');

  // ✅ 1. TRAY ID INPUT EVENT LISTENERS
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
  trayIdInputs.forEach((input, idx, allInputs) => {
      input.addEventListener('input', function () {
          let prevError = input.parentNode.querySelector('.tray-id-error');
          if (prevError) prevError.remove();
          input.style.borderColor = '';
          input.style.backgroundColor = '';

          // Allow only alphabets, numbers, and hyphen for tray scan
          input.value = input.value.replace(/[^A-Za-z0-9-]/g, '');
          // Enforce max 9 characters for tray scan
          if (input.value.length > 9) {
            input.value = input.value.slice(0, 9);
          }

          // ✅ NEW: Uncheck checkbox when any tray ID is modified
          const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
          if (verifyCheckbox && !verifyCheckbox.disabled) {
            verifyCheckbox.checked = false;
            console.log('🔄 Unchecked checkbox due to tray ID input change');
          }

          updateUIElements();
      });
  
      input.addEventListener('blur', async function () {
          let prevError = input.parentNode.querySelector('.tray-id-error');
          if (prevError) prevError.remove();
  
          const trayId = input.value.trim();
          if (!trayId) {
              updateUIElements();
              return;
          }
  
          // Check for duplicates in modal
          let duplicateInModal = false;
          allInputs.forEach((otherInput, otherIdx) => {
              if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                  duplicateInModal = true;
              }
          });
          if (duplicateInModal) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'tray-id-error';
              errorDiv.style.color = 'red';
              errorDiv.style.fontSize = '12px';
              errorDiv.textContent = 'Already scanned in a row!';
              input.parentNode.appendChild(errorDiv);
              input.focus();
              input.select();
              updateUIElements();
              return;
          }
  
          // Backend validation
          try {
              const currentBatchId = window.currentTrayScanBatchId || '';
              const resp = await fetch(`/dayplanning/tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(currentBatchId)}`);
              const result = await resp.json();
  
              if (result.tray_not_in_system) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = '#d32f2f';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `<div style="color: #d32f2f;">❌ Invalid Barcode ID</div>`;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.already_scanned) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = '#d32f2f';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `<div style="color: #d32f2f;">❌ Already Scanned</div>`;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.tray_type_error) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = 'red';
                  errorDiv.style.fontSize = '11px';
                  errorDiv.style.fontWeight = 'bold';
                  errorDiv.style.backgroundColor = '#ffebee';
                  errorDiv.style.padding = '4px 6px';
                  errorDiv.style.borderRadius = '4px';
                  errorDiv.style.marginTop = '4px';
                  errorDiv.innerHTML = `
                      <div style="color: #d32f2f;">❌ Tray Type Mismatch</div>
                      <div style="font-size: 10px; margin-top: 2px;">
                          Batch Type: <strong>${result.batch_tray_type || 'Not Set'}</strong><br>
                          Scanned Type: <strong>${result.scanned_tray_type || 'Not Set'}</strong>
                      </div>
                  `;
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#ff5722';
                  input.style.backgroundColor = '#fff3e0';
                  input.focus();
                  input.select();
              } else if (!result.available) {
                  const errorDiv = document.createElement('div');
                  errorDiv.className = 'tray-id-error';
                  errorDiv.style.color = 'red';
                  errorDiv.style.fontSize = '12px';
                  errorDiv.textContent = result.error || 'Tray not available!';
                  input.parentNode.appendChild(errorDiv);
                  input.style.borderColor = '#d32f2f';
                  input.style.backgroundColor = '#ffebee';
                  input.focus();
                  input.select();
              } else if (result.delink_tray) {
                  input.style.borderColor = '#4caf50';
                  input.style.backgroundColor = '#f1f8e9';
                  const infoDiv = document.createElement('div');
                  infoDiv.className = 'tray-id-success';
                  infoDiv.style.color = '#2e7d32';
                  infoDiv.style.fontSize = '11px';
                  infoDiv.style.fontWeight = 'bold';
                  infoDiv.innerHTML = `✅ Delinked - available for reuse`;
                  input.parentNode.appendChild(infoDiv);
                  setTimeout(() => {
                      if (infoDiv.parentNode) {
                          infoDiv.parentNode.removeChild(infoDiv);
                      }
                  }, 2000);
              } else if (result.available) {
                  input.style.borderColor = '#4caf50';
                  input.style.backgroundColor = '#f1f8e9';
                  if (result.status === 'pre_configured') {
                      const successDiv = document.createElement('div');
                      successDiv.className = 'tray-id-success';
                      successDiv.style.color = '#2e7d32';
                      successDiv.style.fontSize = '11px';
                      successDiv.style.fontWeight = 'bold';
                      successDiv.innerHTML = `✅ Available (${result.tray_type || 'Type not set'})`;
                      input.parentNode.appendChild(successDiv);
                      setTimeout(() => {
                          if (successDiv.parentNode) {
                              successDiv.parentNode.removeChild(successDiv);
                          }
                      }, 2000);
                  }
              }
          } catch (e) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'tray-id-error';
              errorDiv.style.color = '#d32f2f';
              errorDiv.style.fontSize = '11px';
              errorDiv.style.fontWeight = 'bold';
              errorDiv.style.backgroundColor = '#ffebee';
              errorDiv.style.padding = '4px 6px';
              errorDiv.style.borderRadius = '4px';
              errorDiv.style.marginTop = '4px';
              errorDiv.innerHTML = `<div style="color: #d32f2f;">Not exists</div>`;
              input.parentNode.appendChild(errorDiv);
              input.style.borderColor = '#d32f2f';
              input.style.backgroundColor = '#ffebee';
              input.focus();
              input.select();
                      const nextInput = allInputs[idx + 1];
                      if (nextInput) {
                          nextInput.focus();
                          nextInput.select();
                      
                  } else {
                      input.focus();
                      input.select();
                  }
              }, 50);
          }
      });


  // ✅ 2. TOP TRAY QUANTITY EDIT FUNCTIONALITY 
  const editBtn = detailsDiv.querySelector('.tray-edit-btn');
  const qtyInput = detailsDiv.querySelector('.tray-qty-input');
  const trayCapacity = window.currentModalConfig ? window.currentModalConfig.trayCapacity : 12;
  const errorFooter = document.getElementById('trayQtyErrorFooter');
  
  if (editBtn && qtyInput) {
      // ✅ ENHANCED: Store original quantity for decrease-only validation
      let originalQuantity = parseInt(qtyInput.value, 10) || 0;
      
      editBtn.addEventListener('click', function (e) {
          e.preventDefault();
          // ✅ Capture original quantity at edit time
          originalQuantity = parseInt(qtyInput.value, 10) || 0;
          console.log('✏️ Edit started after rebuild - Original quantity:', originalQuantity);
          
          qtyInput.removeAttribute('readonly');
          qtyInput.focus();
          qtyInput.select();
      });
  
      qtyInput.addEventListener('input', function () {
          if (errorFooter) {
              errorFooter.textContent = 'Qty modified';
              errorFooter.style.color = '#007bff';
          }          
          let val = parseInt(qtyInput.value, 10) || 0;
          
          // ✅ ENHANCED: Only allow decrease from original quantity
          if (val > originalQuantity) {
              qtyInput.value = originalQuantity;
              if (errorFooter) {
                  errorFooter.textContent = `Quantity can only be decreased. Maximum allowed: ${originalQuantity}`;
                  errorFooter.style.color = '#d32f2f';
              }
              val = originalQuantity;
          } else if (val > trayCapacity) {
              qtyInput.value = trayCapacity;
              if (errorFooter) errorFooter.textContent = `Tray Qty cannot exceed Tray Capacity (${trayCapacity})`;
          } else if (val < 0) {
              qtyInput.value = 0;
              val = 0;
          }
          
         
          updateUIElements();
      });
  
      qtyInput.addEventListener('keydown', function (ev) {
          if (ev.key === 'Enter') {
              qtyInput.setAttribute('readonly', 'readonly');
              qtyInput.blur();
          }
      });
  
      qtyInput.addEventListener('blur', function () {
          qtyInput.setAttribute('readonly', 'readonly');
          if (errorFooter) errorFooter.textContent = '';
      });
  }

  // ✅ 3. CHECKBOX VALIDATION LISTENER
const verifyCheckbox = detailsDiv.querySelector('input[type="checkbox"]');
if (verifyCheckbox) {
    verifyCheckbox.addEventListener('change', function() {
        if (verifyCheckbox.checked) {
            if (!validateAllTrayIds()) {
                verifyCheckbox.checked = false;
                if (errorFooter) {
                    errorFooter.textContent = '';
                }
                Swal.fire({
                    icon: 'warning',
                    title: 'Incomplete Data',
                    text: 'Please fill all Tray IDs before verifying.',
                    confirmButtonColor: '#007bff'
                });
                return;
            }
            if (errorFooter) {
                errorFooter.textContent = 'Top tray qty verified';
                errorFooter.style.color = 'green';
            }
        } else {
            if (errorFooter) {
                errorFooter.textContent = '';
            }
        }
        updateUIElements();
    });
}

  console.log('✅ All event listeners re-attached after rebuild');
  
  // ✅ ENHANCED: Auto-focus first tray input after rebuild
  setTimeout(() => {
    autoFocusFirstTrayInput();
  }, 50);


// Fixed updateTrayScanSummary function
function updateTrayScanSummary() {
  const detailsDiv = document.getElementById("trayScanDetails");
  const summaryDiv = document.getElementById("trayScanSummary");
  if (!detailsDiv || !summaryDiv) return;

  const qtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');

  // If no rows yet, show 0/0
  if (qtyInputs.length === 0 || trayIdInputs.length === 0) {
    const textSpan = summaryDiv.querySelector('span');
    if (textSpan) {
      textSpan.textContent = `Qty to Scan: 0/0`;
    } else {
      summaryDiv.innerHTML = `<span style="white-space: nowrap;">Qty to Scan: 0/0</span><img src="/static/assets/icons/redo2.png" alt="Redo" id="trayScanRedoClearBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;" />`;
    }
    return;
  }

  // Get actual batch quantity instead of calculating from inputs
  const batchId = window.currentTrayScanBatchId;
  let totalQuantity = 0;
  
  if (batchId) {
    const targetButton = document.querySelector(`.tray-scan-btn[data-batch-id="${batchId}"]`);
    if (targetButton) {
      const actualBatchQuantity = targetButton.getAttribute('data-total-batch-quantity');
      totalQuantity = parseInt(actualBatchQuantity) || 0;
    }
  }
  
  // If we couldn't get the actual batch quantity, fallback to calculation
  if (totalQuantity === 0) {
    for (let i = 0; i < qtyInputs.length; i++) {
      const qty = parseInt(qtyInputs[i].value, 10) || 0;
      if (qty > 0) {
        totalQuantity += qty;
      }
    }
  }

  let scannedQuantity = 0;

  for (let i = 0; i < qtyInputs.length; i++) {
    const qty = parseInt(qtyInputs[i].value, 10) || 0;
    
    if (qty > 0) {
      // Only count if tray ID is filled AND has no validation errors
      if (trayIdInputs[i] && trayIdInputs[i].value.trim()) {
        const hasError = trayIdInputs[i].parentNode.querySelector('.tray-id-error');
        const hasInvalidStyle = trayIdInputs[i].style.borderColor === 'rgb(211, 47, 47)' || 
                               trayIdInputs[i].style.borderColor === '#d32f2f' ||
                               trayIdInputs[i].style.borderColor === '#ff5722';
        
        // Only count if no error div and no error styling
        if (!hasError && !hasInvalidStyle) {
          scannedQuantity += qty;
        }
      }
    }
  }

  // Show: scanned quantity / total quantity
  const textSpan = summaryDiv.querySelector('span');
  if (textSpan) {
    textSpan.textContent = `Qty to Scan: ${scannedQuantity}/${totalQuantity}`;
  } else {
    summaryDiv.innerHTML = `<span style="white-space: nowrap;">Qty to Scan: ${scannedQuantity}/${totalQuantity}</span><img src="/static/assets/icons/redo2.png" alt="Redo" id="trayScanRedoClearBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;" />`;
  }
}

// Updated validation function to not reset quantities
function validateAllTrayIds() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return false;
  
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
  let allFilled = true;
  
  trayIdInputs.forEach((input, index) => {
    if (!input.value.trim()) {
      allFilled = false;
      console.log(`Tray ID ${index + 1} is empty:`, input.value);
    } else {
      console.log(`Tray ID ${index + 1} is filled:`, input.value);
    }
  });
  
  console.log('All Tray IDs filled:', allFilled, 'Total inputs:', trayIdInputs.length);
  return allFilled && trayIdInputs.length > 0;
}

// Listen for changes in tray ID fields only (not quantities unless manually edited)
document.addEventListener("DOMContentLoaded", function () {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (detailsDiv) {
    detailsDiv.addEventListener("input", function (e) {
      // Only update when tray ID fields change, not quantity fields automatically
      if (e.target.matches('input[type="text"]')) {
        updateTrayScanSummary();
        updateUIElements();
      }
      // For quantity fields, only update if user manually changes them
      if (e.target.matches('input[type="number"]') && !e.target.readOnly) {
        updateTrayScanSummary();
      }
    });
  }
});

// ✅ ENHANCED: Get current tray data from DOM elements (real-time data)
function getCurrentDOMTrayScanData() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return [];

  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
  const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
  
  const data = [];
  for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
    data.push({
      trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
      trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
      position: i,
      draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
    });
  }
  
  console.log('📊 Current DOM data extracted:', data);
  return data;
}

// ✅ ENHANCED: Auto-focus first empty tray ID input
function autoFocusFirstTrayInput() {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) {
    console.warn('⚠️ Cannot focus - details div not found');
    return;
  }
  
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
  for (let input of trayIdInputs) {
    if (input.value.trim() === '') {
      setTimeout(() => {
        input.focus();
        input.select();
        console.log('🎯 Auto-focused first empty tray ID input');
      }, 50);
      return;
    }
  }
  // If no empty inputs, don't focus
  console.log('🎯 No empty tray ID inputs to focus');
}

// ✅ ENHANCED: Focus next empty tray ID input
function focusNextEmptyTrayInput(currentInput) {
  const detailsDiv = document.getElementById("trayScanDetails");
  if (!detailsDiv) return;
  
  const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
  const currentIndex = Array.from(trayIdInputs).indexOf(currentInput);
  if (currentIndex === -1) return;
  
  for (let i = currentIndex + 1; i < trayIdInputs.length; i++) {
    if (trayIdInputs[i].value.trim() === '') {
      setTimeout(() => {
        trayIdInputs[i].focus();
        trayIdInputs[i].select();
        console.log('🎯 Focused next empty tray ID input');
      }, 50);
      return;
    }
  }
  // If no next empty, don't focus
}

// ✅ ENHANCED: Function to create backup of original data (call this when modal first opens)
function createBackupOriginalData() {
  if (window.originalTrayScanData && window.originalTrayScanData.length > 0 && !window.backupOriginalTrayScanData) {
    window.backupOriginalTrayScanData = JSON.parse(JSON.stringify(window.originalTrayScanData));
    console.log('💾 Backup created with', window.backupOriginalTrayScanData.length, 'rows');
  }
}

// ✅ ENHANCED: Function to reset all data (call this when modal closes)
function resetTrayScanData() {
  window.originalTrayScanData = null;
  window.backupOriginalTrayScanData = null;
  console.log('🗑️ All tray scan data reset');
}

</script>

  <script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {

      const cancelBtn = document.getElementById("trayScanCancelBtn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", function () {
          const modal = document.getElementById("trayScanModal");
          if (modal) modal.classList.remove("open");
        });
      }

       // DELETE BUTTON HANDLER
      document.querySelectorAll('a[title="Delete"]').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          const row = btn.closest('tr');
          if (!row) return;
          const trayScanLink = row.querySelector('.tray-scan-btn');
          if (!trayScanLink) return;
          const batchId = trayScanLink.getAttribute('data-batch-id');
          if (!batchId) {
            Swal.fire('Error', 'Batch ID not found!', 'error');
            return;
          }
          Swal.fire({
            title: 'Are you sure?',
            text: 'Do you really want to delete this batch?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Yes, delete it!',
            cancelButtonText: 'Cancel'
          }).then((result) => {
            if (result.isConfirmed) {
              fetch('/dayplanning/delete_batch/', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ batch_id: batchId })
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) {
                  row.remove();
                  Swal.fire({
                    icon: 'success',
                    title: 'Deleted!',
                    text: 'Batch has been deleted.',
                    timer: 1200,
                    showConfirmButton: false
                  });                  
                } else {
                  Swal.fire('Error', data.error || 'Delete failed', 'error');
                }
              });
            }
          });
        });
      });

// REPLACE the entire edit button section (around lines 640-780) with this COMPLETE FIXED VERSION:

// REPLACE the entire edit button section with this INDIVIDUAL SAVE VERSION:

document.querySelectorAll('.edit-qty-btn').forEach(function(btn) {
  btn.addEventListener('click', async function(e) {
    e.preventDefault();
    const row = btn.closest('tr');
    if (!row) return;
    const qtyCell = row.querySelector('td:nth-child(12)');
    const colorCell = row.querySelector('td:nth-child(5)');
    const batchId = btn.getAttribute('data-batch-id');
    const oldQty = qtyCell.textContent.trim();
    const oldColor = colorCell.textContent.trim();

    // Prevent multiple inputs
    if (qtyCell.querySelector('input') || colorCell.querySelector('.color-arrow-up')) return;

    // Fetch plating colors from API
    let platingColors = [];
    try {
      const res = await fetch('/dayplanning/get_plating_colors/');
      const data = await res.json();
      if (data.success && Array.isArray(data.plating_colors)) {
        platingColors = data.plating_colors;
      }
    } catch (e) {}

    // Find current color index
    let colorIdx = platingColors.findIndex(c => c === oldColor);
    if (colorIdx === -1) colorIdx = 0;

    // Track what user is editing
    let isEditingColor = false;
    let isEditingQuantity = false;
    let colorChanged = false;
    let quantityChanged = false;

    // Build plating color arrows UI
    colorCell.innerHTML = `
      <div style="display:flex;align-items:center;gap:4px;">
        <button type="button" class="color-arrow-up" style="border:none;background:none;font-size:18px;">&#9650;</button>
        <input type="text" class="form-control color-input" value="${platingColors[colorIdx] || ''}" style="width:90px;text-align:center;background:#f8f8f8;" readonly />
        <button type="button" class="color-arrow-down" style="border:none;background:none;font-size:18px;">&#9660;</button>
      </div>
    `;

    qtyCell.innerHTML = `<input type="number" min="1" class="form-control qty-input" value="${oldQty}" style="width: 80px; display:inline-block;" />`;
    
    
    const qtyInput = qtyCell.querySelector('.qty-input');
    const colorInput = colorCell.querySelector('.color-input');
    const upBtn = colorCell.querySelector('.color-arrow-up');
    const downBtn = colorCell.querySelector('.color-arrow-down');

// FIND the arrow button handlers in your code and REPLACE with this:

// Arrow navigation - automatically focus color input after click
upBtn.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (colorIdx > 0) {
    colorIdx -= 1;
    colorInput.value = platingColors[colorIdx];
    isEditingColor = true;
    colorChanged = true;
    console.log('Color changed to:', colorInput.value);
    
    // ✅ NEW: Auto-focus color input after arrow click
    setTimeout(() => {
      colorInput.focus();
    }, 10);
  }
};

downBtn.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (colorIdx < platingColors.length - 1) {
    colorIdx += 1;
    colorInput.value = platingColors[colorIdx];
    isEditingColor = true;
    colorChanged = true;
    console.log('Color changed to:', colorInput.value);
    
    // ✅ NEW: Auto-focus color input after arrow click
    setTimeout(() => {
      colorInput.focus();
    }, 10);
  }
};

    // Quantity input events - marks quantity as being edited
    qtyInput.addEventListener('input', function() {
      isEditingQuantity = true;
      quantityChanged = true;
      console.log('Quantity changed to:', qtyInput.value);
    });

    qtyInput.addEventListener('focus', function() {
      isEditingQuantity = true;
    });

    colorInput.addEventListener('focus', function() {
      isEditingColor = true;
    });

    // INDIVIDUAL SAVE FUNCTIONS

    function saveQuantityOnly() {
      if (!quantityChanged) {
        console.log('No quantity changes to save');
        return;
      }

      const newQty = qtyInput.value.trim();
      if (!newQty || isNaN(newQty) || parseInt(newQty) <= 0) {
        Swal.fire('Error', 'Enter a valid quantity.', 'error');
        qtyInput.focus();
        return;
      }

      console.log('Saving ONLY quantity:', newQty);
      
      fetch('/dayplanning/update_batch_quantity_and_color/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          batch_id: batchId,
          total_batch_quantity: newQty,
          // Don't send plating_color - keep original
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          qtyCell.textContent = newQty;
          colorCell.textContent = oldColor; // Keep original color
          Swal.fire({
            icon: 'success',
            title: 'Quantity Updated!',
            text: `Quantity changed to ${newQty}`,
            timer: 1000,
            showConfirmButton: false
          }).then(() => location.reload());
        } else {
          Swal.fire('Error', data.error || 'Update failed', 'error');
          revertChanges();
        }
      })
      .catch(() => {
        Swal.fire('Error', 'Network error', 'error');
        revertChanges();
      });
    }

    function saveColorOnly() {
      if (!colorChanged) {
        console.log('No color changes to save');
        return;
      }

      const newColor = colorInput.value;
      console.log('Saving ONLY color:', newColor);
      
      fetch('/dayplanning/update_batch_quantity_and_color/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          batch_id: batchId,
          plating_color: newColor,
          // Don't send total_batch_quantity - keep original
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          colorCell.textContent = newColor;
          qtyCell.textContent = oldQty; // Keep original quantity
          Swal.fire({
            icon: 'success',
            title: 'Color Updated!',
            text: `Color changed to ${newColor}`,
            timer: 1000,
            showConfirmButton: false
          }).then(() => location.reload());
        } else {
          Swal.fire('Error', data.error || 'Update failed', 'error');
          revertChanges();
        }
      })
      .catch(() => {
        Swal.fire('Error', 'Network error', 'error');
        revertChanges();
      });
    }

    // INDIVIDUAL ENTER KEY HANDLERS

    // Quantity input - Enter saves ONLY quantity
    qtyInput.addEventListener('keydown', function(ev) {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        saveQuantityOnly();
      }
      if (ev.key === 'Escape') {
        revertChanges();
      }
    });

    // Color input - Enter saves ONLY color  
    colorInput.addEventListener('keydown', function(ev) {
      if (ev.key === 'ArrowUp') {
        ev.preventDefault();
        upBtn.click(); // Trigger arrow click
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault();
        downBtn.click(); // Trigger arrow click
      } else if (ev.key === 'Enter') {
        ev.preventDefault();
        saveColorOnly();
      } else if (ev.key === 'Escape') {
        revertChanges();
      }
    });

    // Revert function
    function revertChanges() {
      qtyCell.textContent = oldQty;
      colorCell.textContent = oldColor;
    }

    // Blur handlers - revert only if no changes made
    qtyInput.addEventListener('blur', function() {
      setTimeout(() => {
        const activeEl = document.activeElement;
        if (!activeEl || (!qtyCell.contains(activeEl) && !colorCell.contains(activeEl))) {
          if (!quantityChanged && !colorChanged) {
            revertChanges();
          }
        }
      }, 150);
    });

    colorInput.addEventListener('blur', function() {
      setTimeout(() => {
        const activeEl = document.activeElement;
        if (!activeEl || (!qtyCell.contains(activeEl) && !colorCell.contains(activeEl))) {
          if (!quantityChanged && !colorChanged) {
            revertChanges();
          }
        }
      }, 150);
    });

    // Initial focus on quantity input
    qtyInput.focus();
    qtyInput.select();
  });
});

      

const table = document.getElementById("order-listing");
      if (!table) {
        console.warn("Table with ID 'order-listing' not found.");
        return;
      }

      const headers = table.querySelectorAll("thead th");
      const tbody = table.querySelector("tbody");

      let sortDirection = {};

      headers.forEach((header, index) => {
        header.style.cursor = "pointer";

        header.addEventListener("click", function () {
          const rows = Array.from(tbody.querySelectorAll("tr"));
          const dir = sortDirection[index] === "asc" ? "desc" : "asc";
          sortDirection[index] = dir;

          rows.sort((a, b) => {
            const cellA = a.children[index].textContent.trim();
            const cellB = b.children[index].textContent.trim();
            const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
            const valB = isNaN(cellB) ? cellB : parseFloat(cellB);

            if (valA < valB) return dir === "asc" ? -1 : 1;
            if (valA > valB) return dir === "asc" ? 1 : -1;
            return 0;
          });

          tbody.innerHTML = "";
          rows.forEach((row) => tbody.appendChild(row));
        });
      });
    });
  </script>


<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      let openRemarkTooltip = null; // Global reference to track open tooltip

      // Helper function to close remark tooltip completely
      function closeRemarkTooltip(tooltip, trigger) {
        if (tooltip) {
          console.log('🔴 Closing remark tooltip completely');

          // Remove pinned class
          tooltip.classList.remove("pinned");

          // Hide the entire tooltip completely
          tooltip.style.opacity = "0";
          tooltip.style.pointerEvents = "none";
          tooltip.style.visibility = "hidden";
          tooltip.style.display = "none";

          // Hide close button
          const closeBtn = tooltip.querySelector('.remark-close-btn');
          if (closeBtn) closeBtn.style.display = 'none';

          // Remove visual indicator from trigger
          if (trigger) {
            trigger.style.backgroundColor = '';
            trigger.style.borderRadius = '';
          }

          // Clear global reference
          openRemarkTooltip = null;

          console.log('✅ Remark tooltip completely closed');
        }
      }

      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button:not(.remark-close-btn)") : null;
        var closeButton = tooltip ? tooltip.querySelector(".remark-close-btn") : null;
        var textarea = tooltip ? tooltip.querySelector("textarea") : null;

        function showTooltip() {
          tooltip.style.display = "block";
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          tooltip.style.pointerEvents = "auto";

          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
        }

        function hideTooltip() {
          if (!tooltip.classList.contains("pinned")) {
            tooltip.style.opacity = "0";
            tooltip.style.pointerEvents = "none";
            tooltip.style.visibility = "hidden";
            tooltip.style.display = "none";

            // Hide close button
            if (closeButton) closeButton.style.display = 'none';
          }
        }

        // Hover behavior (only when not pinned)
        trigger.addEventListener("mouseenter", function() {
          if (!tooltip.classList.contains("pinned")) {
            showTooltip();
            if (closeButton) closeButton.style.display = 'block';
          }
        });

        trigger.addEventListener("mouseleave", function () {
          if (!tooltip.classList.contains("pinned")) {
            setTimeout(function () {
              if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
                hideTooltip();
              }
            }, 100);
          }
        });

        if (tooltip) {
          tooltip.addEventListener("mouseenter", function() {
            if (!tooltip.classList.contains("pinned")) {
              showTooltip();
              if (closeButton) closeButton.style.display = 'block';
            }
          });

          tooltip.addEventListener("mouseleave", function () {
            if (!tooltip.classList.contains("pinned")) {
              setTimeout(function () {
                if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
                  hideTooltip();
                }
              }, 100);
            }
          });
        }

        // Click to pin/unpin tooltip (like model-image-tooltip)
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
          e.stopPropagation();

          if (tooltip) {
            // Close any previously opened remark tooltip
            if (openRemarkTooltip && openRemarkTooltip !== tooltip) {
              const prevTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
              closeRemarkTooltip(openRemarkTooltip, prevTrigger);
            }

            // Toggle pinned state
            if (tooltip.classList.contains("pinned")) {
              // If already pinned, close it
              closeRemarkTooltip(tooltip, trigger);
            } else {
              // Pin the tooltip open
              tooltip.classList.add("pinned");
              showTooltip();
              openRemarkTooltip = tooltip;

              // Show close button
              if (closeButton) closeButton.style.display = 'block';

              // Add visual indicator that tooltip is pinned
              trigger.style.backgroundColor = '#e3f2fd';
              trigger.style.borderRadius = '4px';

              // Focus the textarea
              if (textarea && !textarea.readOnly) {
                textarea.focus();
              }
            }
          }
        });

        // Close button functionality
        if (closeButton) {
          closeButton.addEventListener('click', function(e) {
            e.stopPropagation();
            console.log('🔴 Remark close button clicked');
            closeRemarkTooltip(tooltip, trigger);
          });

          // Hover effects for close button
          closeButton.addEventListener('mouseenter', function() {
            closeButton.style.backgroundColor = '#c82333';
            closeButton.style.transform = 'scale(1.05)';
          });

          closeButton.addEventListener('mouseleave', function() {
            closeButton.style.backgroundColor = '#dc3545';
            closeButton.style.transform = 'scale(1)';
          });
        }

        // Keep tooltip open while typing in textarea
        if (textarea) {
          textarea.addEventListener('input', function() {
            if (!tooltip.classList.contains("pinned")) {
              // If user starts typing without clicking, pin the tooltip
              tooltip.classList.add("pinned");
              openRemarkTooltip = tooltip;
              trigger.style.backgroundColor = '#e3f2fd';
              trigger.style.borderRadius = '4px';
              if (closeButton) closeButton.style.display = 'block';
            }
          });
        }

        // Send button functionality
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
            var row = trigger.closest("tr");
            var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
            var batchId = trayScanLink ? trayScanLink.getAttribute('data-batch-id') : null;
            if (!batchId) {
              Swal.fire('Error', 'Batch ID not found.', 'error');
              return;
            }
            fetch('/dayplanning/save_dp_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                batch_id: batchId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 1200,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }

                   // Find the chat icon <img> inside this trigger
                    const chatImg = trigger.querySelector('img[alt="Chat"]');
                    if (chatImg) {
                      chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                      chatImg.style.opacity = "1";
                    }

                  // Close the tooltip after saving
                  closeRemarkTooltip(tooltip, trigger);
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });

      // Close remark tooltip when clicking outside
      document.addEventListener("click", function (e) {
        if (openRemarkTooltip && !e.target.closest('.remark-tooltip') && !e.target.closest('.remark-tooltip-trigger')) {
          const openTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
          closeRemarkTooltip(openRemarkTooltip, openTrigger);
        }
      });

      // Close remark tooltip with ESC key
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && openRemarkTooltip) {
          const openTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
          closeRemarkTooltip(openRemarkTooltip, openTrigger);
          console.log('✅ Remark tooltip closed with ESC key');
        }
      });

      // Prevent tooltip from closing when clicking inside it
      document.querySelectorAll(".remark-tooltip").forEach(function (tooltip) {
        tooltip.addEventListener("click", function (e) {
          e.stopPropagation();
        });
      });
    });
</script>

  <!-- Script for Tray Scan - Modal Popup -->
<script nonce="{{ csp_nonce }}">
// ===== CROSS-BROWSER AUTO-SAVE FUNCTIONALITY =====
// ===== UTILITY FUNCTIONS =====
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    console.log(`🔐 CSRF Token: ${cookieValue ? 'Found' : 'Not Found'}`);
    return cookieValue;
}

function clearTrayVerificationMessage() {
    const footer = document.getElementById('trayQtyErrorFooter');
    if (footer) {
        footer.textContent = '';
        footer.style.color = '';
    }
}

function handleNetworkError(error, context = '') {
    console.error(`❌ Network Error in ${context}:`, error);
    
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
        Swal.fire({
            icon: 'error',
            title: 'Connection Error',
            text: 'Unable to connect to server. Please check your internet connection and try again.',
            confirmButtonColor: '#007bff'
        });
    } else if (error.status === 403) {
        Swal.fire({
            icon: 'error',
            title: 'Permission Denied',
            text: 'You do not have permission to perform this action. Please refresh the page and try again.',
            confirmButtonColor: '#007bff'
        });
    } else if (error.status === 404) {
        Swal.fire({
            icon: 'error',
            title: 'Not Found',
            text: 'The requested resource was not found. Please refresh the page.',
            confirmButtonColor: '#007bff'
        });
    } else {
        Swal.fire({
            icon: 'error',
            title: 'Network Error',
            text: `An error occurred: ${error.message || 'Unknown error'}. Please try again.`,
            confirmButtonColor: '#007bff'
        });
    }
}

function validateAllTrayIds() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return false;
    
    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    let allFilled = true;
    
    trayIdInputs.forEach((input, index) => {
        if (!input.value.trim()) {
            allFilled = false;
            console.log(`Tray ID ${index + 1} is empty:`, input.value);
        } else {
            console.log(`Tray ID ${index + 1} is filled:`, input.value);
        }
    });
    
    console.log('All Tray IDs filled:', allFilled, 'Total inputs:', trayIdInputs.length);
    return allFilled && trayIdInputs.length > 0;
}

function updateUIElements() {
    const allTrayIdsFilled = validateAllTrayIds();
    const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
    const submitBtn = document.getElementById('trayScanSubmitBtn');
    const isCheckboxChecked = verifyCheckbox && verifyCheckbox.checked;

    if (verifyCheckbox) {
        const isAlreadyVerified = verifyCheckbox.checked && verifyCheckbox.disabled;
        if (!isAlreadyVerified) {
            if (allTrayIdsFilled) {
                verifyCheckbox.disabled = false;
                verifyCheckbox.style.opacity = '1';
                verifyCheckbox.style.cursor = 'pointer';
            } else {
                verifyCheckbox.disabled = true;
                verifyCheckbox.checked = false;
                verifyCheckbox.style.opacity = '0.5';
                verifyCheckbox.style.cursor = 'not-allowed';
            }
        }
    }

    if (submitBtn) {
        let tooltipMsg = "";
        if (!allTrayIdsFilled && !isCheckboxChecked) {
            tooltipMsg = "Fill all Tray IDs and verify the top tray quantity to enable Submit.";
        } else if (!allTrayIdsFilled) {
            tooltipMsg = "Please fill all Tray IDs to enable Submit.";
        } else if (!isCheckboxChecked) {
            tooltipMsg = "Please verify the top tray quantity to enable Submit.";
        } else {
            tooltipMsg = "";
        }

        if (allTrayIdsFilled && isCheckboxChecked) {
            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            submitBtn.style.cursor = 'pointer';
            submitBtn.style.backgroundColor = '#28a745';
            submitBtn.removeAttribute('title');
        } else {
            submitBtn.disabled = true;
            submitBtn.style.opacity = '0.5';
            submitBtn.style.cursor = 'not-allowed';
            submitBtn.style.backgroundColor = '#6c757d';
            submitBtn.setAttribute('title', tooltipMsg);
        }
    }

    updateTrayScanSummary();
}

function handleQuantityChange(qtyInput, position) {
    const quantity = parseInt(qtyInput.value, 10) || 0;
    const row = qtyInput.closest('tr') || qtyInput.closest('div[style*="display:"]');
    
    if (quantity === 0) {
        if (row) {
            row.style.opacity = '0.5';
            row.style.backgroundColor = '#ffebee';
            row.title = 'This tray will be delinked (quantity = 0)';
        }
        console.log(`Position ${position}: Marked for delinking (qty = 0)`);
    } else {
        if (row) {
            row.style.opacity = '1';
            row.style.backgroundColor = '';
            row.title = '';
        }
        console.log(`Position ${position}: Active tray (qty = ${quantity})`);
    }
    
    updateTrayScanSummary();
    updateUIElements();
}

function updateTrayScanSummary() {
    const detailsDiv = document.getElementById("trayScanDetails");
    const summaryDiv = document.getElementById("trayScanSummary");
    if (!detailsDiv || !summaryDiv) return;

    const qtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');

    if (qtyInputs.length === 0 || trayIdInputs.length === 0) {
        const textSpan = summaryDiv.querySelector('span');
        if (textSpan) {
            textSpan.textContent = `Qty to Scan: 0/0`;
        } else {
            summaryDiv.innerHTML = `<span style="white-space: nowrap;">Qty to Scan: 0/0</span><img src="/static/assets/icons/redo2.png" alt="Redo" id="trayScanRedoClearBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;" />`;
        }
        return;
    }

    // Get actual batch quantity instead of calculating from inputs
    const batchId = window.currentTrayScanBatchId;
    let totalQuantity = 0;
    
    if (batchId) {
        const targetButton = document.querySelector(`.tray-scan-btn[data-batch-id="${batchId}"]`);
        if (targetButton) {
            const actualBatchQuantity = targetButton.getAttribute('data-total-batch-quantity');
            totalQuantity = parseInt(actualBatchQuantity) || 0;
        }
    }
    
    // If we couldn't get the actual batch quantity, fallback to calculation
    if (totalQuantity === 0) {
        for (let i = 0; i < qtyInputs.length; i++) {
            const qty = parseInt(qtyInputs[i].value, 10) || 0;
            if (qty > 0) {
                totalQuantity += qty;
            }
        }
    }

    let scannedQuantity = 0;

    for (let i = 0; i < qtyInputs.length; i++) {
        const qty = parseInt(qtyInputs[i].value, 10) || 0;
        
        if (qty > 0) {
            // Only count if tray ID is filled AND has no validation errors
            if (trayIdInputs[i] && trayIdInputs[i].value.trim()) {
                const hasError = trayIdInputs[i].parentNode.querySelector('.tray-id-error');
                const hasInvalidStyle = trayIdInputs[i].style.borderColor === 'rgb(211, 47, 47)' || 
                                       trayIdInputs[i].style.borderColor === '#d32f2f' ||
                                       trayIdInputs[i].style.borderColor === '#ff5722';
                
                // Only count if no error div and no error styling
                if (!hasError && !hasInvalidStyle) {
                    scannedQuantity += qty;
                }
            }
        }
    }

    const allFilled = validateAllTrayIds();
    const buttonHtml = allFilled ? '' : `<img src="/static/assets/icons/redo2.png" alt="Redo" id="trayScanRedoClearBtn" title="Clear Tray IDs" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;" />`;
    summaryDiv.innerHTML = `<span style="white-space: nowrap;">Qty to Scan: ${scannedQuantity}/${totalQuantity}</span>${buttonHtml}`;

    // Attach click handler to the redo button if it exists
    const redoBtn = summaryDiv.querySelector('#trayScanRedoClearBtn');
    if (redoBtn) {
        redoBtn.onclick = function() {
            console.log('✅ Redo button clicked!');
            let detailsDiv = document.getElementById("trayScanDetails");
            let errorFooterId = 'trayQtyErrorFooter';
            if (!detailsDiv || detailsDiv.querySelectorAll('.tray-id-input').length === 0) {
                detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
                errorFooterId = 'trayErrorMessage';
            }
            
            console.log('🔍 Using detailsDiv:', detailsDiv ? detailsDiv.id : 'not found');
            
            if (detailsDiv) {
                clearTrayIdInputs(detailsDiv, errorFooterId);
                console.log('🔄 Cleared tray IDs from modal');
            } else {
                console.log('❌ No active tray scan modal found');
            }
        };
    }
    
    const modalTrayQty = document.getElementById("modalTrayQty");
    if (modalTrayQty && totalQuantity > 0) {
        modalTrayQty.textContent = totalQuantity;
    }
}

// ===== MAIN MODAL LOGIC =====
document.addEventListener("DOMContentLoaded", () => {
    
// 🎯 UPDATED FUNCTIONS WITH NO OF TRAYS AUTO-UPDATE
function updateRowAfterTrayScan(batchId, needsTopTrayScan = true, isDraft = true) {
    console.log('🔄 Updating row after tray scan completion');
    
    // Find the row with matching batch ID
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetRow = null;
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
            targetRow = btn.closest('tr');
        }
    });

    if (!targetRow || !targetButton) {
        console.warn('⚠️ Could not find target row for batch ID:', batchId);
        return;
    }

    // 1. Update button text and data attributes
    if (needsTopTrayScan) {
        targetButton.textContent = 'Set Top Tray';
        targetButton.setAttribute('data-needs-top-tray-scan', 'true');
        console.log('✅ Button updated to "Set Top Tray"');
    }

    // 🎯 NEW: Update Input Qty in the main table (column 12)
    const inputQtyCell = targetRow.querySelector('td:nth-child(12)'); // Input Qty column
    if (inputQtyCell) {
        // Get the actual scanned quantity from the modal
        const modalTrayQty = document.getElementById("modalTrayQty");
        if (modalTrayQty) {
            const newInputQty = modalTrayQty.textContent.trim();
            inputQtyCell.textContent = newInputQty;
            
            // Also update the button's data attribute
            targetButton.setAttribute('data-total-batch-quantity', newInputQty);
            console.log('✅ Input Qty updated to:', newInputQty);
        }
    }

    // 🎯 NEW: Update No of Trays in the main table (column 11)
    const noOfTraysCell = targetRow.querySelector('td:nth-child(11)'); // No of Trays column
    if (noOfTraysCell) {
        // Calculate actual number of trays from modal data
        const detailsDiv = document.getElementById("trayScanDetails");
        let actualNoOfTrays = 0;
        
        if (detailsDiv) {
            const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
            const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
            
            // Count trays with both tray ID and non-zero quantity
            for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
                const trayId = trayIdInputs[i] ? trayIdInputs[i].value.trim() : '';
                const trayQty = trayQtyInputs[i] ? parseInt(trayQtyInputs[i].value, 10) || 0 : 0;
                
                if (trayId && trayQty > 0) {
                    actualNoOfTrays++;
                }
            }
        }
        
        // Update the cell and button data attribute
        noOfTraysCell.textContent = actualNoOfTrays;
        targetButton.setAttribute('data-no-of-trays', actualNoOfTrays.toString());
        console.log('✅ No of Trays updated to:', actualNoOfTrays);
    }

    // 2. Update lot status to Draft
    if (isDraft) {
        const lotStatusCell = targetRow.querySelector('td:nth-child(15)'); // Lot Status column
        if (lotStatusCell) {
            lotStatusCell.innerHTML = `
                <div
                  class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                  style="
                    border: 1px solid #4997ac;
                    background-color: #d1f2f3;
                    color: #03425d;
                    font-size: 13px;
                    white-space: nowrap;
                    padding: 5px;
                    
                  "
                >
                  Draft
                </div>
            `;
            console.log('✅ Lot status updated to "Draft"');
        }
    }

    // 3. Update process status to partial (half green, half gray)
    const processStatusCell = targetRow.querySelector('td:nth-child(13)'); // Process Status column
    if (processStatusCell) {
        processStatusCell.innerHTML = `
            <div
                title="Tray Scan - Partial"
                class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                style="
                  width: 28px;
                  height: 28px;
                  background: linear-gradient(
                    to right,
                    green 50%,
                    #bfbfbf 50%
                  );
                  color: white;
                  font-weight: bold;
                  line-height: 20px;
                  text-align: center;
                  padding-top: 1px;
                  padding-right: 1px;"
            >
                T
            </div>
        `;
        console.log('✅ Process status updated to partial completion');
    }

    // 4. Update data attributes for future functionality
    targetButton.setAttribute('data-draft-saved', 'True');
    targetButton.setAttribute('data-moved-to-d-picker', 'False');

    // 🎯 NEW: Update the stored modal data for correct reopening
    updateStoredModalData(batchId);

    console.log('🎉 Row update completed successfully with No of Trays auto-update');
}

function updateRowAfterTopTrayScan(batchId) {
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetRow = null;
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
            targetRow = btn.closest('tr');
        }
    });

    if (!targetRow || !targetButton) {
        console.warn('⚠️ Could not find target row for batch ID:', batchId);
        return;
    }

    // Update button text back to indicate completion
    targetButton.textContent = 'Tray Scan'; 
    targetButton.setAttribute('data-needs-top-tray-scan', 'false');
    targetButton.setAttribute('data-moved-to-d-picker', 'True');

    // 🎯 NEW: Update No of Trays in the main table (column 11)
    const noOfTraysCell = targetRow.querySelector('td:nth-child(11)'); // No of Trays column
    if (noOfTraysCell) {
        // Get the current no of trays from button data attribute (already updated in updateRowAfterTrayScan)
        const currentNoOfTrays = targetButton.getAttribute('data-no-of-trays') || '0';
        noOfTraysCell.textContent = currentNoOfTrays;
        console.log('✅ No of Trays confirmed as:', currentNoOfTrays);
    }

    // Update lot status to "Yet To Release"
    const lotStatusCell = targetRow.querySelector('td:nth-child(15)');
    if (lotStatusCell) {
        lotStatusCell.innerHTML = `
            <div
              class="d-inline-block px-3 fw-semibold text-center rounded-pill"
              style="
                border: 1px solid #0d5d17;
                background-color: #c5f9c2;
                color: #2f801b;
                font-size: 13px;
                white-space: nowrap;
                padding: 5px;
                
              "
            >
              Yet To Release
            </div>
        `;
    }

    // Update process status to fully complete (green)
    const processStatusCell = targetRow.querySelector('td:nth-child(13)');
    if (processStatusCell) {
        processStatusCell.innerHTML = `
            <div
              title="Tray Scan - Complete"
              class="d-flex align-items-center justify-content-center rounded-circle ms-1"
              style="
                width: 28px;
                height: 28px;
                background-color: #0c8249;
                color: white;
                font-weight: bold;
              "
            >
              T
            </div>
        `;
    }

    console.log('🎉 Row updated after top tray scan completion with No of Trays confirmation');
}

// 🎯 UPDATED FUNCTION: Enhanced stored modal data update with no of trays calculation

function updateStoredModalData(batchId) {
    console.log('📋 Updating stored modal data for batch:', batchId);
        
    // Find the tray scan button to update its data attributes
    const allTrayScanBtns = document.querySelectorAll('.tray-scan-btn');
    let targetButton = null;

    allTrayScanBtns.forEach(btn => {
        if (btn.getAttribute('data-batch-id') === batchId) {
            targetButton = btn;
        }
    });

    if (!targetButton) {
        console.warn('⚠️ Could not find target button for batch ID:', batchId);
        return;
    }

    // Get current modal data
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');

    // 🎯 NEW: Get and preserve checkbox state
    const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
    const isCheckboxChecked = verifyCheckbox ? verifyCheckbox.checked : false;
    const isCheckboxDisabled = verifyCheckbox ? verifyCheckbox.disabled : false;

    console.log('💾 Preserving checkbox state:', {
        checked: isCheckboxChecked,
        disabled: isCheckboxDisabled
    });

    // Calculate new data
    let newTrayQtyList = [];
    let totalQty = 0;
    let nonZeroRows = [];

    for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
        const qty = parseInt(trayQtyInputs[i]?.value || 0, 10);
        const trayId = trayIdInputs[i]?.value.trim() || '';
        
        if (qty > 0 && trayId) {
            newTrayQtyList.push(qty);
            totalQty += qty;
            nonZeroRows.push({
                trayId: trayId,
                trayQty: qty,
                position: nonZeroRows.length // Reindex starting from 0
            });
        }
    }

    // Update button data attributes with new values
    targetButton.setAttribute('data-tray-qty-list', JSON.stringify(newTrayQtyList));
    targetButton.setAttribute('data-total-batch-quantity', totalQty.toString());
    targetButton.setAttribute('data-no-of-trays', nonZeroRows.length.toString());

    // 🎯 NEW: Store checkbox state in button data attributes
    targetButton.setAttribute('data-top-tray-qty-verified', isCheckboxChecked ? 'True' : 'False');
    targetButton.setAttribute('data-checkbox-disabled', isCheckboxDisabled ? 'True' : 'False');

    console.log('✅ Updated button data attributes:');
    console.log('   - Total Qty:', totalQty);
    console.log('   - No of Trays:', nonZeroRows.length);
    console.log('   - Tray Qty List:', newTrayQtyList);
    console.log('   - Checkbox Verified:', isCheckboxChecked);
    console.log('   - Checkbox Disabled:', isCheckboxDisabled);
}



const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
const modal = document.getElementById("trayScanModal");
const closeBtn = document.getElementById("closeTrayScanModal");
const detailsDiv = document.getElementById("trayScanDetails");
const modalModelNo = document.getElementById("modalModelNo");

// ===== ENHANCED TRAY SCAN MODAL WITH DYNAMIC ROW MANAGEMENT =====

    // ===== ENHANCED TRAY SCAN MODAL WITH DYNAMIC ROW MANAGEMENT =====

// 🚀 NEW: Helper functions for dynamic row management
function getCurrentTrayData() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return [];

    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
    
    const data = [];
    for (let i = 0; i < Math.max(trayIdInputs.length, trayQtyInputs.length); i++) {
        data.push({
            trayId: trayIdInputs[i] ? trayIdInputs[i].value.trim() : '',
            trayQty: trayQtyInputs[i] ? trayQtyInputs[i].value : '',
            position: i,
            draftId: trayIdInputs[i] ? trayIdInputs[i].getAttribute('data-draft-id') : ''
        });
    }
    return data;
}

function rebuildTrayScanTable(currentData, newRowCount, trayCapacity, topTrayQtyVerified, buttonElement) {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    console.log(`🔄 Rebuilding table: ${newRowCount} rows`);

    // Get actual batch quantity for proper distribution
    let totalBatchQuantity = 0;
    if (buttonElement) {
        const actualBatchQuantity = buttonElement.getAttribute('data-total-batch-quantity');
        totalBatchQuantity = parseInt(actualBatchQuantity) || 0;
    }

    // Build new HTML structure - 3 column layout only (no validation status column during rebuild)
    let html = `
        <div style="min-height:32px;">S.no</div>
        <div style="min-height:32px;">Tray ID</div>
        <div style="min-height:32px;">Tray Quantity</div>
    `;

    // Generate rows for the new count
    for (let i = 0; i < newRowCount; i++) {
        const isTopTray = (i === 0);
        const sNo = isTopTray ? '1 (Top Tray)' : (i + 1);
        
        // Get existing data for this position
        const existingTrayId = currentData[i] ? currentData[i].trayId : '';
        const existingDraftId = currentData[i] ? currentData[i].draftId : '';
        
        // Calculate proper tray quantity based on actual batch quantity
        let calculatedTrayQty = trayCapacity;
        if (totalBatchQuantity > 0) {
            if (isTopTray) {
                // Top tray gets the remainder if any
                const fullTrays = Math.floor(totalBatchQuantity / trayCapacity);
                const remainder = totalBatchQuantity % trayCapacity;
                calculatedTrayQty = remainder > 0 ? remainder : trayCapacity;
            } else {
                // Other trays get full capacity, but only if there's enough quantity
                const topTrayQty = totalBatchQuantity % trayCapacity || trayCapacity;
                const remainingAfterTopTray = totalBatchQuantity - topTrayQty;
                const otherTrayIndex = i - 1; // Adjust for top tray being first
                
                if (otherTrayIndex * trayCapacity < remainingAfterTopTray) {
                    calculatedTrayQty = trayCapacity;
                } else {
                    calculatedTrayQty = 0; // This tray is not needed
                }
            }
            calculatedTrayQty = Math.max(0, calculatedTrayQty); // Ensure non-negative
        }
        
        // Always use calculated quantity to ensure proper distribution
        const existingTrayQty = calculatedTrayQty;
        
        html += `
            <div style="min-height:32px;">${sNo}</div>
            <div style="min-height:32px;">
                <input type="text" class="form-control tray-id-input" value="${existingTrayId}" data-draft-id="${existingDraftId}" data-position="${i+1}" style="width: 100%;" />
            </div>
            <div style="min-height:32px;">
                ${
                  isTopTray
                    ? `<div style="display: flex; align-items: center; justify-content: space-between;">
                      <input type="number" class="form-control tray-qty-input" value="${existingTrayQty}" style="width: 60px;" readonly />
                      <div style="display: flex; align-items: center; gap: 27px;">
                          <input type="checkbox" class="tray-verify-checkbox" style="width: 18px; height: 18px; cursor: pointer;" ${buttonElement ? (buttonElement.getAttribute('data-draft-saved') === 'true' ? (topTrayQtyVerified ? 'checked' : '') : (topTrayQtyVerified ? 'checked' : '')) : (topTrayQtyVerified ? 'checked disabled' : '')} />
                          <img src="{% static 'assets/icons/edit2.png' %}" alt="Edit" class="tray-edit-btn" style="width: 18px; height: 18px; cursor: pointer;${buttonElement ? (buttonElement.getAttribute('data-draft-saved') === 'true' ? '' : (topTrayQtyVerified ? 'opacity:0.5;pointer-events:none;' : '')) : (topTrayQtyVerified ? 'opacity:0.5;pointer-events:none;' : '')}" />
                      </div>
                      </div>`
                    : `<input type="number" class="form-control" value="${existingTrayQty}" style="width: 100%;" readonly />`
                }
            </div>
        `;
    }

    // Update the HTML
    detailsDiv.innerHTML = html;
    console.log('✅ Table rebuilt successfully with checkbox state preservation');

    // Add event listeners for draft tray deletion on clear AND checkbox unchecking
    const trayIdInputs = detailsDiv.querySelectorAll('.tray-id, .tray-id-input');
    trayIdInputs.forEach(input => {
      input.addEventListener('input', function() {
        // ✅ NEW: Uncheck checkbox when any tray ID is modified or cleared
        const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
        if (verifyCheckbox && !verifyCheckbox.disabled) {
          verifyCheckbox.checked = false;
          console.log('🔄 Unchecked checkbox due to tray ID modification');
        }
        
        // ✅ NEW: Clear verification message when tray ID is modified
        const errorFooter = document.getElementById('trayQtyErrorFooter');
        if (errorFooter) {
          errorFooter.textContent = '';
        }
        
        if (this.value.trim() === '') {
          const batchId = buttonElement ? buttonElement.getAttribute('data-batch-id') : '';
          if (batchId && this.dataset.position !== undefined) {
            fetch(`/dayplanning/draft_tray_delete/?batch_id=${batchId}&position=${this.dataset.position}`, {
              method: 'DELETE',
              headers: {
                'X-CSRFToken': getCookie('csrftoken')
              }
            }).then(res => res.json()).then(data => {
              if (data.success) {
                console.log(`🗑️ Deleted draft tray at position ${this.dataset.position}`);
              }
            }).catch(err => console.error('Error deleting draft tray:', err));
          }
        }
      });
    });
}



function handleTopTrayZeroQuantity() {
    
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    // Get the top tray ID input
    const topTrayIdInput = detailsDiv.querySelector('input[type="text"]');
    const topTrayId = topTrayIdInput ? topTrayIdInput.value.trim() : '';

    console.log(`📋 Top tray ID: "${topTrayId}"`);

    if (!topTrayId) {
        // 🎯 SCENARIO 1: No tray ID in top tray, quantity is 0
        // Remove one row and shift everything up
        handleRemoveOneRow();
    } else {
        // 🎯 SCENARIO 2: Tray ID exists but quantity is 0
        // Use existing delink/top tray scan functionality
        console.log('✅ Top tray has ID but zero quantity - using existing delink functionality');
    }
}

function handleRemoveOneRow() {
    console.log('🗑️ Removing one row due to top tray being empty with zero quantity');
    
    const currentData = window.currentTrayScanData || getCurrentTrayData();
    const currentRowCount = currentData.length;

    if (currentRowCount <= 1) {
      console.log('⚠️ Cannot remove row - minimum 1 row required');
      return;
    }

    // Create new data array excluding the first row
    const newData = currentData.slice(1); // Remove first row
    const newRowCount = newData.length;

    console.log(`📊 Reducing from ${currentRowCount} rows to ${newRowCount} rows`);

    // Get modal configuration
    const trayCapacity = getCurrentTrayCapacity();
    const topTrayQtyVerified = isTopTrayQtyVerified();

    // 🎯 NEW: Get button element for checkbox state preservation
    const batchId = window.currentTrayScanBatchId;
    const buttonElement = document.querySelector(`[data-batch-id="${batchId}"]`);

    // Rebuild the table with new row count and checkbox state
    rebuildTrayScanTable(newData, newRowCount, trayCapacity, topTrayQtyVerified, buttonElement);

    // Update the modal total quantity display
    updateModalTotalQuantity(newRowCount, trayCapacity);

    // Re-attach all event listeners after rebuilding
    setTimeout(() => {
      attachEnhancedEventListeners();
    }, 100);

    console.log('✅ Row removal completed with checkbox state preservation');
}

function getCurrentTrayCapacity() {
    return window.currentModalConfig ? window.currentModalConfig.trayCapacity : 12;
}

function isTopTrayQtyVerified() {
    return window.currentModalConfig ? window.currentModalConfig.topTrayQtyVerified : false;
}

function updateModalTotalQuantity(rowCount, trayCapacity) {
    console.log("🔄 Updating modal total quantity");
    
    // Get the current batch ID to find the correct button
    const batchId = window.currentTrayScanBatchId;
    if (!batchId) {
        console.log("❌ No current batch ID found");
        return;
    }
    
    // Find the button that opened this modal to get the actual batch quantity
    const targetButton = document.querySelector(`.tray-scan-btn[data-batch-id="${batchId}"]`);
    if (!targetButton) {
        console.log("❌ Target button not found for batch ID:", batchId);
        return;
    }
    
    // Use actual batch quantity from button's data attribute instead of calculating
    const actualBatchQuantity = targetButton.getAttribute('data-total-batch-quantity');
    const batchQuantity = parseInt(actualBatchQuantity) || 0;
    
    console.log(`📊 Using actual batch quantity: ${batchQuantity} (instead of calculated ${rowCount * trayCapacity})`);
    
    const modalTrayQty = document.getElementById("modalTrayQty");
    if (modalTrayQty) {
        modalTrayQty.textContent = batchQuantity;
        console.log(`✅ Updated modal total quantity display to actual batch quantity: ${batchQuantity}`);
    } else {
        console.log("❌ modalTrayQty element not found");
    }
}
// 🚀 ENHANCED: Function to attach all event listeners after table rebuild
function attachEnhancedEventListeners() {
    const detailsDiv = document.getElementById("trayScanDetails");
    if (!detailsDiv) return;

    const trayCapacity = getCurrentTrayCapacity();
    const topTrayQtyVerified = isTopTrayQtyVerified();
    
    // Get draft status
    const batchId = window.currentTrayScanBatchId;
    const buttonElement = document.querySelector(`.tray-scan-btn[data-batch-id="${batchId}"]`);
    const isDraft = buttonElement && buttonElement.getAttribute('data-draft-saved') === 'true';
    
    // Attach listeners to tray ID inputs
    const trayIdInputs = detailsDiv.querySelectorAll('.tray-id, .tray-id-input');
    trayIdInputs.forEach(input => {
        input.addEventListener('input', function() {
            // ✅ NEW: Uncheck checkbox when any tray ID is modified
            const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
            if (verifyCheckbox && !verifyCheckbox.disabled) {
                verifyCheckbox.checked = false;
                console.log('🔄 Unchecked checkbox due to tray ID input change (Enhanced)');
            }
            
            // ✅ NEW: Clear verification message when tray ID is modified
            const errorFooter = document.getElementById('trayQtyErrorFooter');
            if (errorFooter) {
                errorFooter.textContent = '';
            }
            
            updateUIElements();
        });
        input.addEventListener('blur', updateUIElements);
    });

    // Enhanced top tray quantity input handler
    const editBtn = detailsDiv.querySelector('.tray-edit-btn');
    const qtyInput = detailsDiv.querySelector('.tray-qty-input');
    const errorFooter = document.getElementById('trayQtyErrorFooter');

    if (editBtn && qtyInput && (!topTrayQtyVerified || isDraft)) {
        // Remove existing listeners to prevent duplicates
        const newEditBtn = editBtn.cloneNode(true);
        editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        
        const newQtyInput = qtyInput.cloneNode(true);
        qtyInput.parentNode.replaceChild(newQtyInput, qtyInput);

        // ✅ ENHANCED: Store original quantity for decrease-only validation
        let originalQuantity = parseInt(newQtyInput.value, 10) || 0;

        // Add edit button listener
        newEditBtn.addEventListener('click', function (e) {
            e.preventDefault();
            // ✅ Capture original quantity at edit time
            originalQuantity = parseInt(newQtyInput.value, 10) || 0;
            console.log('✏️ Edit started (Enhanced) - Original quantity:', originalQuantity);
            
            newQtyInput.removeAttribute('readonly');
            newQtyInput.focus();
            newQtyInput.select();
        });

        // 🚀 ENHANCED: Quantity input handler with decrease-only + dynamic row management
        newQtyInput.addEventListener('input', function () {
            if (errorFooter) {
                errorFooter.textContent = 'Qty modified';
                errorFooter.style.color = '#007bff';
            } 
            
            let val = parseInt(newQtyInput.value, 10) || 0;
            
            // ✅ ENHANCED: Only allow decrease from original quantity
            if (val > originalQuantity) {
                newQtyInput.value = originalQuantity;
                if (errorFooter) {
                    errorFooter.textContent = `Quantity can only be decreased. Maximum allowed: ${originalQuantity}`;
                    errorFooter.style.color = '#d32f2f';
                }
                val = originalQuantity;
            } else if (val > trayCapacity) {
                newQtyInput.value = trayCapacity;
                if (errorFooter) errorFooter.textContent = `Tray Qty cannot exceed Tray Capacity (${trayCapacity})`;
            } else if (val < 0) {
                newQtyInput.value = 0;
                val = 0;
            }

            
            updateUIElements();
                });

        // Handle enter key and blur events
        newQtyInput.addEventListener('keydown', function (ev) {
            if (ev.key === 'Enter') {
                newQtyInput.setAttribute('readonly', 'readonly');
                newQtyInput.blur();
            }
        });

        newQtyInput.addEventListener('blur', function () {
            newQtyInput.setAttribute('readonly', 'readonly');
            if (errorFooter) errorFooter.textContent = '';
        });
    }

    const verifyCheckbox = detailsDiv.querySelector('input[type="checkbox"]');
if (verifyCheckbox) {
    verifyCheckbox.addEventListener('change', function() {
        if (verifyCheckbox.checked) {
            if (!validateAllTrayIds()) {
                verifyCheckbox.checked = false;
                if (errorFooter) {
                    errorFooter.textContent = '';
                }
                Swal.fire({
                    icon: 'warning',
                    title: 'Incomplete Data',
                    text: 'Please fill all Tray IDs before verifying.',
                    confirmButtonColor: '#007bff'
                });
                return;
            }
            if (errorFooter) {
                errorFooter.textContent = 'Top tray qty verified';
                errorFooter.style.color = 'green';
            }
        } else {
            if (errorFooter) {
                errorFooter.textContent = '';
            }
        }
        updateUIElements();
    });
}

    updateUIElements();
    console.log('✅ Enhanced event listeners attached with decrease-only editing');
}
// ===== MODIFIED MAIN TRAY SCAN HANDLER =====

trayScanLinks.forEach((link) => {
    link.addEventListener("click", async (event) => {
        event.preventDefault();

        // Get tray scan status from the clicked link
        const trayScanStatus = link.getAttribute('data-tray-scan-status') === 'true';
        
        window.currentTrayScanBatchId = event.target.getAttribute("data-batch-id");
        clearTrayVerificationMessage();
        const needsTopTrayScan = link.getAttribute('data-needs-top-tray-scan') === 'true';

        const row = event.target.closest("tr");
        if (!row) return;
        document.querySelectorAll("tbody tr").forEach((row) => {
            row.classList.remove("highlighted-tray-scan");
        });
        row.classList.add("highlighted-tray-scan");

        // Get dynamic data from the clicked row
        const batchId = event.target.getAttribute("data-batch-id");
        const modelNo = event.target.getAttribute("data-model-no");
        const noOfTrays = parseInt(event.target.getAttribute("data-no-of-trays")) || 0;
        const trayCapacity = parseInt(event.target.getAttribute("data-tray-capacity")) || 12; 
        const topTrayQtyVerified = event.target.getAttribute("data-top-tray-qty-verified") === "True";
        const draftSaved = event.target.getAttribute("data-draft-saved") === "True";
        const movedToDPicker = event.target.getAttribute("data-moved-to-d-picker") === "True";
        
        // NEW: Store current modal configuration for use by enhanced functions
        window.currentModalConfig = {
            batchId,
            modelNo,
            noOfTrays,
            trayCapacity,
            topTrayQtyVerified,
            draftSaved,
            movedToDPicker
        };

        // Update modal with dynamic model number
        if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
            
        }

          // --- Tray Type Identification ---
          const trayTypeCell = row.querySelector('td:nth-child(9)');
          const trayType = trayTypeCell ? trayTypeCell.textContent.trim() : 'N/A';
 
                  let trayTypeDiv = modal.querySelector('#modalTrayType');
          if (!trayTypeDiv) {
              trayTypeDiv = document.createElement('div');
              trayTypeDiv.id = 'modalTrayType';
              trayTypeDiv.style.fontWeight = '600';
              trayTypeDiv.style.color = '#222';
              trayTypeDiv.style.fontSize = '12px';
              modal.querySelector('.modal-top-header').appendChild(trayTypeDiv);
          }
          

         // choose size mode, apply class and display numeric size (Normal = 16, Jumbo = 12)
(function(){
  // parse base type from the trayType string (e.g. "Normal-16", "Jumbo-12", "CPSF-12")
  const rawType = (trayType || '').split('-')[0]?.trim().toLowerCase() || 'normal';

  // normalize known aliases -> logical type should be 'normal' or 'jumbo'
  let logicalType = rawType;
  if (logicalType === 'cpsf') logicalType = 'normal';
  // add other aliases if required, e.g. if (logicalType === 'xyz') logicalType = 'jumbo';

  const isJumbo = logicalType === 'jumbo';

  // correct sizes: Jumbo => 12, Normal => 16
  const sizeNumber = isJumbo ? 12 : 16;

  trayTypeDiv.classList.remove('tray-type-jumbo','tray-type-normal');
  trayTypeDiv.classList.add(isJumbo ? 'tray-type-jumbo' : 'tray-type-normal');

  const displayLabel = logicalType.charAt(0).toUpperCase() + logicalType.slice(1);

  trayTypeDiv.innerHTML = `
<span style="display: flex; align-items: center; gap: 8px;">
  <button type="button"
          style="
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #28a745;
            background: #f7fff7;
            color: #5e5959;
            font-weight: 600;
            font-size: 12px;
            border-radius: 20px;
            padding: 5px;
            box-shadow: 0 1px 4px rgba(40,167,69,0.08);
            cursor: default;
          "
          disabled
  >
    ${displayLabel} - ${sizeNumber}
  </button>
</span>
  `;
})();
        // Update model image
        const modalUserImg = modal.querySelector('.modal-top-header img');
        const modelImage = link.getAttribute('data-model-image');
        if (modalUserImg) {
            if (modelImage) {
                modalUserImg.src = modelImage;
            } else {
                modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
            }
        }

        const modalTrayQty = document.getElementById("modalTrayQty");
        const totalBatchQty = event.target.getAttribute("data-total-batch-quantity");
        if (modalTrayQty && totalBatchQty) {
            modalTrayQty.textContent = totalBatchQty;
        }

        // Try to fetch DraftTrayId data first, fallback to TrayId
        let traysData = [];
        let isDraft = false;
        try {
            const draftResp = await fetch(`/dayplanning/draft_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
            const draftResult = await draftResp.json();
            if (draftResult.success && Array.isArray(draftResult.trays) && draftResult.trays.length > 0) {
                traysData = draftResult.trays;
                isDraft = true;
            } else {
                const resp = await fetch(`/dayplanning/tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
                const result = await resp.json();
                if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
                    traysData = result.trays;
                    isDraft = false;
                }
            }
        } catch (e) {
            // Ignore fetch errors, fallback to default
        }

        let totalRows = noOfTrays;
        
        const traysByPosition = {};
        if (isDraft) {
            traysData.forEach(tray => {
                if (tray.position !== undefined) {
                    traysByPosition[tray.position] = tray;
                }
            });
            console.log('🔍 Draft trays mapped by position:', traysByPosition);
        }
        
        let currentData = [];
        for (let i = 0; i < totalRows; i++) {
            if (isDraft) {
                if (traysByPosition[i]) {
                    currentData[i] = {
                        trayId: traysByPosition[i].tray_id,
                        trayQty: traysByPosition[i].tray_quantity,
                        draftId: traysByPosition[i].id,
                    };
                } else {
                    currentData[i] = { trayId: '', trayQty: trayCapacity, draftId: '' };
                }
            } else {
                currentData[i] = {
                    trayId: traysData[i] ? traysData[i].tray_id : '',
                    trayQty: traysData[i] ? traysData[i].tray_quantity : trayCapacity,
                    draftId: '',
                };
            }
        }
        
        let showButtons = isDraft || traysData.length === 0;
        
        rebuildTrayScanTable(currentData, totalRows, trayCapacity, topTrayQtyVerified, link);


        // 🚀 ENHANCED: Initialize UI validation with enhanced event listeners
        setTimeout(() => {
            attachEnhancedEventListeners();
        }, 100);

        // Auto-focus the first empty Tray ID input when modal opens (or none if all filled)
        autoFocusFirstTrayInput();

        const isReleased = event.target.getAttribute("data-moved-to-d-picker") === "True";
        
        if (isReleased) {
            detailsDiv.querySelectorAll('input').forEach(inp => inp.setAttribute('readonly', 'readonly'));
        }
        
        const buttonSection = modal.querySelector('.tray-scan-modal-content > div[style*="justify-content: center"]');
        if (buttonSection) {
            buttonSection.style.display = isReleased ? "none" : (showButtons ? "flex" : "none");
        }

        modal.classList.add("open");

        // --- Show Top Tray Scan UI if needed ---
        if (needsTopTrayScan) {
            showTopTrayScanUIInModal(batchId); // Pass batchId if your function needs it
        } else {
            // Remove/hide the Top Tray Scan UI if present
            const existingSection = document.getElementById('topTrayScanSection');
            if (existingSection) existingSection.remove();
        }



        // Tray ID validation logic
        if (!isReleased) {
            const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]:not([readonly])');
            trayIdInputs.forEach((input, idx, allInputs) => {
                input.addEventListener('input', function () {
                    let prevError = input.parentNode.querySelector('.tray-id-error');
                    if (prevError) prevError.remove();

                    input.style.borderColor = '';
                    input.style.backgroundColor = '';

                    // Allow only alphabets, numbers, and hyphen for tray scan
                    input.value = input.value.replace(/[^A-Za-z0-9-]/g, '');
                    // Enforce max 9 characters for tray scan
                    if (input.value.length > 9) {
                      input.value = input.value.slice(0, 9);
                    }

                    updateUIElements();

                    // Auto-advance to next field after 9 digits
                    const currentValue = input.value.trim();
                    if (currentValue.length === 9) {
                      // Auto-trigger blur validation
                      setTimeout(() => {
                        input.blur();
                      }, 100);
                    }
                });

                input.addEventListener('blur', async function () {
                    let prevError = input.parentNode.querySelector('.tray-id-error');
                    if (prevError) prevError.remove();

                    const trayId = input.value.trim();
                    if (!trayId) {
                        updateUIElements();
                        return;
                    }

                    // Check for duplicates in modal
                    let duplicateInModal = false;
                    allInputs.forEach((otherInput, otherIdx) => {
                        if (otherIdx !== idx && otherInput.value.trim() === trayId) {
                            duplicateInModal = true;
                        }
                    });
                    if (duplicateInModal) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = 'red';
                        errorDiv.style.fontSize = '12px';
                        errorDiv.textContent = 'Already scanned in a row!';
                        input.parentNode.appendChild(errorDiv);
                        input.focus();
                        input.select();
                        updateUIElements();
                        return;
                    }

                    // Backend validation
                    try {
                        console.log('Validating tray ID:', trayId, 'for batch:', window.currentTrayScanBatchId);
                        const currentBatchId = window.currentTrayScanBatchId || '';
                        const resp = await fetch(`/dayplanning/tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(currentBatchId)}`);
                        const result = await resp.json();
                        
                        if (result.tray_not_in_system) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = '#d32f2f';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            errorDiv.innerHTML = `<div style="color: #d32f2f;">Not exists</div>`;
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                            updateUIElements();
                            
                        } else if (result.already_scanned) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = '#d32f2f';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `<div style="color: #d32f2f;">❌ Already Scanned</div>`;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                            updateUIElements();
                            
                        } else if (result.tray_type_error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = 'red';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `
                                <div style="color: #d32f2f;">❌ Tray Type Mismatch</div>
                                <div style="font-size: 10px; margin-top: 2px;">
                                    Batch Type: <strong>${result.batch_tray_type || 'Not Set'}</strong><br>
                                    Scanned Type: <strong>${result.scanned_tray_type || 'Not Set'}</strong>
                                </div>
                            `;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#ff5722';
                            input.style.backgroundColor = '#fff3e0';
                            input.focus();
                            input.select();
                            updateUIElements();
                            updateUIElements();
                            
                        } else if (result.polish_finish_error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = 'red';
                            errorDiv.style.fontSize = '11px';
                            errorDiv.style.fontWeight = 'bold';
                            errorDiv.style.backgroundColor = '#ffebee';
                            errorDiv.style.padding = '4px 6px';
                            errorDiv.style.borderRadius = '4px';
                            errorDiv.style.marginTop = '4px';
                            
                            errorDiv.innerHTML = `<div style="color: #d32f2f;">${result.error}</div>`;
                            
                            input.parentNode.appendChild(errorDiv);
                            input.style.borderColor = '#ff5722';
                            input.style.backgroundColor = '#fff3e0';
                            input.focus();
                            input.select();
                            updateUIElements();
                            updateUIElements();
                            
                        } else if (!result.available) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'tray-id-error';
                            errorDiv.style.color = 'red';
                            errorDiv.style.fontSize = '12px';
                            errorDiv.textContent = result.error || 'Tray not available!';
                            input.parentNode.appendChild(errorDiv);
                            
                            input.style.borderColor = '#d32f2f';
                            input.style.backgroundColor = '#ffebee';
                            input.focus();
                            input.select();
                            updateUIElements();
                            updateUIElements();
                        }
                        else if (result.delink_tray) {
                          // Match "Available" style for delinked trays
                          input.style.borderColor = '#4caf50';
                          input.style.backgroundColor = '#f1f8e9'; // same as Available
                          const infoDiv = document.createElement('div');
                          infoDiv.className = 'tray-id-success';
                          infoDiv.style.color = '#2e7d32';
                          infoDiv.style.fontSize = '11px';
                          infoDiv.style.fontWeight = 'bold';
                          infoDiv.innerHTML = `✅ Delinked - available for reuse`;
                          input.parentNode.appendChild(infoDiv);
                        
                          // Auto-disappear after 2 seconds (like Available)
                          setTimeout(() => {
                            if (infoDiv.parentNode) {
                              infoDiv.parentNode.removeChild(infoDiv);
                            }
                          }, 2000);
                          
                          // Auto-focus next empty field after successful delink validation
                          setTimeout(() => {
                              focusNextEmptyTrayInput(input);
                              updateUIElements();
                          }, 200);
                                                    
                        } else if (result.available) {
                            input.style.borderColor = '#4caf50';
                            input.style.backgroundColor = '#f1f8e9';
                            
                            if (result.status === 'pre_configured') {
                                const successDiv = document.createElement('div');
                                successDiv.className = 'tray-id-success';
                                successDiv.style.color = '#2e7d32';
                                successDiv.style.fontSize = '11px';
                                successDiv.style.fontWeight = 'bold';
                                successDiv.innerHTML = `✅ Available (${result.tray_type || 'Type not set'})`;
                                input.parentNode.appendChild(successDiv);
                                
                                setTimeout(() => {
                                    if (successDiv.parentNode) {
                                        successDiv.parentNode.removeChild(successDiv);
                                    }
                                }, 2000);
                            }
                            
                            // Auto-focus next empty field after successful validation
                            setTimeout(() => {
                                focusNextEmptyTrayInput(input);
                                updateUIElements();
                            }, 200);
                        }
                    } catch (e) {
                        console.error('Tray validation error:', e);
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'tray-id-error';
                        errorDiv.style.color = '#ff5722';
                        errorDiv.style.fontSize = '12px';
                        errorDiv.textContent = 'Validation error - please try again';
                        input.parentNode.appendChild(errorDiv);
                        updateUIElements();
                        updateUIElements();
                    }
                    updateUIElements();
                });
                
                input.addEventListener('keydown', async function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                        setTimeout(() => {
                            if (!input.parentNode.querySelector('.tray-id-error')) {
                                focusNextEmptyTrayInput(input);
                            } else {
                                input.focus();
                                input.select();
                            }
                        }, 50);
                    }
                });
            });
        }


        const draftBtn = document.getElementById('trayScanDraftBtn');
        if (draftBtn) {
            draftBtn.onclick = function() {
                if (detailsDiv.querySelector('.tray-id-error')) {
                    Swal.fire('Error', 'Please fix duplicate Tray IDs before saving draft.', 'error');
                    return;
                }
                detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());
          
                const trayRows = [];
                const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
          
                for (let i = 0; i < trayIdInputs.length; i++) {
                    const tray_id = trayIdInputs[i].value;
                    const tray_quantity = trayQtyInputs[i].value;
                    const draft_id = trayIdInputs[i].getAttribute('data-draft-id') || null;
                    
                    trayRows.push({
                        tray_id,
                        tray_quantity,
                        position: i,
                        id: draft_id
                    });
                }

                // Preserve the top-tray verification state and any verified qty
                const verifyCheckbox = detailsDiv.querySelector('.tray-verify-checkbox');
                const topTrayVerified = !!(verifyCheckbox && verifyCheckbox.checked);
                const verifiedQtyInput = detailsDiv.querySelector('.tray-qty-input');
                const verifiedQty = verifiedQtyInput ? parseInt(verifiedQtyInput.value, 10) || 0 : null;

                const batchId = window.currentTrayScanBatchId || '';
          
                console.log('🚀 Saving draft with positions:', trayRows);
          
                fetch('/dayplanning/draft_tray/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        batch_id: batchId,
                        trays: trayRows,
                        top_tray_qty_verified: topTrayVerified,
                        verified_tray_qty: verifiedQty
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        clearTrayVerificationMessage();
                        // If server reports saved top-tray verification state, update opener button data attr
                        const openerBtn = document.querySelector(`.tray-scan-btn[data-batch-id="${batchId}"]`);
                        if (openerBtn) {
                            openerBtn.setAttribute('data-top-tray-qty-verified', data.top_tray_qty_verified ? 'True' : 'False');
                            if (data.verified_tray_qty !== undefined && data.verified_tray_qty !== null) {
                                openerBtn.setAttribute('data-verified-tray-qty', data.verified_tray_qty.toString());
                            }
                        }
                        Swal.fire({
                            icon: 'success',
                            title: 'Success!',
                            text: 'Draft saved!',
                            timer: 1200,
                            showConfirmButton: false
                        }).then(() => {
                            location.reload();
                        });
                        modal.classList.remove("open");
                    } else {
                        Swal.fire('Error', data.error || 'Failed to save draft', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Swal.fire('Error', 'Network error occurred', 'error');
                });
            };
        }
      
        const submitBtn = document.getElementById('trayScanSubmitBtn');
        if (submitBtn) {
            submitBtn.onclick = function() {
                const verifyCheckbox = document.querySelector('.tray-verify-checkbox');
                const isCheckboxChecked = verifyCheckbox && verifyCheckbox.checked;
                
                if (!isCheckboxChecked) {
                    Swal.fire({
                        icon: 'warning',
                        title: 'Verification Required',
                        text: 'Please verify the top tray quantity before submitting.',
                        confirmButtonColor: '#007bff'
                    });
                    return;
                }
                
                if (!validateAllTrayIds()) {
                    Swal.fire({
                        icon: 'warning',
                        title: 'Incomplete Data',
                        text: 'Please fill all Tray IDs before submitting.',
                        confirmButtonColor: '#007bff'
                    });
                    return;
                }
                
                if (detailsDiv.querySelector('.tray-id-error')) {
                    Swal.fire('Error', 'Please fix all validation errors before submitting.', 'error');
                    return;
                }
                
                // FIRST: Verify top tray quantity if checkbox is checked
                if (isCheckboxChecked && !verifyCheckbox.disabled) {
                    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                    let totalQty = 0;
                    trayQtyInputs.forEach(input => {
                        totalQty += parseInt(input.value, 10) || 0;
                    });
                    
                    const batchId = window.currentTrayScanBatchId || '';
                    
                    console.log(`🚀 Verifying top tray quantity before submit:`);
                    console.log(`   Batch ID: ${batchId}`);
                    console.log(`   Total Qty: ${totalQty}`);
                    
                    // Disable submit button during verification
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Verifying...';
                    
                    fetch('/dayplanning/verify_top_tray_qty/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            verified_tray_qty: totalQty
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            console.log(`✅ Top tray verification successful, proceeding with tray scan`);
                            
                            // Update UI to show verification success
                            verifyCheckbox.disabled = true;
                            const editBtn = detailsDiv.querySelector('.tray-edit-btn');
                            if (editBtn) {
                                editBtn.style.opacity = "0.5";
                                editBtn.style.pointerEvents = "none";
                            }
                            
                            const footer = document.getElementById('trayQtyErrorFooter');
                            if (footer) {
                                footer.textContent = 'Top tray quantity verified!';
                                footer.style.color = 'green';
                            }
                            
                            // NOW proceed with the actual tray scan submission
                            proceedWithTraySubmission();
                            
                        } else {
                            console.error(`❌ Top tray verification failed:`, data.error);
                            
                            const footer = document.getElementById('trayQtyErrorFooter');
                            if (footer) {
                                footer.textContent = data.error || 'Failed to verify';
                                footer.style.color = 'red';
                            }
                            
                            Swal.fire({
                                icon: 'error',
                                title: 'Verification Failed',
                                text: data.error || 'Failed to verify top tray quantity. Please try again.',
                                confirmButtonColor: '#007bff'
                            });
                            
                            // Re-enable submit button
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Submit';
                        }
                    })
                    .catch(error => {
                        console.error(`❌ Top tray verification error:`, error);
                        
                        const footer = document.getElementById('trayQtyErrorFooter');
                        if (footer) {
                            footer.textContent = 'Network error occurred';
                            footer.style.color = 'red';
                        }
                        
                        handleNetworkError(error, 'Top Tray Verification');
                        
                        // Re-enable submit button
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit';
                    });
                } else {
                    // Checkbox already verified, proceed directly
                    proceedWithTraySubmission();
                }
                
                // Function to handle the actual tray scan submission
                function proceedWithTraySubmission() {
                    detailsDiv.querySelectorAll('.tray-id-error').forEach(el => el.remove());

                    const trayRows = [];
                    const trayIdInputs = detailsDiv.querySelectorAll('input[type="text"]');
                    const trayQtyInputs = detailsDiv.querySelectorAll('input[type="number"]');
                    
                    for (let i = 0; i < trayIdInputs.length; i++) {
                        const tray_id = trayIdInputs[i].value.trim();
                        const tray_quantity = trayQtyInputs[i].value;
                        
                        trayRows.push({
                            tray_id,
                            tray_quantity
                        });
                    }
                    
                    const batchId = window.currentTrayScanBatchId || '';

                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Processing...';

                    fetch('/dayplanning/tray_scan/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            trays: trayRows
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            if (data.top_tray_scan_required) {
                                console.log('🔍 Top tray scan required - updating UI and keeping modal open');
                    
                                // 🎯 NEW: Update the row immediately without page refresh
                                updateRowAfterTrayScan(batchId, true, true);
                    
                              
                    
                                // Keep modal open and show top tray scan UI
                                showTopTrayScanUIInModal(batchId);
                                return;
                            }
                    
                            console.log('✅ Normal tray scan success - closing modal');
                    
                            Swal.fire({
                                icon: 'success',
                                title: 'Tray Scan Completed!',
                                text: 'Tray scan saved successfully!',
                                timer: 1200,
                                showConfirmButton: false
                            }).then(() => {
                                const modal = document.getElementById("trayScanModal");
                                if (modal) modal.classList.remove("open");
                                clearTrayVerificationMessage();
                                location.reload();
                            });
                    
                        } else if (data.tray_not_in_system_errors) {
                            // Handle various error types as before...
                            // [Keep existing error handling code]
                        } else {
                            Swal.fire('Error', data.error || 'Failed to save tray scan', 'error');
                        }
                    })
                    
                    .catch(error => {
                        console.error('Error:', error);
                        Swal.fire('Error', 'Network error occurred', 'error');
                    })
                    .finally(() => {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit';
                    });
                }
            };
        }
                    

        // Top tray scan UI function
        function showTopTrayScanUIInModal(batchId) {
            console.log('🔍 Showing top tray scan UI within same modal for batch:', batchId);
            
            const modal = document.getElementById("trayScanModal");
            if (modal) {
                modal.classList.add("open");
            }
            
            const detailsDiv = document.getElementById("trayScanDetails");
            const buttonSection = document.querySelector('.tray-scan-modal-buttons');
            const errorFooter = document.getElementById('trayQtyErrorFooter');
            
            if (detailsDiv) {
                detailsDiv.querySelectorAll('input, button, checkbox').forEach(element => {
                    element.disabled = true;
                    element.style.opacity = '0.5';
                    element.style.pointerEvents = 'none';
                });
            }
            
            if (buttonSection) {
                buttonSection.style.display = 'none';
            }
            
            if (errorFooter) {
                errorFooter.textContent = '';
                errorFooter.style.color = '';
            }
            
            const existingSection = document.getElementById('topTrayScanSection');
            if (existingSection) {
                existingSection.remove();
            }
            
            const topTrayScanHTML = `
                <div id="topTrayScanSection" style="margin-top: 20px; padding: 20px; border: 1px solid #28a745; border-radius: 8px; background: #f0fff4;">
                    <h6 style="color: #28a745; font-weight: 600; margin-bottom: 15px; text-align: center;">
                        🔝 Top Tray Scan Required
                    </h6>
                    <p style="text-align: center; color: #666; margin-bottom: 15px; font-size: 14px;">
                        The first tray quantity is 0. Please scan a tray ID from this batch to set as the top tray.
                    </p>
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 15px;">
                        <input 
                            type="text" 
                            id="topTrayIdInput" 
                            placeholder="Scan or enter top tray ID..." 
                            style="width: 250px; padding: 10px; border: 1px solid #28a745; border-radius: 4px; font-size: 14px; text-align: center;"
                        />
                        <button 
                            id="topTrayScanBtn" 
                            style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 14px;"
                            disabled
                        >
                            Set Top Tray
                        </button>
                    </div>
                    <div id="topTrayError" style="color: red; font-size: 12px; text-align: center; margin-top: 8px; min-height: 20px;"></div>
                    <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                        ℹ️ Only non-delinked tray IDs from this batch are valid
                    </div>
                </div>
            `;
            
            if (detailsDiv) {
                detailsDiv.insertAdjacentHTML('afterend', topTrayScanHTML);
            }
            
            const topTrayIdInput = document.getElementById('topTrayIdInput');
            const topTrayScanBtn = document.getElementById('topTrayScanBtn');
            const topTrayError = document.getElementById('topTrayError');
            
            if (topTrayIdInput) {
                setTimeout(() => {
                    topTrayIdInput.focus();
                }, 100);
                
                topTrayIdInput.addEventListener('input', function() {
                    validateTopTrayId(topTrayIdInput.value.trim(), topTrayError, topTrayScanBtn, batchId);
                });
                
                topTrayIdInput.addEventListener('blur', function() {
                    validateTopTrayId(topTrayIdInput.value.trim(), topTrayError, topTrayScanBtn, batchId);
                });
                
                topTrayIdInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (!topTrayScanBtn.disabled) {
                            topTrayScanBtn.click();
                        }
                    }
                });
            }
            
            if (topTrayScanBtn) {
                topTrayScanBtn.onclick = function() {
                    const scannedTrayId = topTrayIdInput.value.trim();
                    
                    if (!scannedTrayId) {
                        topTrayError.textContent = 'Please enter a tray ID.';
                        topTrayError.style.color = 'red';
                        topTrayIdInput.focus();
                        return;
                    }
                    
                    topTrayError.textContent = '';
                    topTrayScanBtn.disabled = true;
                    topTrayScanBtn.textContent = 'Processing...';
                    topTrayScanBtn.style.opacity = '0.6';
                    
                    fetch('/dayplanning/top_tray_scan/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            batch_id: batchId,
                            scanned_tray_id: scannedTrayId
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                    if (data.success) {
                        // ✅ CROSS-BROWSER AUTO-SAVE: Clear auto-saved data on successful top tray scan
                        TrayModalCrossBrowserAutoSave.clearData();
                        updateRowAfterTopTrayScan(batchId);

                        // 1. Close the modal first
                        if (modal) modal.classList.remove("open");
                        clearTrayVerificationMessage();

                        // 2. Then show the success popup
                        setTimeout(() => {
                            Swal.fire({
                                icon: 'success',
                                title: 'Tray Scan Completed!',
                                text: 'Top tray set successfully!',
                                timer: 2000,
                                showConfirmButton: false
                            }).then(() => {
                                location.reload();
                            });
                        }, 300); // Small delay to ensure modal is closed before showing popup
                    } else {
                            topTrayError.style.color = 'red';
                            topTrayError.style.fontSize = '12px';
                            topTrayError.style.fontWeight = 'normal';
                            topTrayError.textContent = '❌ ' + (data.error || 'Failed to set top tray.');
                            topTrayIdInput.focus();
                            topTrayIdInput.select();
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        topTrayError.style.color = 'red';
                        topTrayError.style.fontSize = '12px';
                        topTrayError.style.fontWeight = 'normal';
                        topTrayError.textContent = '❌ Network error occurred.';
                        topTrayIdInput.focus();
                    })
                    .finally(() => {
                        if (!data || !data.success) {
                            topTrayScanBtn.disabled = false;
                            topTrayScanBtn.textContent = 'Set Top Tray';
                            topTrayScanBtn.style.opacity = '1';
                        }
                    });
                };
            }
            
            console.log('✅ Top tray scan UI added to modal successfully');
        }



        async function validateTopTrayId(trayId, errorElement, buttonElement, batchId) {
            errorElement.textContent = '';
            errorElement.style.color = '';
            
            if (!trayId) {
                buttonElement.disabled = true;
                buttonElement.style.opacity = '0.5';
                return;
            }
            
            try {
                const response = await fetch(`/dayplanning/validate_top_tray/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        batch_id: batchId,
                        tray_id: trayId
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.valid) {
                    errorElement.style.color = 'green';
                    errorElement.textContent = '✅ Valid tray ID';
                    buttonElement.disabled = false;
                    buttonElement.style.opacity = '1';
                } else {
                    errorElement.style.color = 'red';
                    errorElement.textContent = '❌ ' + (result.error || 'Invalid tray ID');
                    buttonElement.disabled = true;
                    buttonElement.style.opacity = '0.5';
                }
                
            } catch (error) {
                console.error('Validation error:', error);
                errorElement.style.color = 'red';
                errorElement.textContent = '❌ Unable to validate tray ID';
                buttonElement.disabled = true;
                buttonElement.style.opacity = '0.5';
            }
        }
    });
});



console.log('✅ Enhanced tray scan modal with dynamic row management loaded');
    
    closeBtn.addEventListener("click", () => {
        modal.classList.remove("open");
        clearTrayVerificationMessage();
    });

    
    const cancelBtn = document.getElementById("trayScanCancelBtn");
    if (cancelBtn) {
        cancelBtn.addEventListener("click", function () {
            modal.classList.remove("open");
            clearTrayVerificationMessage();
        });
    }
});
</script>

<!-- Active row to be highlighted & Restores the highlighted row to its original position and removes the highlight bg when the tray scan modal is closed. -->
<script nonce="{{ csp_nonce }}">
  // Row highlight for Tray Scan (matches highlightWF.html logic) + Move active row to top and restore on close
  document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #fff5bd !important;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  document.querySelectorAll('.tray-scan-btn').forEach(function(link) {
    link.addEventListener('click', function(event) {
      // Remove highlight from all rows
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
      });
      // Move the clicked row to the top and highlight
      var row = event.target.closest('tr');
      if (row && row.parentNode) {
        const tbody = row.parentNode;
        // Only move if not already at top
        if (tbody.firstElementChild !== row) {
          // If a previous move exists, restore it first
          if (movedRow && placeholderRow && placeholderRow.parentNode) {
            placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
            placeholderRow.parentNode.removeChild(placeholderRow);
            movedRow.classList.remove('dp-row-action-highlight');
            movedRow = null;
            placeholderRow = null;
            originalRowIndex = null;
          }
          // Store original index and row
          originalRowIndex = Array.from(tbody.children).indexOf(row);
          movedRow = row;
          // Insert a placeholder at the original position
          placeholderRow = document.createElement('tr');
          placeholderRow.style.display = 'none';
          // Add same number of <td> as the moved row
for (let i = 0; i < row.children.length; i++) {
  placeholderRow.appendChild(document.createElement('td'));
}
          tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
          // Move row to top
          tbody.insertBefore(row, tbody.firstElementChild);
        }
        row.classList.add('dp-row-action-highlight');
      }
    });
  });

  // On modal close, restore row to original position and remove highlight for tray-scan-btn
  var closeBtn = document.getElementById('closeTrayScanModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      if (movedRow && placeholderRow && placeholderRow.parentNode) {
        placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
        placeholderRow.parentNode.removeChild(placeholderRow);
        movedRow.classList.remove('dp-row-action-highlight');
        movedRow = null;
        placeholderRow = null;
        originalRowIndex = null;
      }
      // Also remove highlight from any row just in case
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
        row.classList.remove('highlighted-tray-scan');
      });
    });
  }


  // On modal close for view icon, restore row to original position and remove highlight.
  // FIX: Use the close button for the Day Planning modal ("closeTrayScanModal_DayPlanning")
  var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
  if (jigCloseBtn) {
    jigCloseBtn.addEventListener('click', function() {
      if (movedRowJig && placeholderRowJig && placeholderRowJig.parentNode) {
        placeholderRowJig.parentNode.insertBefore(movedRowJig, placeholderRowJig);
        placeholderRowJig.parentNode.removeChild(placeholderRowJig);
        movedRowJig.classList.remove('dp-row-action-highlight');
        movedRowJig = null;
        placeholderRowJig = null;
        originalRowIndexJig = null;
      }
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
        row.classList.remove('highlighted-tray-scan');
      });
    });
  }
});
</script>

<!-- New script appended below without altering existing lines -->
<script nonce="{{ csp_nonce }}">
  // Append new block: Clear highlight and restore row when Draft, Submit, or Cancel is clicked
  document.addEventListener("DOMContentLoaded", function() {
    function clearHighlightAndRestore() {
      var closeBtn = document.getElementById('closeTrayScanModal');
      if (closeBtn) {
        closeBtn.click();
      }
      var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
      if (jigCloseBtn) {
        jigCloseBtn.click();
      }
    }
    
    var draftBtn = document.getElementById("trayScanDraftBtn");
    if (draftBtn) {
      draftBtn.addEventListener("click", function() {
        clearHighlightAndRestore();
      });
    }
    var submitBtn = document.getElementById("trayScanSubmitBtn");
    if (submitBtn) {
      submitBtn.addEventListener("click", function() {
        clearHighlightAndRestore();
      });
    }
    var cancelBtn = document.getElementById("trayScanCancelBtn");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", function() {
        clearHighlightAndRestore();
      });
    }
  });
</script>

<script nonce="{{ csp_nonce }}">
  // Updated JavaScript for hold toggle functionality
  document.addEventListener("DOMContentLoaded", function () {
  let currentHoldCell = null;
  let intendedState = null;
  let currentBatchId = null;

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Toggle click handler
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    btn.addEventListener('click', function (e) {
      e.preventDefault();
      currentHoldCell = btn.closest('td');
      intendedState = btn.checked;
      const row = currentHoldCell.closest('tr');
      currentBatchId = row.getAttribute('data-batch-id');
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // Save remark and update backend
  document.getElementById('saveHoldRemarkBtn').onclick = function () {
    const remark = document.getElementById('holdRemarkInput').value.trim();
    if (!remark) {
      document.getElementById('holdRemarkError').textContent = 'Remark required!';
      return;
    }
    if (!currentHoldCell || !currentBatchId) return;
    
    const action = intendedState ? 'unhold' : 'hold';
    
    fetch('/dayplanning/save_hold_unhold_reason/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        batch_id: currentBatchId,
        remark: remark,
        action: action
      })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        const row = currentHoldCell.closest('tr');
        const toggle = currentHoldCell.querySelector('.hold-toggle-btn');
        const icon = currentHoldCell.querySelector('.hold-remark-icon');
        
        if (action === 'hold') {
          // Hold the row
          toggle.checked = false;
          row.classList.add('row-inactive');
          
          // Apply blur to all cells except the first one
          row.querySelectorAll('td').forEach((td, idx) => {
            if (idx > 0) {
              td.classList.add('row-inactive-blur');
            } else {
              td.classList.remove('row-inactive-blur');
            }
          });
          
          // Show and update the remark icon
          if (icon) {
            icon.style.display = 'inline-block';
            icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />`;
            icon.setAttribute('title', 'Holding Reason: ' + remark);          }
        } else {
          // Unhold the row
          toggle.checked = true;
          row.classList.remove('row-inactive');
          
          // Remove blur from all cells
          row.querySelectorAll('td').forEach(td => {
            td.classList.remove('row-inactive-blur');
          });
          
          // Hide the remark icon
          if (icon) {
            icon.style.display = 'none';
          }
        }
        
        document.getElementById('holdRemarkModal').style.display = 'none';
        location.reload(); // <-- Add this line to reload the page

      } else {
        document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
      }
    })
    .catch(() => {
      document.getElementById('holdRemarkError').textContent = 'Network error!';
    });
  };

  // Modal close
  document.getElementById('closeHoldRemarkModal').onclick = function () {
    document.getElementById('holdRemarkModal').style.display = 'none';
  };

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>

<!-- /**
  * Script for sorting the order listing table
  * This script allows users to click on table headers to sort the rows based on the column data.
  */   -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
    const table = document.getElementById("order-listing");
    if (!table) return;
    const headers = table.querySelectorAll("thead th");
    const tbody = table.querySelector("tbody");
    let sortDirection = {};

    headers.forEach((header, index) => {
      header.style.cursor = "pointer";
      header.addEventListener("click", function () {
        const rows = Array.from(tbody.querySelectorAll("tr"));
        const dir = sortDirection[index] === "asc" ? "desc" : "asc";
        sortDirection[index] = dir;

        rows.sort((a, b) => {
          const cellA = a.children[index]?.textContent.trim() || "";
          const cellB = b.children[index]?.textContent.trim() || "";
          // Try numeric sort, fallback to string
          const numA = parseFloat(cellA.replace(/,/g, ""));
          const numB = parseFloat(cellB.replace(/,/g, ""));
          if (!isNaN(numA) && !isNaN(numB)) {
            return dir === "asc" ? numA - numB : numB - numA;
          }
          return dir === "asc"
            ? cellA.localeCompare(cellB)
            : cellB.localeCompare(cellA);
        });

        tbody.innerHTML = "";
        rows.forEach((row) => tbody.appendChild(row));
      });
    });
  });

</script>

<!-- Sorting script (already present) -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
    const table = document.getElementById("order-listing");
    if (!table) return;
    const headers = table.querySelectorAll("thead th");
    const tbody = table.querySelector("tbody");
    let sortDirection = {};

    headers.forEach((header, index) => {
      header.style.cursor = "pointer";
      header.addEventListener("click", function () {
        const rows = Array.from(tbody.querySelectorAll("tr"));
        const dir = sortDirection[index] === "asc" ? "desc" : "asc";
        sortDirection[index] = dir;

        rows.sort((a, b) => {
          const cellA = a.children[index]?.textContent.trim() || "";
          const cellB = b.children[index]?.textContent.trim() || "";
          // Try numeric sort, fallback to string
          const numA = parseFloat(cellA.replace(/,/g, ""));
          const numB = parseFloat(cellB.replace(/,/g, ""));
          if (!isNaN(numA) && !isNaN(numB)) {
            return dir === "asc" ? numA - numB : numB - numA;
          }
          return dir === "asc"
            ? cellA.localeCompare(cellB)
            : cellB.localeCompare(cellA);
        });

        tbody.innerHTML = "";
        rows.forEach((row) => tbody.appendChild(row));
      });
    });
  });

</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     let openTooltip = null;
   
     // Helper function to completely close a tooltip
     function closeTooltip(tooltip, trigger) {
       if (tooltip) {
         console.log('🔴 Closing tooltip completely');
         
         // Remove pinned class
         tooltip.classList.remove("pinned");
         
         // Hide the entire tooltip completely
         tooltip.style.opacity = "0";
         tooltip.style.pointerEvents = "none";
         tooltip.style.visibility = "hidden";
         tooltip.style.display = "none"; // ✅ ADDED: Force display none
         
         // Hide buttons
         const infoBtn = tooltip.querySelector('.info-btn');
         const closeBtn = tooltip.querySelector('.close-btn');
         if (infoBtn) infoBtn.style.display = 'none';
         if (closeBtn) closeBtn.style.display = 'none';
         
         // Remove visual indicator from trigger
         if (trigger) {
           trigger.style.backgroundColor = '';
           trigger.style.borderRadius = '';
         }
         
         // Clear global reference
         openTooltip = null;
         
         console.log('✅ Tooltip completely closed');
       }
     }
   
     
  document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
  
     // Tooltip show/hide logic
     document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
       const tooltip = trigger.querySelector(".model-image-tooltip");
   
       trigger.addEventListener("mouseenter", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.display = "flex"; // ✅ ADDED: Reset display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Show Info and Close buttons on hover
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         }
       });
   
       trigger.addEventListener("mouseleave", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.opacity = "0";
           tooltip.style.pointerEvents = "none";
           
           // Hide Info and Close buttons when not hovering and not pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'none';
           if (closeBtn) closeBtn.style.display = 'none';
         }
       });
   
       // Keep tooltip visible when hovering over it
       if (tooltip) {
         tooltip.addEventListener("mouseenter", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.display = "flex"; // ✅ ADDED: Reset display
             tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           }
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Keep buttons visible when hovering over tooltip
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         });
   
         tooltip.addEventListener("mouseleave", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.opacity = "0";
             tooltip.style.pointerEvents = "none";
             
             // Hide buttons when leaving tooltip and not pinned
             const infoBtn = tooltip.querySelector('.info-btn');
             const closeBtn = tooltip.querySelector('.close-btn');
             if (infoBtn) infoBtn.style.display = 'none';
             if (closeBtn) closeBtn.style.display = 'none';
           }
         });
       }
   
       trigger.addEventListener("click", function (e) {
         e.stopPropagation();
   
         if (tooltip) {
           // Close any previously opened tooltip
           if (openTooltip && openTooltip !== tooltip) {
             const prevTrigger = openTooltip.closest('.model-hover-trigger');
             closeTooltip(openTooltip, prevTrigger);
           }
   
           tooltip.classList.add("pinned");
           tooltip.style.display = "flex"; // ✅ ADDED: Ensure display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Ensure visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           openTooltip = tooltip;
           
           // Keep buttons visible when pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
   
           // Add visual indicator that tooltip is pinned
           trigger.style.backgroundColor = '#e3f2fd';
           trigger.style.borderRadius = '4px';
         }
       });
   
       // ✅ FIXED: Handle Close button click - Complete tooltip closure
       const closeBtn = tooltip?.querySelector('.close-btn');
       if (closeBtn) {
         // Initially hide the button
         closeBtn.style.display = 'none';
         
         closeBtn.addEventListener('click', function(e) {
           e.stopPropagation();
           console.log('🔴 Close button clicked');
           
           // Use the helper function to completely close tooltip
           closeTooltip(tooltip, trigger);
           
           // Feedback animation for close button
           closeBtn.style.transform = 'scale(0.9)';
           setTimeout(() => {
             if (closeBtn.style) {
               closeBtn.style.transform = 'scale(1)';
             }
           }, 150);
         });
         
         // ✅ Add hover effect for close button
         closeBtn.addEventListener('mouseenter', function() {
           closeBtn.style.backgroundColor = '#c82333';
           closeBtn.style.transform = 'scale(1.05)';
         });
         
         closeBtn.addEventListener('mouseleave', function() {
           closeBtn.style.backgroundColor = '#dc3545';
           closeBtn.style.transform = 'scale(1)';
         });
       }
     });
   
     // ✅ ENHANCED: Close tooltip when clicking outside
     document.addEventListener("click", function (e) {
       if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
       }
     });
   
     // ✅ Close tooltip with ESC key
     document.addEventListener("keydown", function (e) {
       if (e.key === "Escape" && openTooltip) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
         console.log('✅ Tooltip closed with ESC key');
       }
     });
   
     // Prevent tooltip from closing when clicking inside it
     document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
       tooltip.addEventListener("click", function (e) {
         e.stopPropagation();
       });
     });
   });
</script>

<!-- // Parent action lock when modal is open: only allow scrolling and Eye icon (view) -->
<!-- --- Child Screen Lock Feature ---
When child screen (tray scan modal) is open, only allow scroll and "eye" (view) icon access on parent.
All other actions (edit, delete, filter, etc.) are blocked visually and functionally. -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
    // Helper functions to disable/enable Hold toggles
    function disableHoldToggles() {
      document.querySelectorAll('.hold-toggle-btn').forEach(function(btn) {
        btn.disabled = true;
        btn.style.pointerEvents = 'none';
        btn.closest('label')?.classList.add('hold-toggle-disabled');
      });
    }
    function enableHoldToggles() {
      document.querySelectorAll('.hold-toggle-btn').forEach(function(btn) {
        btn.disabled = false;
        btn.style.pointerEvents = '';
        btn.closest('label')?.classList.remove('hold-toggle-disabled');
      });
    }

    // Tray Scan Modal (child screen) open/close logic
    var trayScanModal = document.getElementById("trayScanModal");
    var trayScanModalDayPlanning = document.getElementById("trayScanModal_DayPlanning");
    var closeTrayScanModal = document.getElementById("closeTrayScanModal");
    var closeTrayScanModalDayPlanning = document.getElementById("closeTrayScanModal_DayPlanning");

    // Open: disable Hold toggles
    document.querySelectorAll('.tray-scan-btn').forEach(function(link) {
      link.addEventListener('click', function() {
        setTimeout(disableHoldToggles, 100);
      });
    });
    // Also for Set Top Tray (if you have a separate button, add similar logic)

    // Close: enable Hold toggles
    if (closeTrayScanModal) {
      closeTrayScanModal.addEventListener('click', function() {
        setTimeout(enableHoldToggles, 200);
      });
    }
    if (closeTrayScanModalDayPlanning) {
      closeTrayScanModalDayPlanning.addEventListener('click', function() {
        setTimeout(enableHoldToggles, 200);
      });
    }

    // Also re-enable on modal cancel/draft/submit if needed
    ["trayScanCancelBtn", "trayScanDraftBtn", "trayScanSubmitBtn"].forEach(function(id) {
      var btn = document.getElementById(id);
      if (btn) {
        btn.addEventListener('click', function() {
          setTimeout(enableHoldToggles, 200);
        });
      }
    });
  });

  document.addEventListener("DOMContentLoaded", function () {
  // Helper to add overlay and block actions except view
  function lockParentActions() {
    let overlay = document.getElementById('parent-action-lock-overlay');
    if (!overlay) {
      // Place overlay only over the table, not the whole viewport
      const tableContainer = document.querySelector('.table-responsive');
      if (!tableContainer) return;
      overlay = document.createElement('div');
      overlay.id = 'parent-action-lock-overlay';
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.zIndex = '99998';
      overlay.style.background = 'rgba(255,255,255,0.01)';
      overlay.style.pointerEvents = 'auto';
      overlay.style.cursor = 'default';
      overlay.style.overflow = 'hidden';
      tableContainer.style.position = 'relative';
      tableContainer.appendChild(overlay);

      // Do NOT block or forward wheel/scroll events at all
      // This allows native horizontal and vertical scrolling of the table

      // Allow only "eye" (view) icon clicks to pass through
      overlay.addEventListener('click', function(e) {
        let el = e.target;
        while (el && el !== document.body) {
          if (el.classList && el.classList.contains('tray-scan-btn-Jig')) {
            overlay.style.pointerEvents = 'none';
            el.click();
            overlay.style.pointerEvents = 'auto';
            return;
          }
          el = el.parentElement;
        }
        e.stopPropagation();
        e.preventDefault();
      }, true);
    }

    // Visually block all actions except view icons (no grey, just block)
    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button:not(#closeTrayScanModal_DayPlanning):not(#trayValidateBtn)'
    ).forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = 'not-allowed';
    });

    // Also block all <a> except .tray-scan-btn-Jig
    document.querySelectorAll('a:not(.tray-scan-btn-Jig)').forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '';
      el.style.cursor = 'not-allowed';
    });

    // Restrict menu panel access (sidebar and main-panel)
    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = 'none';
      menuPanel.style.opacity = '';
      menuPanel.style.filter = '';
      menuPanel.style.cursor = 'not-allowed';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = 'auto'; // keep main-panel interactive for scroll
    }
  }

  // Helper to remove overlay and restore actions
  function unlockParentActions() {
    let overlay = document.getElementById('parent-action-lock-overlay');
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);

    document.querySelectorAll(
      'img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, button'
    ).forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
    });
    document.querySelectorAll('a').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.cursor = '';
    });

    // Restore menu panel access
    var menuPanel = document.querySelector('.sidebar');
    if (menuPanel) {
      menuPanel.style.pointerEvents = '';
      menuPanel.style.opacity = '';
      menuPanel.style.filter = '';
      menuPanel.style.cursor = '';
    }
    var mainPanel = document.querySelector('.main-panel');
    if (mainPanel) {
      mainPanel.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var modal = document.getElementById("trayScanModal_DayPlanning");
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // When any view icon is clicked and modal opens, lock parent
  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // When modal closes, unlock parent
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>
 <!-- Tray ID - Instant Validation -->
<script nonce="{{ csp_nonce }}">
  document.body.addEventListener('input', function (e) {
    if (e.target.classList.contains('tray-id-input')) {
      // Remove previous error
      let prevError = e.target.parentNode.querySelector('.tray-id-error');
      if (prevError) prevError.remove();
      let prevSuccess = e.target.parentNode.querySelector('.tray-id-success');
      if (prevSuccess) prevSuccess.remove();
      e.target.style.borderColor = '';
      e.target.style.backgroundColor = '';

      // Debounce validation
      clearTimeout(e.target._validateTimeout);
      e.target._validateTimeout = setTimeout(async () => {
        const trayId = e.target.value.trim();
        if (!trayId) {
          updateUIElements?.(); // keep UI state consistent
          return;
        }
        // Check for duplicates in modal
        const allInputs = Array.from(document.querySelectorAll('.tray-id-input'));
        const isDuplicate = allInputs.filter(inp => inp !== e.target && inp.value.trim() === trayId).length > 0;
        if (isDuplicate) {
          showTrayIdError(e.target, 'Already scanned in a row!');
          updateUIElements?.();
          return;
        }
        // Backend validation
        try {
          const batchId = window.currentTrayScanBatchId || '';
          const resp = await fetch(`/dayplanning/tray_id_unique_check/?tray_id=${encodeURIComponent(trayId)}&batch_id=${encodeURIComponent(batchId)}`, { credentials: 'same-origin' });
          const result = await resp.json();
          if (result.tray_not_in_system) {
            showTrayIdError(e.target, 'Not exists');
          } else if (result.already_scanned) {
            showTrayIdError(e.target, '❌ Already Scanned');
          } else if (result.tray_type_error) {
            showTrayIdError(e.target, '❌ Tray Type Mismatch');
          } else if (!result.available) {
            showTrayIdError(e.target, result.error || 'Tray not available!');
          } else {
            // Valid - show green + "Valid" message
            removeTrayIdMessages(e.target);
            e.target.style.borderColor = '#4caf50';
            e.target.style.backgroundColor = '#f1f8e9';
            showTrayIdSuccess(e.target, 'Valid Tray ID');
          }
        } catch (err) {
          showTrayIdError(e.target, 'Validation error');
        } finally {
          updateUIElements?.();
        }
      }, 300);
    }
  }, true);

  function removeTrayIdMessages(input) {
    const err = input.parentNode.querySelector('.tray-id-error');
    if (err) err.remove();
    const succ = input.parentNode.querySelector('.tray-id-success');
    if (succ) succ.remove();
  }

  function autoFocusFirstTrayInput() {
    const trayInputs = document.querySelectorAll('.tray-id-input');
    for (let input of trayInputs) {
      if (!input.value.trim()) {
        input.focus();
        input.select();
        return;
      }
    }
    // If all filled, do not focus any to avoid interfering with checkbox
  }

  function focusNextEmptyTrayInput(currentInput) {
    const trayInputsList = Array.from(document.querySelectorAll('.tray-id-input'));
    const currentIndex = trayInputsList.indexOf(currentInput);
    if (currentIndex === -1) return;
    for (let i = currentIndex + 1; i < trayInputsList.length; i++) {
      if (!trayInputsList[i].value.trim()) {
        trayInputsList[i].focus();
        trayInputsList[i].select();
        return;
      }
    }
    // If no empty after, do nothing
  }

  function showTrayIdSuccess(input, msg) {
    removeTrayIdMessages(input);
    const div = document.createElement('div');
    div.className = 'tray-id-success';
    div.style.color = '#2e7d32';
    div.style.fontSize = '11px';
    div.style.fontWeight = '600';
    div.style.backgroundColor = '#e8f5e9';
    div.style.padding = '4px 6px';
    div.style.borderRadius = '4px';
    div.style.marginTop = '4px';
    div.textContent = msg || 'Valid';
    input.parentNode.appendChild(div);
    // auto hide after 2s to match previous success UX
    setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 2000);
  }

  function showTrayIdError(input, msg) {
    removeTrayIdMessages(input);
    let errorDiv = input.parentNode.querySelector('.tray-id-error');
    if (!errorDiv) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'tray-id-error';
      errorDiv.style.color = '#d32f2f';
      errorDiv.style.fontSize = '11px';
      errorDiv.style.fontWeight = '600';
      errorDiv.style.backgroundColor = '#ffebee';
      errorDiv.style.padding = '4px 6px';
      errorDiv.style.borderRadius = '4px';
      errorDiv.style.marginTop = '4px';
      input.parentNode.appendChild(errorDiv);
    }
    errorDiv.textContent = msg;
    input.style.borderColor = '#d32f2f';
    input.style.backgroundColor = '#ffebee';
  }
</script>
  {% endblock %} {% endblock content %}
</div>