{% extends "base.html" %} 
{% load static %}
{% load stock_filters %} 
{% block content %}
 
  <style>
    /* ✅ FIX: Ensure acceptedTrayCancelBtn is always accessible */
    #acceptedTrayCancelBtn {
      z-index: 900005 !important; /* Highest priority above all modals and overlays */
      pointer-events: auto !important;
      cursor: pointer !important;
      position: relative !important;
      opacity: 1 !important;
      user-select: none !important;
    }
    
    /* Override any conflicting styles when modal is open */
    .new-popup-modal.open #acceptedTrayCancelBtn {
      pointer-events: auto !important;
      z-index: 900005 !important;
      cursor: pointer !important;
    }
    
    /* Ensure button remains accessible even with body pointer-events restrictions */
    body[style*="pointer-events: none"] #acceptedTrayCancelBtn {
      pointer-events: auto !important;
    }

/* ========== Tablet override — paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }

.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(5)  { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 105px !important; max-width: 105px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 110px !important; max-width: 110px !important; }
  #order-listing th:nth-child(12) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(13) { min-width: 125px !important; max-width: 120px !important; }
  #order-listing th:nth-child(14) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(15) { min-width: 110px !important; max-width: 100px !important; }
  #order-listing th:nth-child(16) { min-width: 120px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
} 
      /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
  border-bottom: 2.5px solid #bdbdbd !important; /* Thicker grey line below heading */
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 85px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 110px;
  max-width: 110px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 90px;
  max-width: 95px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 80px;
  max-width: 80px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 90px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 160px;
  max-width: 170px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(18) {
  min-width: 100px;
  max-width: 110px;
}


/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}

/* ...existing code... */

/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }

  /* Styling for remark tooltip close button */
  .remark-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    display: none;
    line-height: 1;
    padding: 0;
    transition: all 0.2s ease;
    z-index: 1001;
  }

  .remark-close-btn:hover {
    background: #c82333;
    transform: scale(1.05);
  }

  .remark-close-btn:active {
    transform: scale(0.95);
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 100px 200px 160px !important; /* ✅ Increased column widths for better spacing */
  gap: 2px !important; /* ✅ Added gap for cleaner separation */
  max-height: 400px !important; /* ✅ Increased height for better usability */
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding: 15px 20px 15px 10px; /* ✅ Enhanced padding for professional look */
  margin-top: 15px; /* ✅ Better top spacing */
  border: 2px solid #e1e8ed; /* ✅ Subtle professional border */
  border-radius: 8px; /* ✅ Modern rounded corners */
  background: #fafbfc; /* ✅ Professional background */
  box-shadow: 0 2px 8px rgba(0,0,0,0.08); /* ✅ Professional shadow */
}
 

#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* ✅ MODAL Z-INDEX FIX: Ensure modals and their elements stay above all other content */
.new-popup-modal,
.tray-scan-modal,
.tray-scan-modal-DayPlanning {
  z-index: 900000 !important; /* Above tooltips (500000) but below critical overlays */
}

.new-popup-modal *,
.tray-scan-modal *,
.tray-scan-modal-DayPlanning * {
  z-index: inherit !important; /* Inherit modal's high z-index */
}

/* Ensure modal close buttons are always clickable */
#closeAcceptedTrayModal,
#closeNewPopupModal,
#closeTrayScanModal,
#closeTrayScanModal_DayPlanning {
  z-index: 900001 !important; /* Slightly above modal content */
  pointer-events: auto !important;
 
}

/* ✅ Move close icon to right side for trayScanModal_DayPlanning */
#closeTrayScanModal_DayPlanning {
  position: absolute !important;
  top: 10px !important;
  right: 15px !important;
  font-size: 24px !important;
  color: #dc3545 !important;
  cursor: pointer !important;
  z-index: 900002 !important; /* Above modal content */
  pointer-events: auto !important;
  transition: color 0.3s ease !important;
}




#closeAcceptedTrayModal {
  /* ...existing styles... */
  color: #dc3545 !important; /* Use a grey shade, or remove this line for default */
}

/* Ensure modal backdrop doesn't interfere */
.new-popup-modal.open #closeAcceptedTrayModal {
  pointer-events: auto !important;
  cursor: pointer !important;
}

/* ✅ FIX: Ensure accepted tray modal buttons display in original colors (not grey) */
.new-popup-modal button {
  opacity: 1 !important;
  pointer-events: auto !important;
  cursor: pointer !important;
  background-color: initial !important; /* Reset to original background */
  color: white !important; /* Ensure text is visible */
  border: none !important; /* Maintain original border */
  border-radius: 30px !important; /* Maintain original radius */
}

/* Specific overrides for each button to ensure original colors */
#acceptedTrayUpdateDraftBtn {
  background-color: #f39c12 !important; /* Original draft color */
}

#acceptedTrayFinalSubmitBtn,
#acceptedTraySubmitBtn {
  background-color: #28a745 !important; /* Original submit color */
}

#acceptedTrayDraftBtn {
  background-color: #007bff !important; /* Original draft color */
}

#acceptedTrayCancelBtn {
  background-color: #6c757d !important; /* Original cancel color */
}

/* Override any disabled-looking styles */
.new-popup-modal button:disabled,
.new-popup-modal button[disabled] {
  opacity: 1 !important;
  background-color: #ccc !important; /* Fallback grey for truly disabled buttons */
  cursor: not-allowed !important;
}

/* Ensure buttons look enabled when modal is open */
.new-popup-modal.open button {
  opacity: 1 !important;
  filter: none !important; /* Remove any greyscale or blur effects */
}

/* Specific targeting for draft mode buttons */
#acceptedTrayUpdateDraftBtn,
#acceptedTrayFinalSubmitBtn,
#acceptedTrayDraftBtn,
#acceptedTraySubmitBtn,
#acceptedTrayCancelBtn {
  z-index: 900004 !important; /* Highest priority */
  pointer-events: auto !important;
  position: relative !important;
  cursor: pointer !important;
}

/* Override any conflicting styles when modal is open */
.new-popup-modal.open button {
  pointer-events: auto !important;
  z-index: 900004 !important;
}

/* Ensure modal backdrop doesn't interfere */
.new-popup-modal {
  pointer-events: auto !important;
}

.new-popup-modal * {
  pointer-events: inherit !important; /* Allow children to inherit */
}

/* Override any conflicting styles */
.new-popup-modal * #closeAcceptedTrayModal,
.new-popup-modal.open * #closeAcceptedTrayModal {
  pointer-events: auto !important;
  cursor: pointer !important;
  z-index: 900003 !important;
}

/* Reduce tooltip z-index when modal is open */
body:has(.new-popup-modal.open) .model-image-tooltip,
body:has(.tray-scan-modal.open) .model-image-tooltip,
body:has(.tray-scan-modal-DayPlanning.open) .model-image-tooltip {
  z-index: 10000 !important; /* Much lower when modal is active */
  pointer-events: none !important; /* Disable tooltip interaction when modal is open */
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* ✅ ENHANCED: Professional 4-column layout with validation status */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 80px 1fr 120px 160px !important; /* ✅ Better proportions */
  overflow-y: auto !important;
  overflow-x: hidden !important;
  gap: 3px !important; /* ✅ Consistent gap for 4-column */
}
 
/* ✅ ENHANCED: Professional styling for individual grid cells inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #ffffff; /* ✅ Clean white background */
  padding: 12px 15px; /* ✅ Generous padding for readability */
  font-size: 14px; /* ✅ Better readability font size */
  font-weight: 500; /* ✅ Semi-bold for clarity */
  line-height: 1.4; /* ✅ Better line spacing */
  border: 1px solid #e1e8ed; /* ✅ Subtle modern border */
  border-radius: 6px; /* ✅ Rounded corners for modern look */
  margin: 0; /* reset any margin from <p> or others */
  color: #2c3e50; /* ✅ Professional text color */
  transition: background-color 0.2s ease; /* ✅ Smooth hover effect */
}

/* ✅ ADDED: Hover effect for interactive feel */
#trayScanDetails.table-grid > div:hover {
  background: #f8f9fa;
  border-color: #c3d4e6;
}
 
/* ✅ ENHANCED: Professional S.no column styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 700; /* ✅ Bold for S.no */
  padding: 12px 8px; /* ✅ Better padding for S.no */
  background: #f0f4f8; /* ✅ Distinct background for S.no */
  color: #495057; /* ✅ Professional color */
  border-left: 3px solid #007bff; /* ✅ Professional accent border */
}
 
/* ✅ ENHANCED: Mobile responsiveness with professional styling */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 60px 1fr 1fr !important; /* ✅ Better mobile S.no column */
    gap: 1px !important; /* ✅ Tighter gap on mobile */
    padding: 10px 15px; /* ✅ Adjusted mobile padding */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 50px 1fr 90px 110px !important; /* ✅ Better mobile proportions */
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 8px 4px; /* ✅ Adjusted mobile S.no padding */
    font-size: 12px; /* ✅ Readable font size on mobile */
    font-weight: 700;
  }
  #trayScanDetails.table-grid > div {
    padding: 8px 10px; /* ✅ Adjusted mobile cell padding */
    font-size: 13px; /* ✅ Mobile font size */
  }
}
 
/* ✅ ENHANCED: Very small screens with professional styling */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 80px !important; /* ✅ Compact mobile S.no column */
    padding: 8px 10px; /* ✅ Compact mobile padding */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 75px 95px !important; /* ✅ Compact 4-column */
  }
  #trayScanDetails.table-grid > div {
    padding: 6px 8px; /* ✅ Very compact cell padding */
    font-size: 12px; /* ✅ Compact font size */
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 3px; /* ✅ Very compact S.no padding */
    font-size: 11px;
    font-weight: 700;
  }
}

/* ========== HOLD/UNHOLD TOGGLE SWITCH STYLES ========== */
.hold-toggle-switch {
  position: relative;
  display: inline-block;
  width: 34px;
  height: 20px; 
}

.hold-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.hold-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 20px;
}

.hold-slider:before {
  position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: #bbb;
    border: 2px solid #bbb;
    border-radius: 50%;
    transition: 0.3s;
}

input:checked + .hold-slider {
  position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e5e5e5;
    border-radius: 20px;
    transition: 0.3s;
  }

input:focus + .hold-slider {
  box-shadow: 0 0 1px #28a745;
}

input:checked + .hold-slider:before {
  transform: translateX(14px);
}

/* Disabled state for toggle switch */
.hold-toggle-switch input:disabled + .hold-slider {
  opacity: 0.5;
  cursor: pointer;
  background-color: #e0e0e0;
}

.hold-toggle-switch input:disabled + .hold-slider:before {
  background-color: #f5f5f5;
}

/* Hold remark icon styles */
.hold-remark-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.hold-remark-icon:hover {
  transform: scale(1.1);
    cursor: pointer;

}

.row-inactive {
  cursor: pointer !important;
}

.row-inactive * {
  cursor: pointer !important;
}
</style>
 

<div class="content-wrapper">
   <div class="col-12 grid-margin stretch-card">
      <div class="card">
         <div class="card-body" style="padding-bottom:12px;">
          <div class="mb-4">
            <h5 class="text-left mt-0 mb-0 d-inline-block" style="font-weight:700;">
              Input Screening Pick Table
              <button type="button" class="btn btn-primary btn-sm ms-3" id="scanButton" 
                      style="background-color: #028084; border-color: #028084; font-weight: 600; vertical-align: middle;">
                <i class="fa fa-qrcode" style="margin-right: 6px;"></i>
                Scan
              </button>
              <span id="scanStatusMessage" style="display: none; margin-left: 12px; vertical-align: middle; color: #28a745; font-size: 15px; font-weight: 700;">PLEASE SCAN</span>
            </h5>
            
            <!-- Hidden input for scanner -->
            <input type="text" id="scanHiddenInput" style="position: absolute; left: -9999px; opacity: 0;" />
            
            <!-- Status message -->
            <div id="scanMessage" style="display: none; margin-top: 8px; padding: 6px 12px; border-radius: 4px; font-size: 14px; font-weight: 600;"></div>
          </div>
            <div class="table-responsive" style="overflow: scroll !important">
               <table id="order-listing" class="table">
                  <thead>
                     <tr>
                        <th>
                           S.No <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Last<br>Updated
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Plating <br> Stk No
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Polishing Stk No
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Plating Color
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Category
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Polish Finish
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Tray Cate- <br> Capacity
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Input Source
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           IPA Wiping
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           No of Trays <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           LOT Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th style="display: none;">
                           Physical Qty
                           <i class="fa fa-filter" aria-hidden="true" ></i>
                        </th>
                        <th>
                           Accept Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Reject Qty
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Process Status
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Action <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Lot Status
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th style = "cursor: pointer;min-width: 135px;max-width: 140px;">
                           Current <br> Stage
                           <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                        <th>
                           Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                        </th>
                     </tr>
                  </thead>
                  <tbody>
                     <!-- Row 1 - Highlighted -->
                     {% for data in master_data %}
                     <tr class="highlighted-tray-scan{% if data.ip_hold_lot %} row-inactive{% endif %}"
                        data-stock-lot-id="{{ data.stock_lot_id }}"
                        data-batch-id="{{ data.batch_id }}"
                        data-available-qty="{{ data.available_qty }}"
                        data-ip-onhold-picking="{{ data.ip_onhold_picking }}"
                        data-tray-verify="{{ data.tray_verify }}"
                        data-draft-tray-verify="{{ data.draft_tray_verify }}"
                        data-ip-hold-lot="{{ data.ip_hold_lot }}"
                        data-few-cases-acceptance="{{data.few_cases_accepted_Ip_stock}}"
                        data-model-no="{{ data.plating_stk_no }}"
                        data-remark="{{ data.IP_pick_remarks|default_if_none:'' }}">


<td>
  <span style="display:flex; align-items:center; gap:3px;">
    {% if is_admin %}
    <!-- Admin users: Show toggle switch -->
    <label class="hold-toggle-switch" style="margin-bottom:0;">
      {% if not data.ip_hold_lot %}
      <input type="checkbox" class="hold-toggle-btn" checked />
      <span class="hold-slider"></span>
      {% else %}
      <input type="checkbox" class="hold-toggle-btn" />
      <span class="hold-slider"></span>
      {% endif %}
    </label>
    <!-- Hold remark icon -->
    <span class="hold-remark-icon" 
      data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
      {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
      <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
      {% endif %}
    </span>
    {% else %}
    <!-- Non-admin: Only show view icon if there's a holding/release reason -->
    {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
    <span class="hold-remark-icon" 
      data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
      <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
    </span>
    {% endif %}
    {% endif %}
    <!-- S.no cell should NOT be blurred even if hold -->
    <span class="sno-value" {% if data.ip_hold_lot %} style="filter:none;opacity:1;"{% endif %}>{{ page_obj.start_index|add:forloop.counter0 }}</span>
  </span>
</td>   
                        <!-- Plating Stk No Column -->       
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}style="white-space:normal;word-break:break-all;">
                        {{ data.created_at|date:"d-M-y"  }}<br>
                        <span style="display:inline-block; margin-top:4px;word-break: break-all;">{{ data.created_at|date:"h:i A" }}</span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                           {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                           <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                              <!-- Header with Info and Close buttons - Initially hidden -->
                              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                 <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; display: none;">
                                 Info
                                 </button>
                                 <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; display: none;">
                                 Close
                                 </button>
                              </div>
                              <!-- Image gallery section -->
                              <div style="display: flex; align-items: center; gap: 8px;">
                                 <button class="img-scroll-left" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8592;</button>
                                 <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                                    {% for img_url in data.model_images %}
                                    <img src="{{ img_url }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                                    {% endfor %}
                                 </div>
                                 <button class="img-scroll-right" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8594;</button>
                              </div>
                           </div>
                        </span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.category }}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.polish_finish}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.tray_type}}-{{data.tray_capacity}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.location__location_name}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if data.wiping_required %}
                        Yes
                        {% else %}
                        No
                        {% endif %}
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.no_of_trays}}</td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <span class="lot-qty" style="min-width: 30px; text-align: right">{{ data.total_batch_quantity }}</span>
                        <span style="
                          display: inline-flex;
                          align-items: center;
                          justify-content: center;
                          width: 19px;
                          height: 19px;
                          border-radius: 50%;
                          background: {% if data.ip_person_qty_verified %}#0c8249{% else %}#bdbdbd{% endif %};
                          color: white;
                          font-size: 14px;
                          font-weight: bold;
                          margin-left: 2px;
                        ">
                          &#10003;
                        </span>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %} style="display: none;">
                        <input
                        type="text"
                        class="physical-qty-input"
                        value="{{ data.dp_physical_qty }}"
                        style="width: 36px; padding: 1px 3px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;
                        {% if data.dp_physical_qty_edited %}background-color: #fff3cd; border-color: #ffc107;{% endif %}"
                        readonly
                        {% if data.dp_physical_qty_edited %}title="This quantity was edited"{% endif %}
                        />
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{data.display_accepted_qty|default:0}}   
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.ip_rejection_total_qty|default:0 }}
                        </td>
                        <!-- Process Status Column -->
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <div class="process-status-group d-flex align-items-center justify-content-center" style="gap: 6px;">
                           <!-- Q icon -->
                           <div
                              data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Quantity"
                              class="d-flex align-items-center justify-content-center rounded-circle"
                              style="width: 28px; height: 28px; 
                              {% if data.ip_person_qty_verified %}
                              background-color: #0c8249;
                              {% elif data.draft_tray_verify and not data.ip_person_qty_verified %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% else %}
                              background-color: #bdbdbd;
                              {% endif %}
                              color: white; font-weight: bold; font-size: 15px;">
                              Q
                           </div>
                           <!-- S icon -->
                           <div
                              data-bs-toggle="tooltip" data-placement="right" data-bs-original-title="Screening"
                              class="d-flex align-items-center justify-content-center rounded-circle"
                              style="
                              width: 28px; height: 28px;
                              {% if data.ip_person_qty_verified and data.accepted_tray_scan_status and data.few_cases_accepted_Ip_stock and not data.ip_onhold_picking %}
                              background-color: #0c8249;
                              {% elif data.ip_person_qty_verified and data.ip_onhold_picking and data.few_cases_accepted_Ip_stock %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% elif data.draft_tray_verify and data.ip_onhold_picking and not data.few_cases_accepted_Ip_stock %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                              {% else %}
                              background-color: #bdbdbd;
                              {% endif %}
                              color: white; font-weight: bold; font-size: 15px;">
                              S
                           </div>
                        </div>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <!-- ✅ Always show delete button for admin users, regardless of processing status -->
                        {% if is_admin%}
                        <a href="#" class="delete-batch-btn" title="Delete" data-batch-id="{{ data.batch_id }}" data-stock-lot-id="{{ data.stock_lot_id }}">
                        <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                        </a>
                        {% endif %}
                        
                        {% if not data.accepted_Ip_stock and not data.rejected_ip_stock and not data.accepted_tray_scan_status %}
                        <!-- Accept/Reject Buttons Section -->
                        {% if data.few_cases_accepted_Ip_stock and data.ip_onhold_picking %}
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                           style="background-color: #66bb6a; pointer-events: none; opacity: 0.6; cursor: not-allowed;"
                           disabled>
                        <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                           style="background-color: #e57373;"
                           data-stock-lot-id="{{ data.stock_lot_id }}"
                           data-batch-id="{{ data.batch_id }}"
                           data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}">
                        <i class="fa fa-times-circle"></i>Set Top Tray
                        </button>
                        {% else %}
                        <button type="button" class="btn btn-social-icon-text btn-twitter"
                        style="background-color: #66bb6a;"
                        data-lot-id="{{ data.stock_lot_id }}"
                        {% if not data.ip_person_qty_verified %}disabled{% endif %}>
                        <i class="fa fa-check-circle"></i>Accept
                        </button>
                        <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
                        style="background-color: #e57373;"
                        data-stock-lot-id="{{ data.stock_lot_id }}"
                        data-batch-id="{{ data.batch_id }}"
                        data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}"
                        {% if not data.ip_person_qty_verified %}disabled{% endif %}>
                        <i class="fa fa-times-circle"></i>Reject
                        </button>
                        {% endif %}
                        {% endif %}
                        <!-- Eye icon to view submitted "Tray Scan Table" -->
                        <a href="#"
                           title="View"
                           class="text-primary tray-scan-btn-DayPlanning-view tray-scan-btn-Jig"
                           style="text-decoration: underline"
                           data-stock-lot-id="{{ data.stock_lot_id }}"
                           data-batch-id="{{ data.batch_id }}"
                           data-model-no="{{ data.plating_stk_no }}"
                           data-no-of-trays="{{ data.no_of_trays }}"
                           data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
                           data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
                           data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
                           data-model-image="{{ data.model_images.0|default:'' }}"
                           data-ip-person-qty-verified="{{ data.ip_person_qty_verified|yesno:'true,false' }}"
                           data-total-batch-quantity="{{ data.total_batch_quantity }}">
                        <img src="{% static 'assets/icons/view.png' %}"
                           alt="View"
                           style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
                        </a>
                        </td>

                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {% if data.ip_hold_lot %}
                        <!-- When ip_hold_lot is True, show "On Hold" status -->
                        <div
                           class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="
                           border: 1px solid #dc3545;
                           background-color: #f8d7da;
                           color: #721c24;
                           font-size: 12px;
                           white-space: nowrap;
                           padding: 5px;
                           "
                           >
                           On Hold
                        </div>
                        {% elif data.draft_tray_verify %}
                        <div
                           class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="
                           border: 1px solid #4997ac;
                           background-color: #d1f2f3;
                           color: #03425d;
                           font-size: 12px;
                           white-space: nowrap;
                           padding: 5px;
                           "
                           >
                           Draft
                        </div>
                        {% else %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size: 13px; white-space: nowrap; padding: 0.3rem;">
                           Yet to Start
                        </div>
                        {% endif %}
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #d1edf3; background-color: #d1edf3; color: #033b5d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                        </td>
                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <!-- VoiceRec with tooltip (audio remark) -->
                        <!-- VoiceRec with tooltip (audio remark) -->
                         
                          <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                            <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                            <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                              <!-- Audio recording UI placeholder -->
                              <div style="display: flex; align-items: center; gap: 10px;">
                                <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                  <i class="fa fa-microphone"></i>
                                </button>
                                <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                                  <div style="text-align: right; margin-top: 10px;">
                                <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                  <i class="fa fa-send"></i>
                                </button>
                              </div>
                              </div>
                            
                            </div>
                          </a>

              <a
  href="#"
  title="Add Remark"
  class="remark-tooltip-trigger"
>
  <img
    src="{% static 'assets/icons/chat_icon.png' %}"
    alt="Chat"
    style="width: 20px; height: 20px; {% if data.IP_pick_remarks %}
      filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2);
      opacity: 1;
    {% else %}
      filter: grayscale(1) brightness(0.8);
      opacity: 0.7;
    {% endif %}"
  />

                             <div
                              class="remark-tooltip"
                              style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 270px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                            >
                              <!-- Close button in top-right corner -->
                              <button type="button" class="remark-close-btn" style="position: absolute; top: 8px; right: 8px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 12px; cursor: pointer; display: none; line-height: 1; padding: 0;">
                                ×
                              </button>
                              <textarea
                                placeholder="Type your remark..."
                                style="width: 75%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                {% if data.IP_pick_remarks %}readonly{% endif %}
                              >{{ data.IP_pick_remarks|default_if_none:"" }}</textarea>
                              <div style="text-align: right; margin-top: -35px">
                                {% if not data.IP_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" ></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                {% endif %}
                              </div>
                            </div>
                          </a>
                       
                        </td>
                      
                     </tr>
                     {% endfor%}
                  </tbody>
               </table>
               <!-- Tray Scan Modal for Input Screening -->
               <div
                  id="trayScanModal_DayPlanning"
                  class="tray-scan-modal-DayPlanning"
                  >
                  <div class="tray-scan-modal-DayPlanning-content">
                     <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly"
                        >&times;</span
                        >
                     <!-- New top header container: title + user profile aligned left -->
                     <div
                        class="modal-top-header"
                        style="
                        display: flex;
                        align-items: center;
                        gap: 20px;
                        padding-bottom: 10px;
                        margin: 0px !important;
                        "
                        >
                        <div
                           class="user-profile"
                           style="display: flex; align-items: center; gap: 8px"
                           >
                           <img
                              src="/static/assets/images/imagePlaceholder.png"
                              alt="User Profile"
                              style="
                              border-radius: 50%;
                              width: 50px;
                              height: 50px;
                              object-fit: cover;
                              "
                              />
                           <!-- Model No and Lot Qty in same line -->
                           <div style="display: flex; flex-direction: column; gap: 2px;">
                              <div style="display: flex; align-items: center; gap: 15px;">
                                 <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: bold; color: #666;">Model No:</span>
                                    <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
                                 </div>
                                 <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: bold; color: #666;">Lot Qty:</span>
                                    <h6 id="modalLotQty_DayPlanning" style="margin: 0; color: #e67e22; font-weight: bold;">(Fetch Dynamically)</h6>
                                 </div>
                              </div>
                           </div>
                        </div>
                     </div>


                     <!-- Redo icon for clearing "tray ID" -->
                     <div id="trayValidateSection" style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                           Input Screening - Tray Scan
                        </h5>
                        <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
                        Tray Validate
                        </button>
                        <!-- Please Scan indicator -->
                        <span id="pleaseScanIndicator" style="display: none; margin-left: 12px; vertical-align: middle; color: #28a745; font-size: 15px; font-weight: 700;">PLEASE SCAN</span>
                        <span id="trayQtyRedoBtn" title="Reset Top Tray Qty" style="display:none; cursor:pointer; margin-left:6px;">
                        <img src="{% static 'assets/icons/redo2.png' %}" style="width:22px;vertical-align:middle;" />
                        </span>
                        <!-- Hidden input field -->
                        <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                     </div>
                     <!-- Add verification status indicator when buttons are hidden -->
                     <div id="verificationStatusIndicator" style="display: none; margin-bottom: 8px;">
                        <h5 style="text-align: center; margin: 0; font-weight: 600; color:#595959">
                           Input Screening - Tray Scan
                        </h5>
                     </div>
                     <!-- Error message container - initially hidden -->
                     <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
                        <span id="trayErrorText"></span>
                     </div>
                     <!-- trayScanDetails_DayPlanning will be a scrollable 3-column grid with headers and unlimited rows -->
                     <div id="trayScanDetails_DayPlanning" class="table-grid">
                        <!-- Headers -->
                        <div>S.no</div>
                        <div>Tray ID</div>
                        <div>Tray Quantity</div>
                        <!-- Example rows (replace with dynamic content) -->
                     </div>
                     <!-- No buttons for read-only modal -->
                  </div>
               </div>
            </div>
            <!-- Tray Scan Details Modal (Left Popup) -->
            <div id="trayScanModal" class="tray-scan-modal">
               <div class="tray-scan-modal-content">
                  <span id="closeTrayScanModal" class="tray-scan-close"
                     >&times;</span
                     >
                  <h4 id="trayScanModalHeader">Input Screening / <span class="modal-model-no"></span> / Rejection Window</h4>
                  <div id="trayScanDetails">
                     <!-- Dynamic content will be loaded here -->
                  </div>
               </div>
            </div>
            <!-- New Popup Modal (Right Popup) -->
            <div id="newPopupModal" class="new-popup-modal">
               <div class="tray-scan-modal-content" >
                  <span id="closeNewPopupModal" class="tray-scan-close"
                     >&times;</span
                     >
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                     class="modal-top-header"
                     style="
                     display: flex;
                     align-items: center;
                     gap: 20px;
                     padding-bottom: 10px;
                     "
                     >
                  </div>
                  <!-- Existing centered h3 title -->
                  <!-- Redo icon for clearing "tray ID" -->
                  <!-- Accepted Case Tray Scan Table - Grid View with Visible Borders -->
                  <div id="trayScanDetails" class="table-grid">
                     <!-- NEW BUTTONS SECTION -->
                     <div class="tray-scan-modal-buttons" style="grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
                        <button
                           style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                        Draft
                        </button>
                        <button
                           style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                        Submit
                        </button>
                        <button
                           style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                        Cancel
                        </button>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <!-- Pagination Section -->
         <div class="pagination-wrapper">
            <nav aria-label="Page navigation">
               <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                  <li>
                     <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                     <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                     </a>
                  </li>
                  {% else %}
                  <li class="disabled">
                     <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                  </li>
                  {% endif %}
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                  <li><a href="?page=1">1</a></li>
                  {% if page_obj.number > 4 %}
                  <li class="disabled"><span>…</span></li>
                  {% endif %}
                  {% endif %}
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                  {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                  {% if num == page_obj.number %}
                  <li class="active"><span>{{ num }}</span></li>
                  {% else %}
                  <li><a href="?page={{ num }}">{{ num }}</a></li>
                  {% endif %}
                  {% endif %}
                  {% endfor %}
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                  <li class="disabled"><span>…</span></li>
                  {% endif %}
                  <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                  {# Next button #}
                  {% if page_obj.has_next %}
                  <li>
                     <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                     <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                     </a>
                  </li>
                  {% else %}
                  <li class="disabled">
                     <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                  </li>
                  {% endif %}
               </ul>
            </nav>
         </div>
      </div>
   </div>
</div>
</div>
<!-- Image Slider Modal (popup) -->
<div id="imageSliderModal" class="image-slider-modal">
   <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
   <h3>Visual Aid</h3>
   <div class="slider" id="slider">
      <div class="slides" id="slidesContainer">
         <div class="slide active">
            <img src="{% static 'assets/images/carousel/banner_1.jpg' %}" alt="Slide 1">
         </div>
         <div class="slide">
            <img src="{% static 'assets/images/carousel/banner_2.jpg' %}" alt="Slide 2">
         </div>
         <div class="slide">
            <img src="{% static 'assets/images/carousel/banner_3.jpg' %}" alt="Slide 3">
         </div>
      </div>
      <button class="prev" id="prevBtn">&#10094;</button>
      <button class="next" id="nextBtn">&#10095;</button>
   </div>
</div>
<!-- Image Slider Modal -->
<div id="imageSliderModal" class="image-slider-modal">
   <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
   <div class="slider" id="slider">
      <button class="prev" id="prevBtn">&#8592;</button>
      <div class="slides"></div>
      <button class="next" id="nextBtn">&#8594;</button>
   </div>
</div>
<!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
   <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
      <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
      <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
      <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
      <div style="text-align:right; margin-top:10px;">
         <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
      </div>
      <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
   </div>
</div>

{% block script %}

<!-- Barcode Scanner Integration Script -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // ✅ NEW: Check for pending scans after page load (for pagination scanning)
  setTimeout(() => {
    checkPendingScanAfterPageLoad();
  }, 500);
  
  // ✅ NEW: Clear any highlighted row state on page load (for pagination)
  window.currentHighlightedRow = null;
  window.currentHighlightedLotId = null;
  window.originalRowPosition = null;
  
  // ✅ NEW: Initialize manual draft flag
  window.isManualDraftInProgress = false;
  window.isManualDraftMode = false;
  
  const scanBtn = document.getElementById("scanButton");
  const scanInput = document.getElementById("scanHiddenInput");
  const scanStatus = document.getElementById("scanStatusMessage");

  if (scanBtn && scanInput && scanStatus) {
    scanBtn.addEventListener("click", function () {
      // If modal is open, focus modal input and show please scan in modal
      const modal = document.getElementById("trayScanModal_DayPlanning");
      if (modal && modal.style.display === "block") {
        const pleaseScanIndicator = document.getElementById("pleaseScanIndicator");
        if (pleaseScanIndicator) pleaseScanIndicator.style.display = "inline";
        const validateInput = document.getElementById("trayValidateInput");
        if (validateInput) validateInput.focus();
        console.log("PLEASE SCAN (modal)");
      } else {
        // Normal scanning
        scanInput.focus();
        scanStatus.textContent = "PLEASE SCAN";
        scanStatus.style.display = "inline-block";
        console.log("PLEASE SCAN");
      }

      // If modal is open, also trigger trayValidateBtn actions
      if (modal && modal.style.display === "block") {
        setTimeout(() => {
          const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
          if (topTrayRow) {
            const editIcon = topTrayRow.querySelector('.edit-tray-qty');
            if (editIcon) editIcon.style.display = 'inline-block';
          }
          const redoBtn = document.getElementById("trayQtyRedoBtn");
          if (redoBtn) redoBtn.style.display = 'inline-block';
        }, 100);
      }
    });

    scanInput.addEventListener("keydown", function (e) {
      if (e.key !== "Enter") return; // Only validate on Enter

      const trayId = scanInput.value.trim();

      // Wait until user enters at least 8 characters before validating
      if (trayId.length < 8) {
        scanStatus.style.display = "inline-block";
        scanStatus.style.color = "#28a745";
        scanStatus.textContent = "PLEASE SCAN";
        return;
      }

      fetch(`/inputscreening/get_lot_id_for_tray/?tray_id=${encodeURIComponent(trayId)}`)
        .then(res => res.json())
        .then(data => {
          if (data.success && data.lot_id) {
            console.log("Scanned Tray ID:", trayId, "Lot ID:", data.lot_id);

            // Find the row with this lot_id and trigger the View button
            const row = document.querySelector(`tr[data-stock-lot-id="${data.lot_id}"]`);
            if (row) {
              // ✅ NEW: Check if Accept/Reject buttons are enabled on this row
              const acceptBtn = row.querySelector('.btn-twitter');
              const rejectBtn = row.querySelector('.btn-youtube.tray-scan-btn');
              const hasAcceptRejectButtons = acceptBtn && rejectBtn && 
                                           !acceptBtn.disabled && 
                                           !rejectBtn.disabled;
              
              if (hasAcceptRejectButtons) {
                // For verified trays: close any open modal and highlight the row
                console.log("Verified tray - closing modal and highlighting row");
                
                // ✅ FIXED: Auto-close any open modal when scanning verified tray
                const modal = document.getElementById('trayScanModal');
                const dayPlanningModal = document.getElementById('trayScanModal_DayPlanning');
                
                if (modal && modal.style.display !== 'none') {
                  modal.style.display = 'none';
                  console.log("trayScanModal closed for verified tray scan");
                }
                if (dayPlanningModal && dayPlanningModal.style.display !== 'none') {
                  dayPlanningModal.style.display = 'none';
                  console.log("trayScanModal_DayPlanning closed for verified tray scan");
                }
                
                scanInput.value = "";
                scanStatus.textContent = "PLEASE SCAN";
                
                // Remove highlight from all rows
                document.querySelectorAll('tbody tr').forEach(function(r) {
                  r.classList.remove('dp-row-action-highlight');
                });
                
                // Add highlight to this row and move to top
                row.classList.add('dp-row-action-highlight');
                
                // Move row to top of table
                const tbody = row.parentNode;
                if (tbody && tbody.firstElementChild !== row) {
                  tbody.insertBefore(row, tbody.firstElementChild);
                }
              } else {
                // Original logic: open modal
                const viewBtn = row.querySelector('.tray-scan-btn-DayPlanning-view');
                if (viewBtn) {
                  // ✅ NEW: Set flag to indicate modal is opened from scanner
                  window.isModalOpenedFromScanner = true;
                  
                  viewBtn.click();
                  
                  // ✅ NEW: Auto-fill scanned tray ID and trigger validation after modal opens
                  setTimeout(() => {
                    autoTriggerTrayValidation(trayId);
                  }, 500);
                } else {
                  console.log("View button not found for Lot ID:", data.lot_id);
                }
              }
            } else {
              // ✅ FIX: Row not found on current page - search across all pages
              console.log("Row not found on current page for Lot ID:", data.lot_id);
              
              // Try to find the correct page by searching for the lot_id
              const currentUrl = new URL(window.location);
              const currentPage = currentUrl.searchParams.get('page') || '1';
              
              // If not found, search across pages to locate and highlight
              scanStatus.style.color = "#dc3545";
              scanStatus.textContent = "Lot not found on current page, searching...";
              searchLotIdAcrossPages(data.lot_id, trayId, currentPage);
            }
            
            // Reset scan status if row was found on current page
            if (row) {
              scanStatus.style.color = "#28a745";
              scanStatus.textContent = "PLEASE SCAN";
            }
          } else {
            scanStatus.style.display = "inline-block";
            scanStatus.style.color = "#dc3545";
            scanStatus.textContent = "Invalid Tray ID!";
            scanInput.value = ""; // Automatically clear input
            scanInput.focus();    // Refocus for next scan
            console.log("Tray ID not found or no lot_id returned for:", trayId);
          }
        })
        .catch(() => {
          scanStatus.style.display = "inline-block";
          scanStatus.style.color = "#dc3545";
          scanStatus.textContent = "Network error!";
          scanInput.value = ""; // Automatically clear input
          scanInput.focus();    // Refocus for next scan
          console.log("Network error while fetching lot_id for Tray ID:", trayId);
        });
    });
  }
});

// ✅ NEW: Auto-trigger tray validation function for barcode scanner
function autoTriggerTrayValidation(scannedTrayId) {
  console.log("🔧 Auto-triggering tray validation for:", scannedTrayId);
  
  const validateInput = document.getElementById("trayValidateInput");
  const modal = document.getElementById("trayScanModal_DayPlanning");
  
  if (!validateInput || !modal) {
    console.log("❌ Required elements not found for auto-validation");
    return;
  }
  
  // Check if modal is open and not already quantity verified
  if (modal.style.display !== "block" || modal.isQtyVerified) {
    console.log("❌ Modal not ready for auto-validation");
    return;
  }
  
  // Fill the input with scanned tray ID
  validateInput.value = scannedTrayId;
  validateInput.focus();
  
  // Trigger validation by simulating Enter key press
  const enterEvent = new KeyboardEvent('keydown', {
    key: 'Enter',
    code: 'Enter',
    keyCode: 13,
    which: 13,
    bubbles: true
  });
  
  validateInput.dispatchEvent(enterEvent);
  console.log("✅ Auto-triggered validation for tray ID:", scannedTrayId);
}

// ✅ NEW: Search for lot_id across pages when not found on current page
function searchLotIdAcrossPages(lotId, trayId, currentPage) {
  console.log(`🔍 Searching for Lot ID ${lotId} across pages (current: ${currentPage})`);
  
  // Try to navigate to the page containing the lot_id
  // We'll navigate to different pages and check if the row exists
  const maxPages = 10; // Reasonable limit to prevent infinite searching
  let pageToCheck = 1;
  
  function checkNextPage() {
    if (pageToCheck > maxPages) {
      // Not found in reasonable number of pages
      const scanStatus = document.getElementById("scanStatusMessage");
      const scanInput = document.getElementById("scanHiddenInput");
      if (scanStatus) {
        scanStatus.style.color = "#dc3545";
        scanStatus.textContent = "Tray found but not visible on current pages";
      }
      if (scanInput) {
        scanInput.value = "";
        scanInput.focus();
      }
      return;
    }
    
    if (pageToCheck.toString() === currentPage) {
      // Skip current page (already checked)
      pageToCheck++;
      checkNextPage();
      return;
    }
    
    console.log(`🔍 Checking page ${pageToCheck} for Lot ID ${lotId}`);
    
    // Navigate to the page
    const newUrl = new URL(window.location);
    newUrl.searchParams.set('page', pageToCheck);
    
    // Store scan data for after page load
    sessionStorage.setItem('pendingScanLotId', lotId);
    sessionStorage.setItem('pendingScanTrayId', trayId);
    sessionStorage.setItem('pendingScanOriginalPage', currentPage);
    
    // Navigate to the page
    window.location.href = newUrl.toString();
  }
  
  checkNextPage();
}

// ✅ NEW: Highlight and move row to top when Accept/Reject buttons are enabled
function highlightAndMoveRowToTop(row, lotId) {
  console.log(`🎯 Highlighting and moving row to top for Lot ID: ${lotId}`);
  
  // If there's already a highlighted row, restore it first
  if (window.currentHighlightedRow && window.originalRowPosition) {
    restorePreviousRowPosition();
  }
  
  // Store original position
  const tableBody = row.parentElement;
  const allRows = Array.from(tableBody.children);
  const originalIndex = allRows.indexOf(row);
  
  window.currentHighlightedRow = row;
  window.currentHighlightedLotId = lotId;
  window.originalRowPosition = {
    row: row,
    parent: tableBody,
    nextSibling: row.nextElementSibling,
    index: originalIndex
  };
  
  // ✅ FIXED: Use existing highlighted-tray-scan class instead of custom styling
  row.classList.add('highlighted-tray-scan');
  
  // Move to top of table
  tableBody.insertBefore(row, tableBody.firstChild);
  
  // Scroll to top to make it visible
  const table = tableBody.closest('table');
  if (table) {
    table.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  console.log(`✅ Row highlighted and moved to top for Lot ID: ${lotId}`);
}

// ✅ NEW: Restore previous row to its original position
function restorePreviousRowPosition() {
  if (!window.originalRowPosition) return;
  
  const { row, parent, nextSibling, index } = window.originalRowPosition;
  
  console.log(`🔄 Restoring row to original position for Lot ID: ${window.currentHighlightedLotId}`);
  
  // ✅ FIXED: Remove existing highlighted-tray-scan class instead of custom styles
  row.classList.remove('highlighted-tray-scan');
  
  // Restore to original position
  if (nextSibling) {
    parent.insertBefore(row, nextSibling);
  } else {
    parent.appendChild(row);
  }
  
  // Clear tracking variables
  window.currentHighlightedRow = null;
  window.currentHighlightedLotId = null;
  window.originalRowPosition = null;
  
  console.log(`✅ Row restored to original position`);
}

// ✅ NEW: Check for pending scan after page load
function checkPendingScanAfterPageLoad() {
  const pendingLotId = sessionStorage.getItem('pendingScanLotId');
  const pendingTrayId = sessionStorage.getItem('pendingScanTrayId');
  const originalPage = sessionStorage.getItem('pendingScanOriginalPage');
  
  if (pendingLotId && pendingTrayId) {
    console.log(`🎯 Checking current page for pending scan: Lot ID ${pendingLotId}`);
    
    // Look for the row on current page
    const row = document.querySelector(`tr[data-stock-lot-id="${pendingLotId}"]`);
    if (row) {
      console.log(`✅ Found row for Lot ID ${pendingLotId} on current page`);
      
      // Clear pending scan data
      sessionStorage.removeItem('pendingScanLotId');
      sessionStorage.removeItem('pendingScanTrayId');
      sessionStorage.removeItem('pendingScanOriginalPage');
      
      // ✅ FIXED: Check if Accept/Reject buttons are enabled (verified tray)
      const acceptBtn = row.querySelector('.btn-twitter');
      const rejectBtn = row.querySelector('.btn-youtube.tray-scan-btn');
      const hasAcceptRejectButtons = acceptBtn && rejectBtn && 
                                   !acceptBtn.disabled && 
                                   !rejectBtn.disabled;
      
      if (hasAcceptRejectButtons) {
        // For verified trays: close any open modal and highlight the row
        console.log("Cross-page verified tray - closing modal and highlighting row");
        
        // Auto-close any open modal when scanning verified tray
        const modal = document.getElementById('trayScanModal');
        const dayPlanningModal = document.getElementById('trayScanModal_DayPlanning');
        
        if (modal && modal.style.display !== 'none') {
          modal.style.display = 'none';
          console.log("trayScanModal closed for cross-page verified tray scan");
        }
        if (dayPlanningModal && dayPlanningModal.style.display !== 'none') {
          dayPlanningModal.style.display = 'none';
          console.log("trayScanModal_DayPlanning closed for cross-page verified tray scan");
        }
        
        // Remove highlight from all rows
        document.querySelectorAll('tbody tr').forEach(function(r) {
          r.classList.remove('dp-row-action-highlight');
        });
        
        // Add highlight to this row and move to top
        row.classList.add('dp-row-action-highlight');
        
        // Move row to top of table
        const tbody = row.parentNode;
        if (tbody && tbody.firstElementChild !== row) {
          tbody.insertBefore(row, tbody.firstElementChild);
        }
        
        // Update scan status
        const scanStatus = document.getElementById("scanStatusMessage");
        const scanInput = document.getElementById("scanHiddenInput");
        if (scanStatus) {
          scanStatus.style.color = "#28a745";
          scanStatus.textContent = "PLEASE SCAN";
        }
        if (scanInput) {
          scanInput.value = "";
        }
      } else {
        // Original logic: open modal for non-verified trays
        const viewBtn = row.querySelector('.tray-scan-btn-DayPlanning-view');
        if (viewBtn) {
          window.isModalOpenedFromScanner = true;
          viewBtn.click();
          
          setTimeout(() => {
            autoTriggerTrayValidation(pendingTrayId);
          }, 500);
          
          // Update scan status
          const scanStatus = document.getElementById("scanStatusMessage");
          if (scanStatus) {
            scanStatus.style.color = "#28a745";
            scanStatus.textContent = "PLEASE SCAN";
          }
        }
      }
    } else {
      // Not found on this page either, continue searching
      const currentUrl = new URL(window.location);
      const currentPageNum = parseInt(currentUrl.searchParams.get('page') || '1');
      
      // Continue searching from next page
      searchLotIdAcrossPages(pendingLotId, pendingTrayId, currentPageNum.toString());
    }
  }
}

// Make the function globally available
window.autoTriggerTrayValidation = autoTriggerTrayValidation;
window.searchLotIdAcrossPages = searchLotIdAcrossPages;
window.highlightAndMoveRowToTop = highlightAndMoveRowToTop;
window.restorePreviousRowPosition = restorePreviousRowPosition;
</script>

<!-- Tooltip for Global Remark -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener("DOMContentLoaded", function () {
  let tooltipTimeout = null;
  let lastTrigger = null;
  const tooltip = document.getElementById('global-remark-tooltip');

  // Helper to build tooltip HTML
  function buildTooltip(trigger) {
    const type = trigger.getAttribute('data-tooltip-type');
    let html = '';
    if (type === 'audio') {
      html = `
        <div style="width:265px; background:#fff; border:1px solid #ccc; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); padding:10px;">
          <div style="display:flex; align-items:center; gap:10px;">
            <button type="button" style="background:#28a745; color:#fff; border:none; border-radius:50%; width:40px; height:40px; font-size:20px; display:flex; align-items:center; justify-content:center;">
              <i class="fa fa-microphone"></i>
            </button>
            <span style="font-size:14px; color:#333;">Hold to record audio</span>
            <div style="text-align:right; margin-top:10px;">
              <button type="button" style="background-color:#007bff; color:#fff; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:14px;">
                <i class="fa fa-send"></i>
              </button>
            </div>
          </div>
        </div>
      `;
    } else if (type === 'text') {
      const remark = trigger.getAttribute('data-remark') || '';
      const readonly = trigger.getAttribute('data-remark-readonly') === 'true';
      html = `
        <div style="width:300px; background:#fff; border:1px solid #ccc; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); padding:15px;">
          <textarea placeholder="Type your remark..." style="width:85%; height:40px; resize:vertical; border:1px solid #ccc; padding:5px; border-radius:4px; font-family:Arial,sans-serif; font-size:14px;" ${readonly ? 'readonly' : ''}>${remark}</textarea>
          <div style="text-align:right; margin-top:-35px">
            ${!readonly ? `
              <button type="button" style="background-color:#007bff; color:#fff; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:14px;">
                <i class="fa fa-send"></i>
              </button>
            ` : `
              <div style="margin-top:40px; color:#31708f; background:#d9edf7; border:1px solid #bce8f1; border-radius:4px; padding:8px 12px; font-size:10px; text-align:left;">
                <i class="fa fa-info-circle" style="margin-right:6px;"></i>
                Remark already saved and cannot be edited.
              </div>
            `}
          </div>
        </div>
      `;
    }
    return html;
  }

  // Helper to position tooltip
  function positionTooltip(trigger) {
    const rect = trigger.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    let top = rect.bottom + window.scrollY + 8;
    let left = rect.left + window.scrollX + rect.width / 2 - (tooltipRect.width || 300) / 2;

    // If tooltip would go off the right edge, adjust
    if (left + (tooltipRect.width || 300) > window.innerWidth - 10) {
      left = window.innerWidth - (tooltipRect.width || 300) - 10;
    }
    // If tooltip would go off the left edge, adjust
    if (left < 10) left = 10;

    // If not enough space below, show above
    if (top + (tooltipRect.height || 120) > window.innerHeight - 10) {
      top = rect.top + window.scrollY - (tooltipRect.height || 120) - 8;
    }

    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
  }

  // Show tooltip on hover
  document.querySelectorAll('.remark-tooltip-trigger').forEach(function(trigger) {
    trigger.addEventListener('mouseenter', function(e) {
      clearTimeout(tooltipTimeout);
      tooltip.innerHTML = buildTooltip(trigger);
      tooltip.style.display = 'block';
      tooltip.style.opacity = '1';
      tooltip.style.pointerEvents = 'auto';
      positionTooltip(trigger);
      lastTrigger = trigger;
    });

    trigger.addEventListener('mouseleave', function(e) {
      tooltipTimeout = setTimeout(function() {
        tooltip.style.display = 'none';
        tooltip.style.opacity = '0';
        tooltip.innerHTML = '';
        lastTrigger = null;
      }, 200);
    });
  });

  // Keep tooltip open if mouse enters it
  tooltip.addEventListener('mouseenter', function() {
    clearTimeout(tooltipTimeout);
  });
  tooltip.addEventListener('mouseleave', function() {
    tooltipTimeout = setTimeout(function() {
      tooltip.style.display = 'none';
      tooltip.style.opacity = '0';
      tooltip.innerHTML = '';
      lastTrigger = null;
    }, 200);
  });

  // Hide tooltip on scroll or resize
  window.addEventListener('scroll', function() {
    tooltip.style.display = 'none';
    tooltip.style.opacity = '0';
    tooltip.innerHTML = '';
    lastTrigger = null;
  }, true);
  window.addEventListener('resize', function() {
    tooltip.style.display = 'none';
    tooltip.style.opacity = '0';
    tooltip.innerHTML = '';
    lastTrigger = null;
  });

  // Hide tooltip on click outside
  document.addEventListener('mousedown', function(e) {
    if (tooltip.style.display === 'block' && !tooltip.contains(e.target) && (!lastTrigger || !lastTrigger.contains(e.target))) {
      tooltip.style.display = 'none';
      tooltip.style.opacity = '0';
      tooltip.innerHTML = '';
      lastTrigger = null;
    }
  });
});
</script>

<!-- Place this after your tray scan modal logic and after buildTableHTML is defined and used -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {


  // ✅ FIX: Instantly focus input and show "Please Scan" when Scan button is clicked in DayPlanning modal
  const scanBtnDayPlanning = document.getElementById("trayValidateBtn");
  const scanInputDayPlanning = document.getElementById("trayValidateInput");
  const pleaseScanIndicator = document.getElementById("pleaseScanIndicator");
  const trayScanModalDayPlanning = document.getElementById("trayScanModal_DayPlanning");

  
  if (scanBtnDayPlanning && scanInputDayPlanning && trayScanModalDayPlanning) {
    scanBtnDayPlanning.addEventListener("click", function () {
      // Show "Please Scan" message
      if (pleaseScanIndicator) {
        pleaseScanIndicator.style.display = "inline-block";
        pleaseScanIndicator.textContent = "PLEASE SCAN";
      }
      // Focus the input for instant scanning
      scanInputDayPlanning.focus();
      scanInputDayPlanning.select && scanInputDayPlanning.select();
    });
  
    // Also, when the modal opens, auto-focus and show "Please Scan" if not verified
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (trayScanModalDayPlanning.style.display === "block" && !trayScanModalDayPlanning.isQtyVerified) {
          if (pleaseScanIndicator) {
            pleaseScanIndicator.style.display = "inline-block";
            pleaseScanIndicator.textContent = "PLEASE SCAN";
          }
          scanInputDayPlanning.focus();
          scanInputDayPlanning.select && scanInputDayPlanning.select();
        }
      });
    });
    observer.observe(trayScanModalDayPlanning, { attributes: true, attributeFilter: ['style'] });
  }
  


     // Show Edit icon after Tray Validate is clicked
     const validateBtn = document.getElementById("trayValidateBtn");
     const redoBtn = document.getElementById("trayQtyRedoBtn");
     const modal = document.getElementById("trayScanModal_DayPlanning");
     const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
   
     
     if (validateBtn) {
       validateBtn.addEventListener("click", function () {
         setTimeout(() => {
           const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
           if (topTrayRow) {
             const editIcon = topTrayRow.querySelector('.edit-tray-qty');
             if (editIcon) editIcon.style.display = 'inline-block';
           }
           if (redoBtn) redoBtn.style.display = 'inline-block';
         }, 100);
       });
     }
   
   
   
     // Redo icon click: reset qty, disable editing, disable Tray Validate
     if (redoBtn) {
       redoBtn.addEventListener('click', function () {
         const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
         if (topTrayRow) {
           const qtyInput = topTrayRow.querySelector('.tray-qty-input[data-top-tray="1"]');
           if (qtyInput) {
             qtyInput.value = qtyInput.getAttribute('data-initial');
             qtyInput.setAttribute('readonly', true);
           }


           // Hide Tray Validation Status column by rebuilding table without it
         if (modal && detailsDiv && modal.buildTableHTML) {
           detailsDiv.innerHTML = modal.buildTableHTML(false);
         }
          // ✅ Remove draft/cancel buttons and info message
         if (window.removeDraftCancelButtons) {
           window.removeDraftCancelButtons();
         }
         }
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
         if (redoBtn) redoBtn.style.display = 'none';

         // NEW: Reset tray verification
         const lotId = modal.dataset.lotId;
         if (lotId) {
           function getCookie(name) {
             let cookieValue = null;
             if (document.cookie && document.cookie !== '') {
               const cookies = document.cookie.split(';');
               for (let i = 0; i < cookies.length; i++) {
                 const cookie = cookies[i].trim();
                 if (cookie.substring(0, name.length + 1) === (name + '=')) {
                   cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                   break;
                 }
               }
             }
             return cookieValue;
           }
           fetch('/inputscreening/reset_tray_verification_for_lot/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify({ lot_id: lotId })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               // Update UI to show not verified
               const rows = detailsDiv.querySelectorAll('tbody tr');
               rows.forEach(row => {
                 const input = row.querySelector('input[type="text"]');
                 if (input) {
                   input.style.backgroundColor = '#fff3cd';
                   input.style.borderColor = '#ffc107';
                   input.style.color = '#856404';
                 }
                 const indicator = row.querySelector('small');
                 if (indicator) {
                   indicator.textContent = '⏳ Not Verified';
                   indicator.style.color = '#856404';
                 }
               });
             } else {
               alert('Failed to reset tray verification: ' + data.error);
             }
           });
         }
       });
     }
   
     // When qty is changed, re-enable Tray Validate
     document.addEventListener('input', function (e) {
       if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
         const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
         let currentQty = parseInt(e.target.value, 10) || 0;
         // Prevent increasing above original
         if (currentQty > originalQty) {
           e.target.value = originalQty;
         }
         // Prevent going below zero
         if (currentQty < 0) {
           e.target.value = 0;
         }
         // Enable Tray Validate as before
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
         }
       }
     });
   
       document.addEventListener('click', function (e) {
       if (e.target.closest('.edit-tray-qty')) {
         const row = e.target.closest('tr');
         const qtyInput = row.querySelector('.tray-qty-input[data-top-tray="1"]');
         if (qtyInput) {
           qtyInput.removeAttribute('readonly');
           qtyInput.focus();
     
           // Add blur handler to return focus to validate input after editing
           qtyInput.addEventListener('blur', function handleBlur() {
             setTimeout(() => {
               // Only refocus if not clicking Edit icon again
               const active = document.activeElement;
               if (!active || !active.classList.contains('edit-tray-qty')) {
                 const validateInput = document.getElementById("trayValidateInput");
                 if (validateInput) validateInput.focus();
               }
             }, 100);
             // Remove this handler after it runs once
             qtyInput.removeEventListener('blur', handleBlur);
           });
         }
       }
     });
   
     
   });
</script>

<!-- ✅ SCRIPT 1: Save IP Checkbox -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     // ✅ HELPER FUNCTION: Get edited tray qty from modal
     function getEditedTrayQtyFromModal() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (!modal) {
         return null;
       }
       
       // Find the top tray input
       const editedTrayQtyInput = modal.querySelector('.tray-qty-input[data-top-tray="1"]');
       if (!editedTrayQtyInput) {
         return null;
       }
       
       const currentValue = editedTrayQtyInput.value.trim();
       const initialValue = editedTrayQtyInput.getAttribute('data-initial') || '';
       
   
       
       // Return current value regardless of whether it changed
       return currentValue || null;
     }
   
     // ✅ HELPER FUNCTION: Get CSRF token
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   
     // ✅ SAVE IP CHECKBOX HANDLER
     document.addEventListener('click', function(e) {
       if (e.target.classList.contains('save-ip-checkbox')) {
         const element = e.target;
         const row = element.closest('tr');
         
         let lotId = element.getAttribute('data-lot-id');
         if (!lotId) lotId = row.getAttribute('data-stock-lot-id');
         
         if (!lotId) {
           Swal.fire('Error', 'Lot ID not found', 'error');
           return;
         }
         
         // Get the calculated missing qty from the input
         const missingQtyInput = row.querySelector('.missing-qty-input');
         const missingQty = missingQtyInput ? missingQtyInput.value.trim() : '0';
         
         // ✅ FIXED: Get edited tray qty using helper function
         const editedTrayQty = getEditedTrayQtyFromModal();
         
   
         // Change icon to indicate processing
         if (element.tagName === 'I') {
           element.className = 'fa fa-spinner fa-spin';
         }
         
         // Disable element during processing
         element.style.pointerEvents = 'none';
         
         fetch('/inputscreening/save_ip_checkbox/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({
             lot_id: lotId,
             missing_qty: missingQty || '0',
             edited_tray_qty: editedTrayQty
           })
         })
         .then(res => res.json())
         .then(data => {
           if (data.success) {
             // Change to checked state
             if (element.tagName === 'I') {
               element.className = 'fa fa-check-square';
               element.style.color = '#28a745';
             }
             
             element.title = 'IP Checkbox saved';
             
             Swal.fire({
               icon: 'success',
               title: 'Saved successfully!',
               timer: 2000,
               showConfirmButton: false
             });
             
             // Update row to show verification completed
             updateRowAfterIPSave(row, lotId, missingQty);
             
             // Reload page after a short delay
             setTimeout(() => {
               window.location.reload();
             }, 1500);
             
           } else {
             Swal.fire('Error', data.error || 'Save failed', 'error');
             // Reset icon and enable element
             if (element.tagName === 'I') {
               element.className = 'fa fa-square-o';
             }
             element.style.pointerEvents = 'auto';
           }
         })
         .catch(error => {
           Swal.fire('Error', 'Network error', 'error');
           // Reset icon and enable element
           if (element.tagName === 'I') {
             element.className = 'fa fa-square-o';
           }
           element.style.pointerEvents = 'auto';
         });
       }
     });
   
     // ✅ HELPER FUNCTION: Update row after IP save
     function updateRowAfterIPSave(row, lotId, missingQty) {
       // Update main IP checkbox
       const mainIpCheckbox = row.querySelector('.ip-checkbox');
       if (mainIpCheckbox) {
         mainIpCheckbox.checked = true;
         mainIpCheckbox.disabled = true;
       }
       
       // Update missing qty input
       const missingQtyInput = row.querySelector('.missing-qty-input');
       if (missingQtyInput) {
         missingQtyInput.disabled = true;
       }
       
       // Update physical qty
       const physicalQtyInput = row.querySelector('.physical-qty-input');
       const lotQtySpan = row.querySelector('.lot-qty');
       if (physicalQtyInput && lotQtySpan && missingQty) {
         const totalQty = parseInt(lotQtySpan.textContent.trim(), 10);
         const newPhysicalQty = totalQty - parseInt(missingQty);
         physicalQtyInput.value = newPhysicalQty;
       }
       
       // Update process status Q icon
       const processIcons = row.querySelectorAll('.d-flex > div');
       if (processIcons.length > 0) {
         processIcons[0].style.backgroundColor = '#0c8249';
       }
     }
   
     // ✅ Make helper functions available globally
     window.getEditedTrayQtyFromModal = getEditedTrayQtyFromModal;
     window.getCookie = getCookie;
   });
</script>

<!--✅ SCRIPT 2: Modal Opening and Table Building-->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach(function(link) {
       link.addEventListener('click', async function (e) {
         e.preventDefault();
         
         // ✅ FIXED: Use existing row highlighting system - the handleRowHighlight already manages restoration
         // No need for custom restoration as existing system handles it
   
         // Get modal elements
         const modal = document.getElementById("trayScanModal_DayPlanning");
         const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
         const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
         const modalLotQty = document.getElementById("modalLotQty_DayPlanning"); // ✅ NEW
         modal.dataset.batchId = link.getAttribute('data-batch-id');
   
         // ✅ FIXED: Get total batch quantity and USE it
         const totalBatchQuantity = link.getAttribute('data-total-batch-quantity') || "0";
         
         // Get data attributes
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         modal.dataset.lotId = stockLotId;
         const modelNo = link.getAttribute('data-model-no');
         const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
         const trayCapacity = link.getAttribute('data-tray-capacity') || "";
         const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';
         
         let trayQtyList = [];
         try {
           trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
         } catch (e) {
           trayQtyList = [];
         }
   
         // Set model number in modal
         if (modalModelNo && modelNo) {
           modalModelNo.textContent = modelNo;
         }
         
         // ✅ FIXED: Actually SET the lot quantity in modal
         if (modalLotQty) {
           modalLotQty.textContent = totalBatchQuantity;
           console.log("✅ Set Lot Qty to:", totalBatchQuantity);
         } else {
           console.log("❌ modalLotQty element not found!");
         }
   
         // Rest of your existing code...
         // Set model image, validation buttons, etc.
         // Set model image
         const modalUserImg = modal.querySelector('.user-profile img');
         const modelImage = link.getAttribute('data-model-image');
         if (modalUserImg) {
           if (modelImage) {
             modalUserImg.src = modelImage;
           } else {
             modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
           }
         }

// --- Tray Type Identification ---
const row = link.closest('tr');  // Get the table row for tray type data
// const trayTypeCell = row.querySelector('td:nth-child(9)');
const trayTypeCell = row.cells && row.cells[7] ? row.cells[7] : row.querySelector('td:nth-child(8)');
const trayType = trayTypeCell ? trayTypeCell.textContent.trim() : 'N/A';

let trayTypeDiv = modal.querySelector('#modalTrayType');
if (!trayTypeDiv) {
  trayTypeDiv = document.createElement('div');
  trayTypeDiv.id = 'modalTrayType';
  trayTypeDiv.style.fontWeight = '600';
  trayTypeDiv.style.color = '#222';
  trayTypeDiv.style.fontSize = '17px';  // ✅ Match font size of Model No/Input Qty for consistency
  modal.querySelector('.modal-top-header').appendChild(trayTypeDiv);
}

// ✅ NEW: Make modal header display in a straight line (horizontal flex)
const modalTopHeader = modal.querySelector('.modal-top-header');
if (modalTopHeader) {
  modalTopHeader.style.display = 'flex';
  modalTopHeader.style.alignItems = 'center';
  modalTopHeader.style.gap = '20px';
  modalTopHeader.style.flexWrap = 'wrap';  // Allow wrapping on small screens
}

// ✅ FIXED: Parse tray type accurately (e.g., "Normal-12" → "Normal - 12")
(function(){
  const trayTypeParts = trayType.split('-');
  const trayTypeName = trayTypeParts[0]?.trim() || 'N/A';
  // ✅ ENHANCED: Use proper defaults based on tray type (Normal=16, Jumbo=12)
  let defaultCapacity = 16; // Default to Normal capacity
  if (trayTypeName.toLowerCase().includes('jumbo')) {
    defaultCapacity = 12;
  }
  const trayCapacity = trayTypeParts[1] ? parseInt(trayTypeParts[1]) : defaultCapacity;  // Use dynamic default

  trayTypeDiv.innerHTML = `
    <span style="display: flex; align-items: center; gap: 8px;">
      <button type="button"
              style="
                display: flex;
                align-items: center;
                gap: 6px;
                border: 1px solid #28a745;
                background: #f7fff7;
                color: #5e5959;
                font-weight: 600;
                font-size: 12px;
                border-radius: 20px;
                padding: 5px;
                box-shadow: 0 1px 4px rgba(40,167,69,0.08);
                cursor: default;
              "
              disabled
      >
        ${trayTypeName} - ${trayCapacity}
      </button>
    </span>
  `;
})();
         
   
         // Show/Hide validation buttons based on verification status
         const trayValidateSection = document.getElementById("trayValidateSection");
         const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");
   
         if (isQtyVerified) {
           if (trayValidateSection) trayValidateSection.style.display = "none";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
         } else {
           if (trayValidateSection) trayValidateSection.style.display = "flex";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
         }
   
         // Fetch tray data with proper top tray handling using API
         let traysData = [];
         try {
           const resp = await fetch(`/inputscreening/ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
           const result = await resp.json();
           if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
             traysData = result.trays;
           }
         } catch (e) {
         }
   
         // Fetch existing verification status
         let verificationData = {};
         try {
           const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
           const verifyResult = await verifyResp.json();
           if (verifyResult.success) {
             verificationData = verifyResult.verification_data;
             console.log('✅ [Tray Scan Modal] Fetched verification data for lot ' + stockLotId + ':', verificationData);
           } else {
             console.log('⚠️ [Tray Scan Modal] No verification data found for lot ' + stockLotId);
           }
         } catch (e) {
           console.error('❌ [Tray Scan Modal] Error fetching verification status:', e);
         }
   
         // ✅ TABLE BUILDING FUNCTION
         function buildTableHTML(showValidationColumn = false) {
           let html = `
             <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
               <thead>
                 <tr>
                   <th style="width:50px;">S.no</th>
                   <th>Tray ID</th>
                   <th>Tray Qty</th>
                 </tr>
               </thead>
               <tbody>
           `;
           
           // If we have trays data from API, use it directly
           if (traysData && traysData.length > 0) {
             traysData.forEach((tray, index) => {
               const isTopTray = tray.is_top_tray || index === 0;
               const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
               const position = index + 1;
   
               // Check verification status
               const verification = this.verificationData[position];
               const isVerifiedByUser = verification ? verification.is_verified : false;
               const isVerifiedInDB = tray.IP_tray_verified || false;
               const isVerified = isVerifiedByUser || isVerifiedInDB;
               
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
   
               // Set input properties based on verification status
               let inputValue, inputStyle, verificationIndicator;
   
               if (isVerified) {
                 inputValue = verifiedTrayId || tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
   
               html += `
                 <tr>
                   <td>${displaySNo}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td style="position:relative; white-space:nowrap;">
                     <span style="display:inline-flex; align-items:center;">
                       <input type="number" 
                              class="form-control tray-qty-input" 
                              value="${tray.tray_quantity || ''}" 
                              readonly 
                              style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                              data-initial="${tray.tray_quantity || ''}"
                              ${isTopTray ? 'data-top-tray="1"' : ''} 
                       />
                      
                     </span>
                   </td>
                 </tr>
               `;
             });
           } else {
             // Fallback: Use the old method if API data is not available
             let totalRows = noOfTrays;
             for (let i = 0; i < totalRows; i++) {
               const position = i + 1;
               const verification = this.verificationData[position];
               const isVerified = verification ? verification.is_verified : false;
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
               const trayQty = trayQtyList[i] || trayCapacity;
               
               let inputValue, inputStyle, verificationIndicator;
               
               if (isVerified) {
                 inputValue = verifiedTrayId;
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
               
               html += `
                 <tr>
                   <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td>
                     <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                   </td>
                 </tr>
               `;
             }
           }
           
           html += `
               </tbody>
             </table>
           `;
           return html;
         }
   
   
   
         // Store data in modal for later use
         modal.buildTableHTML = buildTableHTML;
         modal.traysData = traysData;
         modal.verificationData = verificationData;
         modal.noOfTrays = noOfTrays;
         modal.trayQtyList = trayQtyList;
         modal.trayCapacity = trayCapacity;
         modal.isQtyVerified = isQtyVerified;
         modal.stockLotId = stockLotId;
   
         // Initially show table
         detailsDiv.innerHTML = modal.buildTableHTML(false);
   
         // Show the modal
         if (modal) modal.style.display = "block";
         modal.classList.add("open");

         // ✅ Enable redo button when modal opens
         const redoBtn = document.getElementById("trayQtyRedoBtn");
         if (redoBtn) redoBtn.style.display = 'inline-block';

         // ✅ Enable edit icon for top tray when modal opens
         const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
         if (topTrayRow) {
           const editIcon = topTrayRow.querySelector('.edit-tray-qty');
           if (editIcon) editIcon.style.display = 'inline-block';
         }

         // ✅ NEW: Auto-trigger Tray Validate functionality when modal opens  
         setTimeout(() => {
           if (!modal.isQtyVerified) {
             checkVerificationStatusAndShowButtons();
             
             // ✅ Auto-focus on Tray Validate input field for immediate scanner usage
             const validateInput = document.getElementById("trayValidateInput");
             if (validateInput) {
               validateInput.focus();
               console.log("✅ Auto-focused on Tray Validate input for scanner");
               
               // ✅ NEW: Auto-trigger table with validation column when modal opened via scanner
               if (window.isModalOpenedFromScanner) {
                 console.log("🔧 Modal opened from scanner - auto-showing validation table");
                 detailsDiv.innerHTML = buildTableHTML(true); // Show validation column
                 window.isModalOpenedFromScanner = false; // Reset flag
               }
             }
             
             // ✅ Check capacity violations when modal opens
             setTimeout(() => {
               const capacityViolation = validateAllTrayCapacities();
               if (capacityViolation) {
                 console.log('❌ Capacity violation detected on modal open:', capacityViolation);
                 showErrorMessage(capacityViolation);
               }
             }, 1000); // Wait for modal to fully load
           } else {
             removeDraftCancelButtons();
           }
         }, 200);
       });
     });
   
     // ✅ HELPER FUNCTIONS for modal operations
     function getCurrentBatchId() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal && modal.dataset.batchId) return modal.dataset.batchId;
       const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-batch-id]');
       return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
     }
   
     function getCurrentLotId() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal && modal.stockLotId) return modal.stockLotId;
       const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-stock-lot-id]');
       return lastBtn ? lastBtn.getAttribute('data-stock-lot-id') : '';
     }
   
     // ✅ Make helper functions available globally
     window.getCurrentBatchId = getCurrentBatchId;
     window.getCurrentLotId = getCurrentLotId;
   });
   
   
</script>

<!-- ✅ SCRIPT 3: Enhanced Tray Validation with Popup Error Handling -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     function showError(message) {
       const errorMessage = document.getElementById("trayErrorMessage");
       const errorText = document.getElementById("trayErrorText");
       if (errorMessage && errorText) {
         errorText.textContent = message;
         
         // Enhanced styling for better visibility
         errorMessage.style.setProperty('display', 'block', 'important');
         errorMessage.style.setProperty('visibility', 'visible', 'important');
         errorMessage.style.setProperty('opacity', '1', 'important');
         errorMessage.style.setProperty('z-index', '99999', 'important');
         errorMessage.style.setProperty('position', 'relative', 'important');
         errorMessage.style.setProperty('background-color', '#ffebee', 'important');
         errorMessage.style.setProperty('border', '1px solid #f44336', 'important');
         errorMessage.style.setProperty('color', '#c62828', 'important');
         errorMessage.style.setProperty('padding', '8px 12px', 'important');
         errorMessage.style.setProperty('border-radius', '4px', 'important');
         errorMessage.style.setProperty('margin-bottom', '10px', 'important');
         errorMessage.style.setProperty('font-size', '12px', 'important');
         errorMessage.style.setProperty('text-align', 'center', 'important');
         errorMessage.style.setProperty('width', '100%', 'important');
         
         // Scroll to error message
         errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
         
         // Flash effect for better visibility
         let flashCount = 0;
         const flashInterval = setInterval(() => {
           if (flashCount < 6) {
             errorMessage.style.backgroundColor = flashCount % 2 === 0 ? '#ffcdd2' : '#ffebee';
             flashCount++;
           } else {
             clearInterval(flashInterval);
             errorMessage.style.backgroundColor = '#ffebee';
           }
         }, 200);
         
         // Auto-hide after 8 seconds
         setTimeout(() => {
           errorMessage.style.display = "none";
         }, 8000);
       } else {
         // Fallback to alert if error elements not found
         alert(message);
       }
     }
     
     function hideError() {
       const errorMessage = document.getElementById("trayErrorMessage");
       if (errorMessage) {
         errorMessage.style.display = "none";
       }
     }
     
     // ✅ ENHANCED: Tray validation with better error handling and automatic input clearing
     const validateInput = document.getElementById("trayValidateInput");
     const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
     
     if (validateInput && detailsDiv) {
       validateInput.addEventListener("keydown", function (e) {
         if (e.key === "Enter") {
           const trayId = validateInput.value.trim();
           if (!trayId) return;
   
           // Check if this tray ID is already verified
           const alreadyVerified = Array.from(detailsDiv.querySelectorAll("tbody tr")).some(row => {
             const input = row.querySelector('input[type="text"]');
             const verificationIndicator = row.querySelector('small');
             
             return input && 
                    input.value.trim() === trayId && 
                    verificationIndicator && 
                    verificationIndicator.textContent.includes('✓ Verified');
           });
   
           if (alreadyVerified) {
             showError(`Tray ID "${trayId}" is already verified. Cannot scan again.`);
             // ✅ ENHANCED: Auto-clear input and refocus
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           const batchId = window.getCurrentBatchId();
           const lotId = window.getCurrentLotId();
           if (!batchId || !lotId) {
             showError('Batch ID or Lot ID not found. Please try again.');
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           hideError();
   
                      // Find the row where trayId matches and is not yet verified
           const rows = detailsDiv.querySelectorAll("tbody tr");
           let targetRow = null;
           let position = null;

           rows.forEach((row, index) => {
             if (!targetRow) {
               const trayIdInput = row.querySelector('input[type="text"]');
               const verificationIndicator = row.querySelector('small');

               if (
                 trayIdInput &&
                 trayIdInput.value.trim() === trayId &&
                 verificationIndicator &&
                 !verificationIndicator.textContent.includes('✓ Verified')
               ) {
                 targetRow = row;
                 position = parseInt(trayIdInput.getAttribute('data-position')) || (index + 1);
               }
             }
           });

          // FOCUS FIX: Ensure the matched "⏳ Not Verified" row is visible & centered in the modal viewport
          if (targetRow) {
            try {
              const container = document.getElementById('trayScanDetails_DayPlanning');
              if (container) {
                const containerRect = container.getBoundingClientRect();
                const rowRect = targetRow.getBoundingClientRect();
                const offsetTop = (rowRect.top - containerRect.top) + container.scrollTop - (container.clientHeight / 2) + (rowRect.height / 2);
                container.scrollTo({ top: Math.max(0, Math.round(offsetTop)), behavior: 'smooth' });
              } else {
                // Fallback if container not found
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }
            } catch (e) {
              console.warn('Scroll-to-row failed', e);
            }
          }

           if (!targetRow) {
             showError(`Tray ID "${trayId}" is not expected in this position or already verified.`);
             // ✅ ENHANCED: Auto-clear input and refocus
             setTimeout(() => {
               validateInput.value = "";
               validateInput.focus();
             }, 100);
             return;
           }
   
           // ✅ ENHANCED: Show loading state
           validateInput.disabled = true;
           validateInput.style.background = '#f0f0f0';
   
           // Send validation request
           fetch("/inputscreening/ip_tray_validate/", {
             method: "POST",
             headers: {
               "Content-Type": "application/json",
               "X-CSRFToken": window.getCookie('csrftoken')
             },
             body: JSON.stringify({
               batch_id: batchId,
               tray_id: trayId,
               tray_position: position,
               lot_id: lotId
             })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               const trayIdInput = targetRow.querySelector('input[type="text"]');
               
               // Fill the tray ID and make it readonly
               if (trayIdInput) {
                 trayIdInput.value = trayId;
                 trayIdInput.setAttribute('readonly', true);
                 trayIdInput.style.backgroundColor = '#f5f5f5';
                 trayIdInput.style.borderColor = data.exists ? '#28a745' : '#dc3545';
                 trayIdInput.style.color = data.exists ? '#155724' : '#721c24';

                 // Update verification indicator text
                 const existingIndicator = trayIdInput.parentElement.querySelector('small');
                 if (existingIndicator) {
                   existingIndicator.style.color = data.exists ? '#28a745' : '#dc3545';
                   existingIndicator.style.fontWeight = 'bold';
                   existingIndicator.textContent = data.exists ? '✓ Verified' : '✗ Failed';
                 }
               }

               // ✅ ENHANCED: Show success/failure message based on validation result
               if (!data.exists) {
                 showError(data.error || `Tray ID "${trayId}" validation failed.`);
               } else {
                 // ✅ NEW: Hide "Please Scan" indicator after successful validation
                 const pleaseScanIndicator = document.getElementById("pleaseScanIndicator");
                 if (pleaseScanIndicator) {
                   pleaseScanIndicator.style.display = "none";
                 }
               }
             } else {
               // ✅ ENHANCED: Show detailed error message from server
               showError(data.error || 'An error occurred while validating the tray ID.');
             }
           })
           .catch(error => {
             console.error('Validation error:', error);
             showError('Network error occurred while validating the tray ID. Please try again.');
           })
           .finally(() => {
             // ✅ ENHANCED: Always restore input state and clear for next scan
             validateInput.disabled = false;
             validateInput.style.background = '';
             validateInput.value = "";
             validateInput.focus();
   
             // Check verification status after each scan
             setTimeout(() => {
               checkVerificationStatusAndShowButtons();
             }, 100);
           });
         }
       });
     }
     
     // ✅ CHECK VERIFICATION STATUS AND SHOW BUTTONS (existing function - no changes needed)
     function checkVerificationStatusAndShowButtons() {
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       const rows = detailsDiv.querySelectorAll("tbody tr");
       if (rows.length === 0) {
         return;
       }
   
       // Check if quantity is already verified
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const isQtyAlreadyVerified = modal && modal.isQtyVerified;
       
       if (isQtyAlreadyVerified) {
         removeDraftCancelButtons();
         return;
       }
   
       let totalTrays = 0;
       let verifiedTrays = 0;
       let unverifiedTrays = 0;
       let filledTrays = 0;
   
       rows.forEach((row, index) => {
         const trayIdInput = row.querySelector('input[type="text"]');
         
         if (trayIdInput) {
           totalTrays++;
           const trayId = trayIdInput.value.trim();
           
           if (trayId) {
             filledTrays++;
             
             // Check multiple ways to determine if row is verified
             let isVerified = false;
             
             // Method 1: Check for verification indicator (✓ Verified text)
             const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
             if (hasVerificationIndicator && hasVerificationIndicator.textContent.includes('✓')) {
               isVerified = true;
             }
             
             // Method 2: Check for validation status icons
             if (!isVerified) {
               const statusCell = row.querySelector("td:last-child");
               const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
               if (hasPassIcon) {
                 isVerified = true;
               }
             }
             
             // Method 3: Check if tray ID input is readonly and has value
             if (!isVerified && trayIdInput.hasAttribute('readonly') && trayIdInput.value.trim()) {
               const inputStyle = trayIdInput.style.backgroundColor;
               if (inputStyle.includes('#f5f5f5')) {
                 isVerified = true;
               }
             }
             
             // Add to appropriate counter
             if (isVerified) {
               verifiedTrays++;
             } else {
               unverifiedTrays++;
             }
           }
         }
       });
   
       // Show buttons logic
       if (totalTrays > 0) {
         if (verifiedTrays === totalTrays && filledTrays > 0) {
           removeDraftCancelButtons();
           autoTriggerCheckboxSave();
         } else if (verifiedTrays > 0 && unverifiedTrays > 0 && !draftButtonsShown) {
           showDraftCancelButtons();
         } else if (filledTrays === 0) {
           removeDraftCancelButtons();
         }
       }
     }
     
     // ✅ Make function available globally
     window.checkVerificationStatusAndShowButtons = checkVerificationStatusAndShowButtons;
   });
</script>

<!-- ✅ NEW SCRIPT: Auto-Save Rejection Drafts -->
<script nonce="{{ csp_nonce }}">

// ✅ AGGRESSIVE: Global auto-save function that works from anywhere
window.triggerAutoSave = function() {
  console.log('🔄 [triggerAutoSave] Looking for modal data...');
  
  // ✅ NEW: Set auto-save active flag and show indicator
  window.isAutoSaveActive = true;
  showAutoSaveIndicator();
  
  const trayScanModal = document.getElementById("trayScanModal");
  if (trayScanModal) {
    const stockLotId = trayScanModal.dataset.stockLotId;
    const batchId = trayScanModal.dataset.batchId;
    
    if (stockLotId && batchId) {
      console.log('🔄 [triggerAutoSave] Found modal data, saving...', {stockLotId, batchId});
      if (typeof autoSaveRejectionDraft === 'function') {
        autoSaveRejectionDraft(stockLotId, batchId).catch(error => {
          console.log('⚠️ Global auto-save failed:', error);
        });
      } else if (typeof window.autoSaveRejectionDraft === 'function') {
        window.autoSaveRejectionDraft(stockLotId, batchId).catch(error => {
          console.log('⚠️ Global auto-save failed:', error);
        });
      } else {
        console.log('❌ autoSaveRejectionDraft function not found');
      }
    } else {
      console.log('⚠️ No modal data found for auto-save');
    }
  } else {
    console.log('⚠️ Modal not found for auto-save');
  }
};

// ✅ Set up global input monitoring once DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  // Monitor ALL input changes in the modal
  document.addEventListener('input', function(event) {
    if (event.target.closest('#trayScanModal')) {
      clearTimeout(window.globalAutoSaveTimeout);
      window.globalAutoSaveTimeout = setTimeout(() => {
        console.log('🔄 [globalInputMonitor] Input detected, triggering auto-save');
        window.triggerAutoSave();
      }, 2000);
    }
  });
  
  // Monitor ALL change events in the modal
  document.addEventListener('change', function(event) {
    if (event.target.closest('#trayScanModal')) {
      console.log('🔄 [globalChangeMonitor] Change detected, triggering auto-save');
      window.triggerAutoSave();
    }
  });
  
  // ✅ SAFETY NET: Periodic auto-save every 10 seconds when modal is open
  setInterval(function() {
    const trayScanModal = document.getElementById("trayScanModal");
    if (trayScanModal && trayScanModal.classList.contains("open") && !window.isDraftMode) {
      console.log('🔄 [periodicAutoSave] Running periodic auto-save');
      window.triggerAutoSave();
    }
  }, 10000);
});

// ✅ NEW: Auto-save rejection draft function
function autoSaveRejectionDraft(stockLotId, batchId) {
  console.log('🔄 [autoSaveRejectionDraft] Starting auto-save for lot:', stockLotId);
  
  // Collect current form data
  const formData = collectFormData(stockLotId, batchId);
  
  console.log('🔄 [autoSaveRejectionDraft] Collected form data:', {
    rejection_data_count: formData.rejection_data.length,
    tray_scans_count: formData.tray_scans.length,
    is_batch_rejection: formData.is_batch_rejection,
    lot_rejection_remarks: formData.lot_rejection_remarks,
    total_rejection_qty: formData.total_rejection_qty
  });
  
  // Only save if there's actual data
  if (!formData.rejection_data.length && !formData.lot_rejection_remarks.trim()) {
    console.log('🔄 [autoSaveRejectionDraft] No data to save, skipping');
    return Promise.resolve();
  }
  
  // Send to draft save API
  return fetch('/inputscreening/save_rejection_draft/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      rejection_data: formData.rejection_data,
      tray_scans: formData.tray_scans,
      is_batch_rejection: formData.is_batch_rejection,
      lot_rejection_remarks: formData.lot_rejection_remarks,
      is_auto_save: true  // ✅ CRITICAL FIX: Mark as auto-save to prevent manual draft alert
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      console.log('✅ [autoSaveRejectionDraft] Draft saved successfully');
      return data;
    } else {
      console.error('❌ [autoSaveRejectionDraft] Failed to save draft:', data.error);
      throw new Error(data.error);
    }
  })
  .catch(error => {
    console.error('❌ [autoSaveRejectionDraft] Error saving draft:', error);
    throw error;
  });
}

// ✅ Make function globally accessible
window.autoSaveRejectionDraft = autoSaveRejectionDraft;

// ✅ NEW: Auto-save indicator function
function showAutoSaveIndicator() {
  // Remove existing indicator
  const existingIndicator = document.getElementById('auto-save-indicator');
  if (existingIndicator) {
    existingIndicator.remove();
  }
  
  // Create new indicator
  const indicator = document.createElement('div');
  indicator.id = 'auto-save-indicator';
  indicator.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    z-index: 10002;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    animation: autoSaveGlow 2s ease-in-out infinite alternate;
    display: flex;
    align-items: center;
    gap: 8px;
  `;
  
  indicator.innerHTML = `
    <i class="fa fa-save" style="font-size: 14px;"></i>
    Auto Save Enabled
  `;
  
  document.body.appendChild(indicator);
  
  // Auto-hide after 4 seconds
  setTimeout(() => {
    if (indicator && indicator.parentNode) {
      indicator.style.opacity = '0';
      indicator.style.transform = 'translateX(100px)';
      setTimeout(() => {
        if (indicator && indicator.parentNode) {
          indicator.remove();
        }
      }, 300);
    }
  }, 4000);
}

// ✅ NEW: Add CSS animation for auto-save indicator
const autoSaveStyle = document.createElement('style');
autoSaveStyle.textContent = `
  @keyframes autoSaveGlow {
    0% {
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }
    100% {
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.5);
    }
  }
`;
document.head.appendChild(autoSaveStyle);

// ✅ Make function globally available
window.showAutoSaveIndicator = showAutoSaveIndicator;

// ✅ UPDATED: Enhanced addEditableFormEventListeners to include auto-save
function addEditableFormEventListeners(row, batchId, stockLotId) {
  
  
  // ✅ NEW: Add auto-save on input changes (debounced)
  let autoSaveTimeout;
  function scheduleAutoSave() {
    // ✅ NEW: Skip auto-save if manual draft is in progress
    if (window.isManualDraftInProgress) {
      console.log('🔄 [scheduleAutoSave] Skipping auto-save - manual draft in progress');
      return;
    }
    
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(() => {
      try {
        autoSaveRejectionDraft(stockLotId, batchId).catch(error => {
          console.log('⚠️ Auto-save failed, but continuing...', error);
        });
      } catch (error) {
        console.log('⚠️ Auto-save error caught:', error);
      }
    }, 1500); // Save after 1.5 seconds of no changes
  }
  
  // ✅ AGGRESSIVE: Add auto-save to all relevant inputs with multiple triggers
  const addAutoSaveToInputs = () => {
    document.querySelectorAll('.rejection-qty-input, .rejection-tray-id-input, #batchRejection, #lotRejectionRemarksInput').forEach(input => {
      // Remove existing listeners to avoid duplicates
      input.removeEventListener('input', scheduleAutoSave);
      input.removeEventListener('change', scheduleAutoSave);
      input.removeEventListener('focus', scheduleAutoSave);
      input.removeEventListener('blur', scheduleAutoSave);
      
      // Add all event listeners
      input.addEventListener('input', scheduleAutoSave);
      input.addEventListener('change', scheduleAutoSave);
      input.addEventListener('focus', scheduleAutoSave); // Trigger on focus too
      input.addEventListener('blur', scheduleAutoSave);  // And on blur
    });
  };
  
  // Initial setup and periodic re-setup (in case DOM changes)
  addAutoSaveToInputs();
  const inputSetupInterval = setInterval(addAutoSaveToInputs, 3000);
  
  // Clear interval when modal closes
  const clearInputSetup = () => {
    clearInterval(inputSetupInterval);
  };
  
  // ✅ NOTE: Button event listeners are now attached in showEditableRejectionFormWithData()
  // after the DOM is ready. Removed from here to prevent "Cannot read properties of null" errors.
  
  // ✅ IMPROVED: Enhanced modal close detection and auto-save
  const modal = document.getElementById("trayScanModal");
  if (modal) {
    const closeHandler = () => {
      console.log('🔄 [autoSave] Modal close detected, saving draft...');
      clearInputSetup(); // Clear the interval
      // Save draft immediately when closing
      autoSaveRejectionDraft(stockLotId, batchId);
    };
    
    // Method 1: Add to known close buttons
    const closeButtons = modal.querySelectorAll('#closeTrayScanModal, .tray-scan-close, .close, [onclick*="close"], button[onclick*="cancel"]');
    closeButtons.forEach(btn => {
      btn.addEventListener('click', closeHandler);
    });
    
    // ✅ NEW: Add to modal close button (X) for auto-save indication
    const modalCloseBtn = document.getElementById('closeTrayScanModal');
    if (modalCloseBtn) {
      modalCloseBtn.addEventListener('click', function() {
        // ✅ Show auto-save indicator when closing without manual save
        if (window.isAutoSaveActive) {
          showAutoSaveIndicator();
        }
      });
    }
    
    // Method 2: Use MutationObserver to detect when modal display changes to 'none'
    const modalObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && 
            (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
          const computedStyle = window.getComputedStyle(modal);
          const hasOpenClass = modal.classList.contains('open');
          
          // Trigger auto-save when modal is being closed
          if (computedStyle.display === 'none' || !hasOpenClass) {
            console.log('🔄 [autoSave] Modal visibility changed, saving draft...');
            closeHandler();
          }
        }
      });
    });
    
    // Start observing the modal for attribute changes
    modalObserver.observe(modal, {
      attributes: true,
      attributeFilter: ['style', 'class']
    });
    
    // Method 3: Global click event to detect clicks outside modal
    document.addEventListener('click', (event) => {
      if (modal.style.display !== 'none' && 
          modal.classList.contains('open') &&
          !modal.contains(event.target)) {
        // Click outside modal - might be closing it
        setTimeout(() => {
          if (modal.style.display === 'none' || !modal.classList.contains('open')) {
            closeHandler();
          }
        }, 100);
      }
    });
    
    // Method 4: Keyboard escape key
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && 
          modal.style.display !== 'none' && 
          modal.classList.contains('open')) {
        closeHandler();
      }
    });
    
    // Method 5: Window beforeunload (in case browser is closed)
    window.addEventListener('beforeunload', closeHandler);
  }
  
  
}

// ✅ UPDATED: Enhanced checkForExistingDraft to better handle draft loading
function checkForExistingDraft(stockLotId, batchId, detailsDiv, row) {
  console.log('🔍 [checkForExistingDraft] Checking for draft data for lot:', stockLotId);
  
  fetch(`/inputscreening/get_rejection_draft/?lot_id=${encodeURIComponent(stockLotId)}`)
    .then(response => response.json())
    .then(data => {
      if (data.success && data.draft_data) {
        console.log('✅ [checkForExistingDraft] Draft data found, loading...');
        loadDraftDataIntoForm(data.draft_data);
        showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, data.draft_data);
      } else {
        console.log('ℹ️ [checkForExistingDraft] No draft data found, showing fresh form');
        showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
      }
    })
    .catch(error => {
      console.error('❌ [checkForExistingDraft] Error checking draft:', error);
      showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
    });
}

// ✅ Placeholder - main function is defined later in the file
// This keeps the function reference available early
window.loadDraftDataIntoForm = function(draftData) {
  console.log('⚠️ Early call to loadDraftDataIntoForm, will be replaced by full implementation');
};


</script>

<!-- ✅ SCRIPT 4: Draft Save and Auto-trigger Functionality -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
     let draftButtonsShown = false;
     
     // ✅ CALCULATE TRAY QUANTITIES
     function calculateTrayQuantities() {
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       
       let totalLotQty = 0;
       let verifiedQty = 0;
       let unverifiedQty = 0;
       
       const rows = detailsDiv.querySelectorAll("tbody tr");
       
       
       rows.forEach((row, index) => {
         const trayQtyInput = row.querySelector('input[type="number"]');
         const trayIdInput = row.querySelector('input[type="text"]');
         
         if (trayQtyInput && trayIdInput) {
           const trayQty = parseInt(trayQtyInput.value) || 0;
           totalLotQty += trayQty;
           
           // Check multiple ways to determine if row is verified
           let isVerified = false;
           
           // Method 1: Check for verification indicator (✓ Verified text)
           const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
           if (hasVerificationIndicator && hasVerificationIndicator.textContent.includes('✓')) {
             isVerified = true;
           }
           
           // Method 2: Check for validation status icons
           if (!isVerified) {
             const statusCell = row.querySelector("td:last-child");
             const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
             if (hasPassIcon) {
               isVerified = true;
             }
           }
           
           // Method 3: Check if tray ID input is readonly and has value
           if (!isVerified && trayIdInput.hasAttribute('readonly') && trayIdInput.value.trim()) {
             const inputStyle = trayIdInput.style.backgroundColor;
             if (inputStyle.includes('#f5f5f5')) {
               isVerified = true;
             }
           }
           
           // Add to appropriate counter
           if (isVerified) {
             verifiedQty += trayQty;
           } else {
             unverifiedQty += trayQty;
           }
         }
       });
       
   
       return {
         totalLotQty,
         verifiedQty,
         unverifiedQty
       };
     }
     
     // ✅ HANDLE DRAFT SAVE
   // In your IS_PickTable.html, find the handleDraftSave or draft button click handler
// Add this after successful draft save:

function handleDraftSave() {
   showLoadingOverlay();
    // ✅ CRITICAL: Log flag state at function entry
    console.log('🚀 [handleDraftSave] ENTRY - isManualDraftMode:', window.isManualDraftMode);
    
    // ✅ FIXED: Handle both tray scanning modal and rejection form contexts
    
    // Try to get data from tray scanning modal first (original context)
    let stockLotId = document.querySelector('[name="lot_id"]')?.value || '';
    let batchId = document.querySelector('[name="batch_id"]')?.value || '';
    
    // If not found, try to get from modal dataset (rejection form context)
    if (!stockLotId || !batchId) {
        const modal = document.getElementById("trayScanModal");
        if (modal) {
            stockLotId = modal.stockLotId || modal.dataset.stockLotId || '';
            batchId = modal.dataset.batchId || '';
        }
    }
    
    // If still not found, try global functions
    if (!stockLotId) stockLotId = window.getCurrentLotId ? window.getCurrentLotId() : '';
    if (!batchId) batchId = window.getCurrentBatchId ? window.getCurrentBatchId() : '';
    
    console.log('🔄 [handleDraftSave] Collected IDs - lot:', stockLotId, 'batch:', batchId);
    
    if (!stockLotId || !batchId) {
        console.error('❌ [handleDraftSave] Missing lot_id or batch_id');
        showSuccessMessage('❌ Error: Missing lot or batch information', '#dc3545');
        return;
    }
    
    // ✅ CRITICAL FIX: Use collectFormData to properly capture tray_scans for draft restoration
    const formData = window.collectFormData ? window.collectFormData(stockLotId, batchId) : null;
    
    if (!formData) {
        console.error('❌ [handleDraftSave] collectFormData not available');
        showSuccessMessage('❌ Error: Unable to collect form data', '#dc3545');
        return;
    }
    
    // Override is_auto_save flag based on manual draft mode
    formData.is_auto_save = !window.isManualDraftMode;
    
    console.log('💼 [handleDraftSave] isManualDraftMode:', window.isManualDraftMode, '-> is_auto_save:', formData.is_auto_save);
    console.log('🔄 [handleDraftSave] Collected form data:', {
        rejection_data_count: formData.rejection_data.length,
        tray_scans_count: formData.tray_scans.length,
        is_batch_rejection: formData.is_batch_rejection,
        total_rejection_qty: formData.total_rejection_qty
    });
    
    const rejectionData = formData.rejection_data;
    
    // If no rejection data, this is a tray-validation draft — use the tray-draft endpoint
    if (!rejectionData.length) {
        fetch('/inputscreening/ip_save_tray_draft/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ lot_id: stockLotId, edited_tray_qty: null })
        })
        .then(response => response.json())
        .then(data => {
            console.log('🔄 [handleDraftSave] IP tray draft response:', data);
            if (data.success) {
              showSuccessMessage();
               location.reload();
              // Update the main table row UI for draft (keeps behavior consistent)
              setTimeout(() => {
                window.location.reload();
              }, 2000); // Increased delay to ensure alert is visible
            } else {
              showSuccessMessage('❌ Tray draft save failed: ' + (data.error || 'Unknown error'), '#dc3545');
            }
        })
        .catch(err => {
           hideLoadingOverlay();
            console.error('🔴 [handleDraftSave] IP tray draft error:', err);
            showSuccessMessage('❌ Tray draft save failed: Network error', '#dc3545');
        });
        return;
    }

    // Otherwise treat as rejection draft
    fetch('/inputscreening/save_rejection_draft/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(formData)
    })
    .then(response => response.json())
    .then(data => {
        console.log('🔄 [handleDraftSave] Response:', data);
        if (data.success) {
            // ✅ FIXED: Show success message and wait longer before reload
            
            // ✅ NEW: Disable auto-save temporarily to prevent interference
            window.isManualDraftInProgress = true;
            
            // ✅ FIXED: Increase delay to 2 seconds so user can see the message
            setTimeout(() => {
                console.log('🔄 [handleDraftSave] Reloading page after manual draft save');
                // ✅ NEW: Reset manual draft flag before reload
                window.isManualDraftInProgress = false;
                window.isManualDraftMode = false; // Reset manual draft mode
                window.location.reload();
            }, 2000);
        } else {
            showSuccessMessage('❌ Draft save failed: ' + (data.error || 'Unknown error'), '#dc3545');
        }
    })
    .catch(error => {
        console.error('❌ [handleDraftSave] Error:', error);
        hideLoadingOverlay();
        showSuccessMessage('❌ Draft save failed: Network error', '#dc3545');
    });
}
     
     // ✅ AUTO-TRIGGER CHECKBOX SAVE
     function autoTriggerCheckboxSave() {
       const lotId = window.getCurrentLotId();
       if (!lotId) {
         return;
       }
   
       const { totalLotQty, unverifiedQty, verifiedQty } = calculateTrayQuantities();
       const missingQty = unverifiedQty;
       const physicalQty = totalLotQty - unverifiedQty;
       const editedTrayQty = window.getEditedTrayQtyFromModal();
   
       showSuccessMessage('All trays verified! Auto-saving checkbox...', '#007bff');
   
       fetch('/inputscreening/save_ip_checkbox/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': window.getCookie('csrftoken')
         },
         body: JSON.stringify({
           lot_id: lotId,
           missing_qty: missingQty || '0',
           edited_tray_qty: editedTrayQty
         })
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           showSuccessMessage('✅ All trays verified.', '#28a745');
           updateMainTableRowStatus(lotId, missingQty, physicalQty);
           setTimeout(() => {
             const modal = document.getElementById("trayScanModal_DayPlanning");
             if (modal) {
               modal.classList.remove("open");
               modal.style.display = "none";
             }
             window.location.reload();
           }, 2000);
         } else {
           showSuccessMessage('❌ Auto-save failed: ' + (data.error || 'Unknown error'), '#dc3545');
         }
       })
       .catch(error => {
         showSuccessMessage('❌ Auto-save network error', '#dc3545');
       });
     }
     
     // ✅ SHOW DRAFT/CANCEL BUTTONS
     function showDraftCancelButtons() {
       if (draftButtonsShown) {
         return;
       }
   
       removeDraftCancelButtons();
   
       const infoMsg = document.createElement('div');
       infoMsg.id = 'draftInfoMessage';
       infoMsg.style.cssText = `
         background: #fff3cd;
         border: 1px solid #ffeaa7;
         color: #856404;
         padding: 12px 16px;
         border-radius: 8px;
         margin: 15px 0;
         font-size: 14px;
         text-align: center;
       `;
       infoMsg.innerHTML = `
         <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
         Some tray IDs are not verified. You can save as draft to continue later or cancel to return.
       `;
   
       const buttonContainer = document.createElement('div');
       buttonContainer.id = 'draftCancelButtons';
       buttonContainer.style.cssText = `
         display: flex;
         justify-content: center;
         gap: 15px;
         margin-top: 20px;
         padding: 15px;
         background: #f8f9fa;
         border-radius: 8px;
         border: 1px solid #dee2e6;
       `;
   
       const draftBtn = document.createElement('button');
       draftBtn.id = 'trayDraftBtn';
       draftBtn.textContent = 'Save as Draft';
       draftBtn.style.cssText = `
         padding: 10px 20px;
         background: #007bff;
         color: white;
         border: none;
         border-radius: 25px;
         font-weight: 600;
         cursor: pointer;
         transition: all 0.3s ease;
       `;
   
       const cancelBtn = document.createElement('button');
       cancelBtn.id = 'trayCancelBtn';
       cancelBtn.textContent = 'Cancel';
       cancelBtn.style.cssText = `
         padding: 10px 20px;
         background: #6c757d;
         color: white;
         border: none;
         border-radius: 25px;
         font-weight: 600;
         cursor: pointer;
         transition: all 0.3s ease;
       `;
   
       draftBtn.onmouseover = () => draftBtn.style.background = '#0056b3';
       draftBtn.onmouseout = () => draftBtn.style.background = '#007bff';
       cancelBtn.onmouseover = () => cancelBtn.style.background = '#545b62';
       cancelBtn.onmouseout = () => cancelBtn.style.background = '#6c757d';
   
       draftBtn.onclick = () => {
         // ✅ NEW: Set manual draft flag when clicking draft
         window.isManualDraftMode = true;
         handleDraftSave();
       };
       cancelBtn.onclick = handleCancel;
   
       buttonContainer.appendChild(draftBtn);
       buttonContainer.appendChild(cancelBtn);
   
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const modalContent = modal.querySelector('.tray-scan-modal-DayPlanning-content');
       if (modalContent) {
         modalContent.appendChild(infoMsg);
         modalContent.appendChild(buttonContainer);
       }
   
       draftButtonsShown = true;
     }
     
     // ✅ REMOVE DRAFT/CANCEL BUTTONS
     function removeDraftCancelButtons() {
       const existingInfoMsg = document.getElementById('draftInfoMessage');
       if (existingInfoMsg) {
         existingInfoMsg.remove();
       }
   
       const existingButtons = document.getElementById('draftCancelButtons');
       if (existingButtons) {
         existingButtons.remove();
       }
   
       draftButtonsShown = false;
     }
     
     // ✅ HANDLE CANCEL
     function handleCancel() {
       const modal = document.getElementById("trayScanModal_DayPlanning");
       if (modal) {
         modal.classList.remove("open");
         modal.style.display = "none";
       }
     }
     
     // ✅ UPDATE MAIN TABLE ROW FOR DRAFT WITH QUANTITIES
     function updateMainTableRowForDraftWithQuantities(lotId, missingQty, physicalQty) {
       try {
         const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
         if (!mainTableRow) {
           return;
         }
   
         const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
         if (missingQtyInput) {
           missingQtyInput.value = missingQty;
           missingQtyInput.style.backgroundColor = '#fff3cd';
           missingQtyInput.style.borderColor = '#ffc107';
         }
   
         const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = physicalQty;
           physicalQtyInput.style.backgroundColor = '#fff3cd';
           physicalQtyInput.style.borderColor = '#ffc107';
           physicalQtyInput.setAttribute('title', 'This quantity was edited');
         }
   
   
   
         const lotStatusCell = mainTableRow.cells[17];
         if (lotStatusCell) {
           lotStatusCell.innerHTML = `
             <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                 style="
                 border: 1px solid #4997ac;
                 background-color: #d1f2f3;
                 color: #03425d;
                 font-size: 12px;
                 white-space: nowrap;
                 padding: 5px;
                 "
                 >
               Draft
             </div>
           `;
         }
   
       } catch (error) {
       }
     }
     
     // ✅ UPDATE MAIN TABLE ROW STATUS
     function updateMainTableRowStatus(lotId, missingQty, physicalQty) {
       try {
         const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
         if (!mainTableRow) {
           return;
         }
   
         const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
         if (missingQtyInput) {
           missingQtyInput.value = missingQty;
           missingQtyInput.disabled = true;
           if (missingQty === 0) {
             missingQtyInput.style.backgroundColor = '#d4edda';
             missingQtyInput.style.borderColor = '#28a745';
           } else {
             missingQtyInput.style.backgroundColor = '#fff3cd';
             missingQtyInput.style.borderColor = '#ffc107';
           }
         }
   
         const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = physicalQty;
           physicalQtyInput.style.backgroundColor = '#d4edda';
           physicalQtyInput.style.borderColor = '#28a745';
           physicalQtyInput.setAttribute('title', 'Quantity verified through tray scan');
         }
   
         const checkbox = mainTableRow.querySelector('.ip-checkbox');
         if (checkbox) {
           checkbox.checked = true;
           checkbox.disabled = true;
         }
   
         const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
         if (processIcons.length > 0) {
           processIcons[0].style.backgroundColor = '#0c8249';
         }
   
         const saveIpCheckbox = mainTableRow.querySelector('.save-ip-checkbox');
         if (saveIpCheckbox) {
           saveIpCheckbox.style.display = 'none';
         }

         // Disable Accept/Reject buttons to mark as accepted
         const acceptBtn = mainTableRow.querySelector('.btn-twitter');
         const rejectBtn = mainTableRow.querySelector('.btn-youtube.tray-scan-btn');
         if (acceptBtn) {
           acceptBtn.disabled = true;
           acceptBtn.style.opacity = '0.5';
           acceptBtn.style.cursor = 'not-allowed';
         }
         if (rejectBtn) {
           rejectBtn.disabled = true;
           rejectBtn.style.opacity = '0.5';
           rejectBtn.style.cursor = 'not-allowed';
         }

       } catch (error) {
       }
     }
     
     // ✅ SHOW SUCCESS MESSAGE
     function showSuccessMessage(message, color = '#28a745') {
       const existingMsg = document.getElementById('auto-save-message');
       if (existingMsg) {
         existingMsg.remove();
       }
   
       const messageDiv = document.createElement('div');
       messageDiv.id = 'auto-save-message';
       messageDiv.style.cssText = `
         position: fixed;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         background: ${color};
         color: white;
         padding: 12px 20px;
         border-radius: 8px;
         box-shadow: 0 4px 12px rgba(0,0,0,0.15);
         z-index: 10002;
         font-weight: 500;
         max-width: 300px;
         word-wrap: break-word;
         text-align: center;
       `;
       messageDiv.style.zIndex = "1000001"; // Higher than modal
   
       messageDiv.textContent = message;
       document.body.appendChild(messageDiv);
   
       setTimeout(() => {
         messageDiv.style.transform = 'translate(-50%, -50%) scale(1)';
       }, 100);
   
       setTimeout(() => {
         messageDiv.style.transform = 'translate(-50%, -50%) scale(0.9)';
         messageDiv.style.opacity = '0';
         setTimeout(() => {
           if (messageDiv.parentNode) {
             messageDiv.parentNode.removeChild(messageDiv);
           }
         }, 300);
       }, 4000);
     }
     
     // ✅ Make functions available globally
     window.showDraftCancelButtons = showDraftCancelButtons;
     window.removeDraftCancelButtons = removeDraftCancelButtons;
     window.autoTriggerCheckboxSave = autoTriggerCheckboxSave;
     window.handleDraftSave = handleDraftSave;
     window.draftButtonsShown = draftButtonsShown;
   });
</script>

<!-- ✅ SCRIPT 5: Button Handlers and Modal Controls -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     
   // ✅ IMPROVED: TRAY VALIDATE BUTTON HANDLER - Prevent rebuilding if already active
   const validateBtn = document.getElementById("trayValidateBtn");
   const validateInput = document.getElementById("trayValidateInput");
   const errorMessage = document.getElementById("trayErrorMessage");
   const pleaseScanIndicator = document.getElementById("pleaseScanIndicator");
   
   if (validateBtn && validateInput) {
     validateBtn.addEventListener("click", function () {
       if (validateBtn.disabled) return;
   
       // ✅ NEW: Show "Please Scan" indicator
       if (pleaseScanIndicator) {
         pleaseScanIndicator.style.display = "inline-block";
       }
   
       // ✅ NEW: Check if validation mode is already active
       const modal = document.getElementById("trayScanModal_DayPlanning");
       const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
       
       // ✅ First time clicking - proceed with normal setup
       validateInput.value = "";
       if (errorMessage) {
         errorMessage.style.display = "none";
       }
       
       // Change button to active state
       validateBtn.style.background = "#e8f5e8";
       validateBtn.style.borderColor = "#4caf50";
       validateBtn.style.color = "#2e7d32";
       
       // Add the validation column to the table (only first time)
       if (modal && detailsDiv && modal.buildTableHTML) {
         detailsDiv.innerHTML = modal.buildTableHTML(true);
       }
       
       validateInput.focus();
     });
   }
   
// ✅ REDO BUTTON HANDLER
const redoBtn = document.getElementById("trayQtyRedoBtn");
if (redoBtn && validateInput) {
  redoBtn.addEventListener('click', async function () {
    // 1. Call backend to reset verification for this lot
    const modal = document.getElementById("trayScanModal_DayPlanning");
    const lotId = modal && modal.stockLotId ? modal.stockLotId : (window.getCurrentLotId && window.getCurrentLotId());
    if (!lotId) return;

    // Disable redo button to prevent double clicks
    redoBtn.disabled = true;

    try {
      // Call backend to reset verification
      await fetch('/inputscreening/reset_tray_verification_for_lot/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': (window.getCookie && window.getCookie('csrftoken')) || ''
        },
        body: JSON.stringify({ lot_id: lotId })
      });

      // 2. Fetch updated verification status
      const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(lotId)}`);
      const verifyResult = await verifyResp.json();
      let verificationData = {};
      if (verifyResult.success) {
        verificationData = verifyResult.verification_data;
      }

      // 3. Update modal's verificationData and rebuild table
      if (modal) {
        modal.verificationData = verificationData;
        // Rebuild the table to reflect "Not verified" status
        if (typeof modal.buildTableHTML === "function") {
          const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
          if (detailsDiv) {
            detailsDiv.innerHTML = modal.buildTableHTML(false);
          }
        }
      }

      // 4. Visually update all status indicators to "Not verified"
      document.querySelectorAll('.tray-verified-indicator').forEach(function (el) {
        el.textContent = '⏳ Not Verified';
        el.classList.remove('verified');
        el.classList.add('not-verified');
      });

    } catch (err) {
      console.error('Redo failed:', err);
    } finally {
      redoBtn.disabled = false;
    }
  });
}
   
   
     // ✅ QTY INPUT CHANGE HANDLER
     document.addEventListener('input', function (e) {
       if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
         const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
         let currentQty = parseInt(e.target.value, 10) || 0;
         
         // Prevent increasing above original
         if (currentQty > originalQty) {
           e.target.value = originalQty;
         }
         // Prevent going below zero
         if (currentQty < 0) {
           e.target.value = 0;
         }
         
         // Enable Tray Validate button
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
         }
       }
     });
   
     // ✅ MODAL CLOSE HANDLER
     const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
     if (closeBtn) {
       closeBtn.addEventListener("click", function () {
         window.location.reload(); 

         window.removeDraftCancelButtons();
         window.draftButtonsShown = false;
         
         const modal = document.getElementById("trayScanModal_DayPlanning");
         if (modal) {
           modal.classList.remove("open");
           modal.style.display = "none";
         }
         
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
         
         // ✅ NEW: Hide "Please Scan" indicator when modal is closed
         const pleaseScanIndicator = document.getElementById("pleaseScanIndicator");
         if (pleaseScanIndicator) {
           pleaseScanIndicator.style.display = "none";
         }
       });
     }

    });
</script>

<!--Accept functionality-->
<script nonce="{{csp_nonce}}">
   document.addEventListener("DOMContentLoaded", function () {
     // Use event delegation to handle dynamically created buttons
     document.addEventListener('click', function(e) {
       // Check if the clicked element is an Accept button
       if (e.target.closest('.btn-twitter')) {
         const acceptBtn = e.target.closest('.btn-twitter');
         
         // Skip if button is disabled
         if (acceptBtn.disabled) return;
         
         const row = acceptBtn.closest('tr');
         if (!row) return;
         
         // Try to get lot ID from multiple sources
         let lotId = acceptBtn.getAttribute('data-lot-id');
         if (!lotId) {
           const checkbox = row.querySelector('.ip-checkbox');
           lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
         }
         if (!lotId) {
           lotId = row.getAttribute('data-stock-lot-id');
         }
         
         if (!lotId) {
           Swal.fire('Error', 'Lot ID not found', 'error');
           return;
         }
         
         // Show confirmation dialog before proceeding
         Swal.fire({
           title: 'Lot Accept',
           text: 'Are you sure you want to accept this lot?',
           icon: 'question',
           showCancelButton: true,
           confirmButtonColor: '#28a745',
           cancelButtonColor: '#6c757d',
           confirmButtonText: 'Yes, Accept',
           cancelButtonText: 'Cancel',
           reverseButtons: true
         }).then((result) => {
           if (result.isConfirmed) {
             // User confirmed, proceed with acceptance
             
             // Disable button during processing
             acceptBtn.disabled = true;
             
             fetch('/inputscreening/is_accepted_form/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({ stock_lot_id: lotId })
         })
         .then(res => {
           if (res.redirected) {
             window.location.href = res.url; // handle Django redirect
             return;
           }
           return res.json();
         })
         .then(data => {
           if (data && data.success) {
             Swal.fire({
               icon: 'success',
               title: 'Accepted successfully!',
               showConfirmButton: false,
               timer: 1200
             }).then(() => {
               // Update UI elements silently instead of reloading page
               window.location.reload(); // Reload to reset state
             });
           } else if (data && data.error) {
             Swal.fire('Error', data.error, 'error');
             // Re-enable button on error
             acceptBtn.disabled = false;
           }
         })
         .catch((error) => {
           Swal.fire('Error', 'Network error', 'error');
           // Re-enable button on error
           acceptBtn.disabled = false;
         });
           }
         });
       }
     });
     
     // Helper function for CSRF token (if not already defined)
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   });
</script>

<!-- Delete Batch Functionality -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
   
     const cancelBtn = document.getElementById("trayScanCancelBtn");
     if (cancelBtn) {
       cancelBtn.addEventListener("click", function () {
         const modal = document.getElementById("trayScanModal_BQ");
         if (modal) modal.classList.remove("open");
       });
     }
   
      // DELETE BUTTON HANDLER
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
     btn.addEventListener('click', function(e) {
       e.preventDefault();
       const row = btn.closest('tr');
       if (!row) return;
       const batchId = btn.getAttribute('data-batch-id');
       const stockLotId = btn.getAttribute('data-stock-lot-id');
       if (!batchId || !stockLotId) {
         Swal.fire('Error', 'Batch ID or Stock Lot ID not found!', 'error');
         return;
       }
       Swal.fire({
         title: 'Are you sure?',
         text: 'Do you really want to delete this batch?',
         icon: 'warning',
         showCancelButton: true,
         confirmButtonColor: '#d33',
         cancelButtonColor: '#3085d6',
         confirmButtonText: 'Yes, delete it!',
         cancelButtonText: 'Cancel'
       }).then((result) => {
         if (result.isConfirmed) {
           fetch('/inputscreening/ip_delete_batch/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify({ batch_id: batchId, stock_lot_id: stockLotId })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               row.remove();
               Swal.fire({
                 icon: 'success',
                 title: 'Deleted!',
                 text: 'Batch has been deleted.',
                 timer: 1200,
                 showConfirmButton: false
               });                  
             } else {
               Swal.fire('Error', data.error || 'Delete failed', 'error');
             }
           });
         }
       });
     });
   });
   
   
   // Helper function to show error notification
   function showErrorNotification(message) {
   // Create or get existing notification element
   let notification = document.getElementById('error-notification');
   if (!notification) {
   notification = document.createElement('div');
   notification.id = 'error-notification';
  notification.style.cssText = `
     position: fixed;
     left: 50%;
     top: 50%;
     transform: translate(-50%, -50%);
     background: #dc3545;
     color: white;
     padding: 18px 32px;
     border-radius: 12px;
     box-shadow: 0 4px 24px rgba(220,53,69,0.18);
     z-index: 10001;
     font-weight: 600;
     font-size: 18px;
     text-align: center;
     transition: opacity 0.3s ease;
     opacity: 1;
  `;
 
notification.textContent = message;

// Show notification
notification.style.opacity = '1';

// Hide notification after 4 seconds
setTimeout(() => {
   notification.style.opacity = '0';
}, 4000);
   
   const table = document.getElementById("order-listing");
     if (!table) {
       return;
     }
   
     const headers = table.querySelectorAll("thead th");
     const tbody = table.querySelector("tbody");
   
     let sortDirection = {};
   
     headers.forEach((header, index) => {
       header.style.cursor = "pointer";
   
       header.addEventListener("click", function () {
         const rows = Array.from(tbody.querySelectorAll("tr"));
         const dir = sortDirection[index] === "asc" ? "desc" : "asc";
         sortDirection[index] = dir;
   
         rows.sort((a, b) => {
           const cellA = a.children[index].textContent.trim();
           const cellB = b.children[index].textContent.trim();
           const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
           const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
   
           if (valA < valB) return dir === "asc" ? -1 : 1;
           if (valA > valB) return dir === "asc" ? 1 : -1;
           return 0;
         });
   
         tbody.innerHTML = "";
         rows.forEach((row) => tbody.appendChild(row));
       });
     });
   });
</script>

<!-- Complete Tray Scan Modal & New Popup Script with Simplified Single Top Tray Scan -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", () => {
     const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
     const trayModal = document.getElementById("trayScanModal");
     const closeTrayBtn = document.getElementById("closeTrayScanModal");
     if (closeTrayBtn && trayModal) {
       closeTrayBtn.addEventListener("click", function () {
         // ✅ CRITICAL: Auto-save before closing modal
         console.log('🔄 [closeTrayScanModal] Triggering auto-save before close');
         if (typeof window.triggerAutoSave === 'function') {
           window.triggerAutoSave();
         }
         
         trayModal.classList.remove("open");
         trayModal.style.display = "none";
       });
     }

     const detailsDiv = document.getElementById("trayScanDetails");
     const newPopupModal = document.getElementById("newPopupModal");
     const closeNewPopupBtn = document.getElementById("closeNewPopupModal");
   
     // ✅ NEW: Draft functionality variables
     let isDraftMode = false;
     let currentDraftData = null;
     let isManualDraftMode = false; // ✅ NEW: Track if draft was manually created
   
     trayScanLinks.forEach((link) => {
       link.addEventListener("click", (event) => {
         event.preventDefault();
   
         const row = event.target.closest("tr");
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         const isOnProceed = row.getAttribute('data-few-cases-acceptance') === 'True';
         const hasDraft = row.getAttribute('data-draft-tray-verify') === 'True';
         const isOnHold = row.getAttribute('data-ip-onhold-picking') === 'True';
   
         trayModal.dataset.batchId = batchId;
         trayModal.dataset.stockLotId = stockLotId;
   
         const dateTime = row.cells[1].textContent.trim();
         const totalQuantity = row.cells[10].textContent.trim();
         const modelNo = row.getAttribute('data-model-no') || '';
         const modalHeader = document.getElementById("trayScanModalHeader");
         if (modalHeader) {
           modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
         }
   
         // ✅ IMPROVED: Better logic to distinguish between acceptance and rejection drafts
         // Only show accepted tray modal if:
         // 1. few_cases_accepted_Ip_stock is True AND 
         // 2. NOT just a draft (draft_tray_verify alone doesn't mean accepted)
         // 3. ip_onhold_picking is False (fully processed)
         if (isOnProceed && !isOnHold) {
           // This is a truly accepted lot, show accepted tray modal
           fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
             .then(res => res.json())
             .then(rescanData => {
               if (rescanData.success) {
                 showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
               } else {
                 // Fallback to showing rejection modal if accepted tray data fails
                 showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
               }
             })
             .catch(error => {
               console.error('Error fetching accepted tray data:', error);
               // Fallback to showing rejection modal
               showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
             });
           return; // Exit early, don't show rejection modal
         }
   
         // ✅ EXISTING: Normal flow for new rejections (when isOnProceed = false)
         showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
       });
     });
   
     // ✅ NEW: Extract the original modal logic into a separate function
   function showRejectionModalFlow(batchId, stockLotId, isOnProceed, row) {
   const trayModal = document.getElementById("trayScanModal");
   const detailsDiv = document.getElementById("trayScanDetails");
   
   trayModal.dataset.batchId = batchId;
   trayModal.dataset.stockLotId = stockLotId;





         // ✅ MODAL CLOSE HANDLER
     const closeBtn = document.getElementById("closeTrayScanModal");
     if (closeBtn) {
       closeBtn.addEventListener("click", function () {
         window.location.reload(); 

         window.removeDraftCancelButtons();
         window.draftButtonsShown = false;
         
         const modal = document.getElementById("trayScanModal_DayPlanning");
         if (modal) {
           modal.classList.remove("open");
           modal.style.display = "none";
         }
         
         const validateBtn = document.getElementById("trayValidateBtn");
         if (validateBtn) {
           validateBtn.disabled = false;
           validateBtn.style.opacity = "1";
           validateBtn.style.cursor = "pointer";
           validateBtn.style.background = "#f5faff";
           validateBtn.style.borderColor = "#023E4DCC";
           validateBtn.style.color = "#023E4DCC";
         }
       });
     }
   
   
   const dateTime = row.cells[1].textContent.trim();
   const totalQuantity = row.cells[10].textContent.trim();
   const modelNo = row.getAttribute('data-model-no') || '';
   const modalHeader = document.getElementById("trayScanModalHeader");
   if (modalHeader) {
   modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
   }
   
   // Set current lot qty for auto-checking lot rejection checkbox
   window.currentLotQty = parseInt(totalQuantity) || 0;
   
   // If ip_onhold_picking is True, show read-only saved data
   if (isOnProceed) {
   showReadOnlyRejectionData(stockLotId, detailsDiv);
   } else {
   // ✅ UPDATED: Check for draft first, then show form
   checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
   }
   
   trayModal.style.display = "block";
   trayModal.classList.add("open");
   }
   
     // ✅ NEW: Check for existing draft data
     function checkForExistingDraft(stockLotId, batchId, detailsDiv, row) {
       fetch(`/inputscreening/get_rejection_draft/?lot_id=${encodeURIComponent(stockLotId)}`)
         .then(res => res.json())
         .then(data => {
           if (data.success && data.has_draft) {
             isDraftMode = true;
             currentDraftData = data.draft_data;
             
             // ✅ NEW: Check if this is a manual draft or auto-save
             isManualDraftMode = !data.draft_data?.is_auto_save;
             
             showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, currentDraftData);
           } else {
             isDraftMode = false;
             isManualDraftMode = false;
             currentDraftData = null;
             showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
           }
         })
         .catch(error => {
           // Fallback to normal form
           isDraftMode = false;
           isManualDraftMode = false;
           currentDraftData = null;
           showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
         });
     }
   
// ✅ NEW: Function to show read-only rejection data (for proceed mode)
function showReadOnlyRejectionData(stockLotId, detailsDiv) {
  fetch(`/inputscreening/ip_get_rejected_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
    .then(res => res.json())
    .then(data => {
      if (data.success && data.rows && data.rows.length > 0) {
        // Process is completed - directly open set top tray with delink window
        console.log('✅ Rejection process completed, opening set top tray window directly');
        
        // Close the current rejection modal
        const currentModal = document.getElementById("trayScanModal");
        if (currentModal) {
          currentModal.style.display = "none";
          currentModal.classList.remove("open");
        }
        
        // Find the row and open set top tray directly
        const rows = document.querySelectorAll('#order-listing tbody tr');
        let targetRow = null;
        
        console.log('🔍 [showReadOnlyRejectionData] Searching for lot ID:', stockLotId);
        console.log('🔍 [showReadOnlyRejectionData] Found', rows.length, 'table rows');
        
        rows.forEach((row, index) => {
          // Try multiple ways to find the lot ID
          const dataLotId = row.getAttribute('data-lot-id');
          const dataStockLotId = row.getAttribute('data-stock-lot-id'); 
          const firstCellText = row.querySelector('td:first-child')?.textContent?.trim();
          const lotIdCell = row.querySelector('td:nth-child(3)')?.textContent?.trim(); // 3rd column often contains lot ID
          
          console.log(`🔍 Row ${index}:`, {
            dataLotId,
            dataStockLotId, 
            firstCellText,
            lotIdCell
          });
          
          if (dataLotId === stockLotId || dataStockLotId === stockLotId || 
              firstCellText === stockLotId || lotIdCell === stockLotId) {
            targetRow = row;
            console.log('✅ [showReadOnlyRejectionData] Found matching row at index:', index);
          }
        });
        
        if (targetRow) {
          // Get batch ID from the row - try multiple attributes
          const batchId = targetRow.getAttribute('data-batch-id') || 
                         targetRow.getAttribute('data-batch_id') ||
                         targetRow.querySelector('[data-batch-id]')?.getAttribute('data-batch-id');
          
          console.log('🔍 [showReadOnlyRejectionData] Found batch ID:', batchId);
          
          // Open set top tray window directly (rejection process already completed)
          openSetTopTrayWindow(batchId, stockLotId, targetRow, 'reject');
        } else {
          console.error('❌ [showReadOnlyRejectionData] Could not find target row for lot:', stockLotId);
          console.log('🔍 [showReadOnlyRejectionData] Available lot IDs in table:');
          rows.forEach((row, i) => {
            const dataLotId = row.getAttribute('data-lot-id') || row.getAttribute('data-stock-lot-id');
            if (dataLotId) console.log(`   Row ${i}: ${dataLotId}`);
          });
          
          // Fallback: show read-only data in current modal
          displayReadOnlyRejectionData(data.rows, detailsDiv, stockLotId);
        }
      } else {
        // No rejection data exists, show empty state
        detailsDiv.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #666;">
            <p>No rejection data found for this lot.</p>
          </div>`;
      }
    })
    .catch(error => {
      console.error('Error fetching rejection data:', error);
      detailsDiv.innerHTML = `
        <div style="text-align: center; padding: 20px; color: #dc3545;">
          <p>Error loading rejection data. Please try again.</p>
        </div>`;
    });
}

// ✅ NEW: Function to display read-only rejection data (fallback)
function displayReadOnlyRejectionData(rows, detailsDiv, stockLotId) {
  // Group rows by rejection reason
  const groupedData = {};
  rows.forEach(row => {
    if (!groupedData[row.reason_id]) {
      groupedData[row.reason_id] = {
        rejection_reason_id: row.reason_id,
        rejection_reason_text: row.reason,
        total_quantity: 0,
        tray_scans: []
      };
    }
    
    groupedData[row.reason_id].total_quantity += parseInt(row.qty) || 0;
    groupedData[row.reason_id].tray_scans.push({
      tray_id: row.tray_id,
      tray_qty: row.qty
    });
  });
  
  const rejectionData = Object.values(groupedData);
  
  let html = `
    <div class="rejection-readonly-container">
      <div class="readonly-header">
        <h4>Rejection Details (Read-Only)</h4>
        <p>This lot has been processed. Data cannot be modified.</p>
      </div>
      <div class="rejection-reason-list">`;

  rejectionData.forEach((item, index) => {
    html += `
      <div class="readonly-rejection-item">
        <div class="rejection-reason-header">
          <span class="reason-id">${item.rejection_reason_id}</span>
          <span class="reason-text">${item.rejection_reason_text}</span>
          <span class="qty-badge">${item.total_quantity} pieces</span>
        </div>`;
    
    if (item.tray_scans && item.tray_scans.length > 0) {
      html += `<div class="tray-scans-list">`;
      item.tray_scans.forEach((tray, trayIndex) => {
        html += `
          <div class="readonly-tray-item">
            <span class="tray-id">${tray.tray_id}</span>
            <span class="tray-qty">${tray.tray_qty} pieces</span>
          </div>`;
      });
      html += `</div>`;
    }
    
    html += `</div>`;
  });

  html += `
      </div>
      <div class="readonly-footer">
        <button type="button" class="btn btn-secondary" onclick="closeRejectionModal()">Close</button>
      </div>
    </div>
    
    <style>
    .rejection-readonly-container {
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      margin: 10px 0;
    }
    .readonly-header {
      border-bottom: 2px solid #dee2e6;
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    .readonly-header h4 {
      color: #495057;
      margin: 0 0 5px 0;
    }
    .readonly-header p {
      color: #6c757d;
      margin: 0;
      font-size: 14px;
    }
    .readonly-rejection-item {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      margin-bottom: 15px;
      overflow: hidden;
    }
    .rejection-reason-header {
      background: #e9ecef;
      padding: 12px 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .reason-id {
      background: #007bff;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
    }
    .reason-text {
      flex: 1;
      font-weight: 500;
      color: #495057;
    }
    .qty-badge {
      background: #28a745;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }
    .tray-scans-list {
      padding: 15px;
    }
    .readonly-tray-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #f8f9fa;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    .tray-id {
      font-family: monospace;
      font-weight: bold;
      color: #495057;
    }
    .tray-qty {
      color: #6c757d;
      font-size: 14px;
    }
    .readonly-footer {
      text-align: center;
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #dee2e6;
    }
    </style>`;

  detailsDiv.innerHTML = html;
}

// ✅ NEW: Function to open set top tray window directly
function openSetTopTrayWindow(batchId, stockLotId, row, mode) {
  console.log('🔄 Opening set top tray window for', mode, 'mode');
  
  // Use the existing showAcceptedTrayModal function
  if (typeof showAcceptedTrayModal === 'function') {
    // First get the accepted tray scan data, then call showAcceptedTrayModal
    fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          showAcceptedTrayModal(data, stockLotId, data.has_draft || false);
        } else {
          console.error('Failed to load accepted tray data:', data.error);
          alert('Unable to open set top tray window. Please try clicking the Accept button manually.');
        }
      })
      .catch(error => {
        console.error('Error loading accepted tray data:', error);
        alert('Error opening set top tray window. Please try again.');
      });
  } else {
    console.warn('showAcceptedTrayModal function not found, attempting manual trigger');
    
    // Fallback: Try to find and click the appropriate button
    const acceptButton = row.querySelector('button[onclick*="showAcceptedTrayModal"], button[onclick*="accepted_form"]');
    if (acceptButton) {
      acceptButton.click();
    } else {
      console.error('Could not find set top tray trigger for lot:', stockLotId);
      alert('Unable to open set top tray window. Please try clicking the Accept button manually.');
    }
  }
}

// ✅ NEW: Function to close rejection modal
function closeRejectionModal() {
  const modal = document.getElementById("trayScanModal");
  if (modal) {
    modal.style.display = "none";
    modal.classList.remove("open");
  }
}

// ✅ UPDATED: Function to show editable rejection form with optional draft data
function showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, draftData) {
  // Get tray capacity from the row
  const trayCapacityText = row.cells[7]?.textContent || ''; // Tray Category-Capacity column
  const trayCapacity = trayCapacityText.includes('-') ?
                      parseInt(trayCapacityText.split('-')[1]) : 10; // Default to 10
  
  // Set data attribute for tray capacity
  row.setAttribute('data-tray-capacity', trayCapacity);
  

  
 // ✅ NEW: Draft mode styling and indicators
  const draftIndicator = ''; // Removed draft mode text
  const draftAlert = ''; // Removed draft mode alert text
  



// Always enable draft/cancel buttons after modal opens or validation
setTimeout(() => {
  const draftBtns = document.querySelectorAll(' #draftButton, #cancelButton');
  draftBtns.forEach(btn => {
    btn.disabled = false;
    btn.style.backgroundColor = btn.id === 'cancelButton' ? '#dc3545' : '#f39c12'; // Use your desired color
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
    btn.style.filter = 'none';
    btn.classList.remove('disabled');
  });
}, 100); // Delay ensures DOM is ready


  const headerColor = isDraftMode ? '#f39c12' : '#028084';
  const inputStyle = isDraftMode ? 'background-color: #fff3cd; border-color: #f39c12; border-width: 2px;' : '';
            detailsDiv.innerHTML = `
                ${draftAlert}
                <!-- ✅ UPDATED: Enhanced header section with better visual consistency -->
                <div class="d-flex justify-content-between align-items-center mb-3" style="padding: 5px !important; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 10px; border-left: 4px solid ${isDraftMode ? '#f39c12' : '#028084'}; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                  <h4 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 8px;">
                    Rejection Reason List${draftIndicator}
                  </h4>
                  
                  <div class="form-check d-flex align-items-center" style="margin: 0; padding: 3px 12px; background: #fff; border-radius: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                      <input class="form-check-input" type="checkbox" id="batchRejection"
                             style="width: 13px; height: 13px;margin-left: 0px !important; margin-right: 8px; accent-color: ${isDraftMode ? '#f39c12' : '#028084'};"
                             ${draftData && draftData.is_batch_rejection ? 'checked' : ''} />
                      <label class="form-check-label" for="batchRejection" style="font-size: 14px; font-weight: 600; color: #495057; margin: 0; cursor: pointer;">Lot Rejection</label>
                  </div>
                </div>
              
                <!-- ✅ REDESIGNED: Perfectly matched table with enhanced headers -->
                <div id="rejection-reasons-section" class="table-responsive"
style="max-height: 320px !important; border: 1px solid #dee2e6; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow: auto !important; ">
<table class="table table-bordered text-center mb-0" style="font-size: 13px; border-collapse: initial !important; border-color: black !important; border-spacing: 0; grid-column: 1 / -1;">
                    <thead style="background: linear-gradient(135deg, ${headerColor} 0%, ${isDraftMode ? '#e67e22' : '#0056b3'} 100%); position: relative;">
                      <tr style="border: 1px solid #282f3a;">
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            S.No
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 65px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            ID
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 12px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                            Rejection Reason
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 8px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); width: 75px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                            Qty
                          </div>
                        </th>
                        <th style="background-color: #028084 !important; padding: 12px 12px; font-size: 12px; font-weight: 700;border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); min-width: 150px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                          <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                            Tray ID(s)
                          </div>
                        </th>
                      </tr>
                      <!-- ✅ ADD: Subtle shadow line under header -->
                      <tr style="height: 2px; background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.1) 50%, transparent 100%);"><td colspan="5" style="padding: 0;border: 1px solid #282f3a;"></td></tr>
                    </thead>
                    <tbody id="rejection-table-body" style="background: #fff;">
                      {% for reason in ip_rejection_reasons %}
                      <tr data-batch-id="${batchId}" data-stock-lot-id="${stockLotId}" style="border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;">
                        <td style="padding: 8px 6px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4;">{{ forloop.counter }}</td>
                        <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 11px; font-weight: 700; border-right: 1px solid #f1f3f4; background: #fafbfc;">{{ reason.rejection_reason_id }}</td>
                        <td style="color: {{ reason.row_color }}; padding: 5px; font-size: 12px; text-align: left; font-weight: 500; border-right: 1px solid #f1f3f4;">{{ reason.rejection_reason }}</td>
                        <td style="padding: 6px; border-right: 1px solid #f1f3f4; background: #fafbfc;">
                          <input type="number"
                                 min="0"
                                 class="form-control rejection-qty-input"
                                 name="quantity_{{ forloop.counter }}"
                                 style="width: 65px; height: 25px !important; padding: 6px !important; font-size: 12px; text-align: center; border: 2px solid #e1e5e9; border-radius: 6px; font-weight: 600; transition: all 0.3s ease; ${inputStyle}"
                                 data-reason-id="{{ reason.rejection_reason_id }}"
                                 value="" />
                        </td>
                        <td style="vertical-align: middle; padding: 8px 12px; min-width: 150px; max-width: 200px; background: #fafbfc;">
                          <span style="color: #8e9aaf; font-style: italic; font-size: 11px; font-weight: 500;">Enter quantity first</span>
                        </td>
                      </tr>
                      {% endfor %}
                      <!-- ✅ ENHANCED: Total row with better styling -->
                      <tr style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-top: 3px solid ${isDraftMode ? '#f39c12' : '#028084'};">
                        <td colspan="4" style="text-align: right; font-weight: 700; padding: 12px 16px; font-size: 14px; color: #495057; border-right: 1px solid #dee2e6;">
                          <i class="fa fa-calculator" style="margin-right: 6px; color: ${isDraftMode ? '#f39c12' : '#028084'};"></i>
                          Total Qty
                        </td>
                        <td id="rejection-total-qty" style="font-weight: 700; padding: 12px 16px; font-size: 16px; color: #28a745; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); text-align: center;">0</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                
                <!-- ✅ ENHANCED: Better integrated remarks section -->
                <div id="lotRejectionRemarksSection" style="display: none; margin-top: 16px; padding: 16px; border: 2px solid #28a745; border-radius: 10px; background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%); box-shadow: 0 4px 8px rgba(40, 167, 69, 0.1);">
                  <div style="margin-bottom: 12px;">
                    <label style="font-weight: 700; color: #28a745; margin-bottom: 6px; display: block; font-size: 14px; display: flex; align-items: center; gap: 6px;">
                      <i class="fa fa-check-circle" style="font-size: 16px;"></i>
                      Lot Rejection Remarks (Required)
                    </label>
                    <textarea
                      id="lotRejectionRemarksInput"
                      placeholder="Please provide detailed reason for lot rejection..."
                      style="width: 100%; height: 70px; padding: 12px 16px; border: 2px solid #28a745; border-radius: 8px; font-size: 13px; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; transition: all 0.3s ease;"
                      maxlength="500"></textarea>
                    <div style="text-align: right; margin-top: 5px; font-size: 12px; color: #6c757d;">
                      <span id="remarksCharCount">0</span>/500 characters
                    </div>
                  </div>
                  <div style="font-size: 12px; color: #155724; background-color: #d4edda; padding: 5px; border-radius: 6px; border-left: 4px solid #28a745; display: flex; align-items: center; gap: 8px;">
                    <i class="fa fa-info-circle" style="font-size: 14px;"></i>
                    <span><strong>Note:</strong> Lot rejection remarks are mandatory when rejecting the entire lot.</span>
                  </div>
                </div>
                
                <div id="batchRejectionMsg" style="margin: 5px 0; color: #d32f2f; font-weight: 600; font-size: 13px; text-align: center; min-height: 20px;"></div>
              <!-- ✅ OLD SIMPLE BUTTON DESIGN -->
              <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                <button id="draftButton" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                  Draft
                </button>
                <button id="proceedButton" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                  Proceed
                </button>
                <button id="cancelButton" style="padding: 8px 16px; background: #dc3545 !important; color: white; border: none; border-radius: 30px;">
                  Cancel
                </button>
              </div>
              
              `;
              
              if (draftData) {
                loadDraftDataIntoForm(draftData);
              }

  // ✅ NEW: Add event listener for Lot Rejection checkbox
  const batchRejectionCheckbox = document.getElementById('batchRejection');
  const rejectionReasonsSection = document.getElementById('rejection-reasons-section');
  const lotRejectionRemarksSection = document.getElementById('lotRejectionRemarksSection');
  
  if (batchRejectionCheckbox) {
    // Set initial state based on checkbox status
    if (batchRejectionCheckbox.checked) {
      rejectionReasonsSection.style.display = 'none';
      lotRejectionRemarksSection.style.display = 'block';
    } else {
      rejectionReasonsSection.style.display = 'grid';
      lotRejectionRemarksSection.style.display = 'none';
    }

    batchRejectionCheckbox.addEventListener('change', function() {
      if (this.checked) {
        // When Lot Rejection is checked: Hide rejection reasons table, show only remarks section
        rejectionReasonsSection.style.display = 'none';
        lotRejectionRemarksSection.style.display = 'block';
        
        // Clear all rejection reason quantities when switching to lot rejection
        const qtyInputs = document.querySelectorAll('.rejection-qty-input');
        qtyInputs.forEach(input => {
          input.value = '';
        });
        
        // Update total quantity to 0
        const totalQtyElement = document.getElementById('rejection-total-qty');
        if (totalQtyElement) {
          totalQtyElement.textContent = '0';
        }
      } else {
        // When Lot Rejection is unchecked: Show rejection reasons table, hide remarks section
        rejectionReasonsSection.style.display = 'grid';
        lotRejectionRemarksSection.style.display = 'none';
        
        // Clear lot rejection remarks when switching back
        const lotRemarksInput = document.getElementById('lotRejectionRemarksInput');
        if (lotRemarksInput) {
          lotRemarksInput.value = '';
        }
      }
    });
  }

  // Add the updated event listeners for the editable form
  addEditableFormEventListeners(row, batchId, stockLotId);
  
  // ✅ CRITICAL FIX: Attach draft button event listeners AFTER DOM insertion
  setTimeout(function() {
    console.log('🔧 [showEditableRejectionFormWithData] Attaching button event listeners');
    
    const draftButton = document.getElementById('draftButton');
    const proceedButton = document.getElementById('proceedButton');
    const cancelButton = document.getElementById('cancelButton');
    
    if (draftButton) {
      // Remove all existing listeners by cloning
      const newDraftButton = draftButton.cloneNode(true);
      draftButton.parentNode.replaceChild(newDraftButton, draftButton);
      
      newDraftButton.addEventListener('click', () => {
        console.log('🔄 [draftButton] Manual draft save triggered for lot:', stockLotId);
        window.isManualDraftMode = true;
        console.log('✅ [draftButton] Set isManualDraftMode =', window.isManualDraftMode);
        handleDraftSave();
      });
      console.log('✅ [showEditableRejectionFormWithData] Draft button listener attached');
    } else {
      console.log('❌ [showEditableRejectionFormWithData] Draft button NOT found');
    }
    
    if (proceedButton) {
      const newProceedButton = proceedButton.cloneNode(true);
      proceedButton.parentNode.replaceChild(newProceedButton, proceedButton);
      
      newProceedButton.addEventListener('click', () => {
        console.log('🔄 [proceedButton] Proceed clicked for lot:', stockLotId);
        // ✅ FIXED: Call handleProceed function to process the rejection
        const isDraftMode = row.getAttribute('data-few-cases-acceptance') === 'True';
        handleProceed(stockLotId, batchId, isDraftMode);
      });
      console.log('✅ [showEditableRejectionFormWithData] Proceed button listener attached');
    }
    
    if (cancelButton) {
      const newCancelButton = cancelButton.cloneNode(true);
      cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
      
      newCancelButton.addEventListener('click', () => {
        window.location.reload();
        modal.style.display = 'none';
        console.log('🔄 [cancelButton] Cancel clicked for lot:', stockLotId);
        // Handle cancel logic here
      });
      console.log('✅ [showEditableRejectionFormWithData] Cancel button listener attached');
    }
    
    // ✅ NEW: Ensure instant validation is attached to all tray inputs after form loads
    setTimeout(() => {
      console.log('🔧 [showEditableRejectionFormWithData] Re-attaching validation to all tray inputs');
      const allRejectionRows = document.querySelectorAll('#rejectionTableBody tr');
      allRejectionRows.forEach(row => {
        const trayIdCell = row.querySelector('td:nth-child(5)'); // Tray ID column
        if (trayIdCell) {
          addInstantTrayValidationToInputs(trayIdCell);
        }
      });
      console.log('✅ [showEditableRejectionFormWithData] Validation re-attached to all rows');
    }, 200);
    
    forceEnableRejectionDraftButtons();
    console.log('✅ [showEditableRejectionFormWithData] All button event listeners applied');
  }, 100); // Increased timeout to ensure DOM is ready
}


     // ✅ FIXED: Enhanced loadDraftDataIntoForm function - Make globally accessible
window.loadDraftDataIntoForm = function(draftData) {
  console.log('🔄 [loadDraftDataIntoForm] Loading draft data:', draftData);
  
  // ✅ FIRST: Load batch rejection state and show remarks section if needed
  if (draftData.is_batch_rejection) {
    console.log('✅ Loading batch rejection draft with remarks');
    
    const batchCheckbox = document.getElementById("batchRejection");
    if (batchCheckbox) {
      batchCheckbox.checked = true;
      console.log('✅ Set batch rejection checkbox to true');
      
      // ✅ CRITICAL: Show the lot rejection remarks section immediately
      const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
      if (lotRejectionRemarksSection) {
        lotRejectionRemarksSection.style.display = "block";
        lotRejectionRemarksSection.style.opacity = "1";
        lotRejectionRemarksSection.style.transform = "translateY(0)";
        console.log('✅ Showed lot rejection remarks section');
      }
      
      // ✅ FIXED: Load the draft remarks
      const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
      if (lotRejectionRemarksInput) {
        const remarksValue = draftData.lot_rejection_remarks || '';
        lotRejectionRemarksInput.value = remarksValue;
        console.log('✅ Set remarks value:', remarksValue);
        
        // Update character count
        const remarksCharCount = document.getElementById("remarksCharCount");
        if (remarksCharCount) {
          remarksCharCount.textContent = remarksValue.length;
          
          // Update character count color
          if (remarksValue.length > 450) {
            remarksCharCount.style.color = "#dc3545";
          } else if (remarksValue.length > 350) {
            remarksCharCount.style.color = "#ffc107";
          } else {
            remarksCharCount.style.color = "#28a745";
          }
        }
        
        // Trigger input event to ensure any other listeners are notified
        lotRejectionRemarksInput.dispatchEvent(new Event('input'));
      }
      
      // Disable quantity inputs for lot rejection
      document.querySelectorAll('.rejection-qty-input').forEach(input => {
        input.disabled = true;
        input.value = ""; // Clear values
      });
      document.getElementById('rejection-total-qty').textContent = "0";
      console.log('✅ Disabled quantity inputs for batch rejection');
    }
  }
  
  // Load rejection quantities (only if not batch rejection)
  if (!draftData.is_batch_rejection && draftData.rejection_data && draftData.rejection_data.length > 0) {
    console.log('✅ Loading individual rejection data');
    
    draftData.rejection_data.forEach(item => {
      const input = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
      if (input) {
        input.value = item.qty;
        input.style.backgroundColor = '#fff3cd';
        input.style.borderColor = '#f39c12';
        input.style.borderWidth = '2px';
        
        // Trigger input event to generate tray ID fields
        input.dispatchEvent(new Event('input'));
        console.log(`✅ Set quantity ${item.qty} for reason ${item.reason_id}`);
      }
    });
    
    // Update total
    const totalQty = draftData.total_rejection_qty || 0;
    document.getElementById('rejection-total-qty').textContent = totalQty;
    console.log('✅ Set total rejection qty:', totalQty);
  }
  
  // ✅ FIXED: Load tray scans for non-batch rejections
  if (!draftData.is_batch_rejection && draftData.tray_scans && draftData.tray_scans.length > 0) {
    // Wait for tray inputs to be generated
    setTimeout(() => {
      console.log('✅ Loading tray scans:', draftData.tray_scans);
      
      // ✅ NEW: Group tray scans by reason_id first
      const traysByReason = {};
      draftData.tray_scans.forEach(scan => {
        const reasonId = scan.reason_id;
        if (!traysByReason[reasonId]) {
          traysByReason[reasonId] = [];
        }
        traysByReason[reasonId].push(scan);
      });
      
      console.log('📦 Grouped trays by reason:', traysByReason);
      
      // ✅ FIXED: Load trays for each reason
      Object.keys(traysByReason).forEach(reasonId => {
        const traysForReason = traysByReason[reasonId];
        console.log(`🎯 Loading ${traysForReason.length} trays for reason ${reasonId}`);
        
        // Find the row for this reason
        const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"]`);
        if (qtyInput) {
          const row = qtyInput.closest('tr');
          const trayIdCell = row.querySelector('td:last-child');
          
          if (trayIdCell) {
            const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
            console.log(`Found ${trayInputs.length} tray inputs for reason ${reasonId}`);
            
            // ✅ FIXED: Load each tray into the corresponding input
            traysForReason.forEach((scan, index) => {
              if (index < trayInputs.length) {
                const trayInput = trayInputs[index];
                const trayCapacity = parseInt(trayInput.getAttribute('data-tray-capacity')) || 0;
                if (trayInput && trayInput.value !== undefined) {
                  trayInput.value = scan.tray_id;
                  console.log(`✅ Set tray ${index + 1}: ${scan.tray_id} (qty: ${scan.tray_qty}, capacity: ${trayCapacity})`);
                } else {
                  console.warn('⚠️ [loadDraftDataIntoForm] Tray input is null or invalid at index', index);
                  return;
                }

                // ✅ FIXED: First check if this tray was previously validated by backend
                setTimeout(async () => {
                  try {
                    // Check backend validation status for this tray
                    const lotId = document.querySelector('[data-stock-lot-id]')?.getAttribute('data-stock-lot-id');
                    if (lotId) {
                      const response = await fetch(`/inputscreening/reject_check_tray_id_simple/?tray_id=${encodeURIComponent(scan.tray_id)}&lot_id=${encodeURIComponent(lotId)}&rejection_qty=${scan.tray_qty}&rejection_reason_id=${reasonId}&current_session_allocations=[]&is_draft=true`);
                      const data = await response.json();
                      
                      // ✅ CRITICAL FIX: Store complete backend response data for frontend validation
                      trayInput._backendResponseData = data;
                      console.log(`✅ [loadDraftDataIntoForm] Stored complete backend response data for frontend validation on ${scan.tray_id}`);
                      
                      // ✅ GLOBAL FIX: Store available quantities globally for all tray validations in this lot
                      if (data.available_quantities) {
                        window.currentLotAvailableQuantities = Array.isArray(data.available_quantities) 
                          ? data.available_quantities 
                          : Array.from(data.available_quantities);
                        console.log(`✅ [loadDraftDataIntoForm] Stored global available quantities: [${window.currentLotAvailableQuantities.join(', ')}] for lot ${lotId}`);
                      }
                      
                      if (data.success && data.message === 'Perfect capacity match!') {
                        // Mark as backend validated and show success state
                        trayInput._isBackendValidated = true;
                        trayInput._isValid = true;
                        trayInput.style.backgroundColor = '#d4edda';
                        trayInput.style.borderColor = '#28a745';
                        trayInput.style.borderWidth = '2px';
                        
                        // ✅ NEW: Store actual tray quantity from backend response
                        if (data.tray_actual_quantity) {
                          trayInput._backendTrayQuantity = data.tray_actual_quantity;
                          console.log(`✅ [loadDraftDataIntoForm] Stored backend tray quantity: ${data.tray_actual_quantity} for ${scan.tray_id}`);
                        }
                        
                        // Update error span with success message
                        const errorSpan = trayInput.parentElement?.parentElement?.querySelector('.rejection-tray-error');
                        if (errorSpan) {
                          errorSpan.innerHTML = '✅ Valid for re-use - Perfect capacity match';
                          errorSpan.style.display = 'block';
                          errorSpan.style.color = '#155724';
                          errorSpan.style.backgroundColor = '#d4edda';
                          errorSpan.style.border = '1px solid #c3e6cb';
                          errorSpan.style.padding = '6px 10px';
                          errorSpan.style.borderRadius = '4px';
                          errorSpan.style.fontSize = '12px';
                          errorSpan.style.fontWeight = '500';
                          errorSpan.style.marginTop = '4px';
                        }
                        console.log(`✅ [loadDraftDataIntoForm] Backend validated ${scan.tray_id} as valid`);
                      } else {
                        // Show draft styling for invalid/unvalidated trays
                        trayInput.style.backgroundColor = '#fff3cd';
                        trayInput.style.borderColor = '#f39c12';
                        trayInput.style.borderWidth = '2px';
                        
                        // ✅ NEW: Extract actual tray quantity from error message for accurate validation
                        if (data.error && data.error.includes('but tray has')) {
                          const match = data.error.match(/but tray has (\d+) pieces/);
                          if (match) {
                            const actualQty = parseInt(match[1]);
                            trayInput._extractedTrayQuantity = actualQty;
                            console.log(`✅ [loadDraftDataIntoForm] Extracted actual tray quantity from error: ${actualQty} for ${scan.tray_id}`);
                          }
                        }
                        
                        console.log(`⚠️ [loadDraftDataIntoForm] Backend validation failed for ${scan.tray_id}:`, data.error || 'Unknown error');
                      }
                    } else {
                      // No lot ID available, use draft styling
                      trayInput.style.backgroundColor = '#fff3cd';
                      trayInput.style.borderColor = '#f39c12';
                      trayInput.style.borderWidth = '2px';
                    }
                    
                    // Trigger validation after status check to update proceed button
                    setTimeout(() => {
                      if (typeof validateDuplicateTrayIds === 'function') {
                        validateDuplicateTrayIds();
                      }
                      if (typeof updateFormValidationState === 'function') {
                        updateFormValidationState();
                      }
                    }, 100);
                    
                  } catch (error) {
                    console.warn('⚠️ Failed to validate draft tray:', error);
                    // Fallback to draft styling
                    trayInput.style.backgroundColor = '#fff3cd';
                    trayInput.style.borderColor = '#f39c12';
                    trayInput.style.borderWidth = '2px';
                  }
                }, 100);
                
                console.log(`  ✅ Set tray ${index + 1}: ${scan.tray_id} (qty: ${scan.tray_qty})`);
                
                // ✅ NEW: Update the data-tray-qty attribute to match the saved quantity
                if (scan.tray_qty) {
                  trayInput.setAttribute('data-tray-qty', scan.tray_qty);
                }
              } else {
                console.log(`  ⚠️ No input available for tray ${index + 1}: ${scan.tray_id}`);
              }
            });
            
            // ✅ NEW: If we have more trays than inputs, something is wrong with the generation
            if (traysForReason.length > trayInputs.length) {
              console.warn(`⚠️ Mismatch: ${traysForReason.length} saved trays but only ${trayInputs.length} inputs for reason ${reasonId}`);
              
              // ✅ FIXED: Regenerate tray inputs with correct count
              const qtyValue = parseInt(qtyInput.value) || 0;
              if (qtyValue > 0) {
                console.log(`🔧 Regenerating tray inputs for reason ${reasonId} with qty ${qtyValue}`);
                generateDynamicTrayIdInputs(row, qtyValue, trayIdCell);
                
                // Wait a bit and try loading again
                setTimeout(() => {
                  const newTrayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
                  console.log(`🔄 After regeneration: ${newTrayInputs.length} inputs available`);
                  
                  traysForReason.forEach((scan, index) => {
                    if (index < newTrayInputs.length) {
                      const trayInput = newTrayInputs[index];
                      if (trayInput && trayInput.value !== undefined) {
                        trayInput.value = scan.tray_id;
                        // Immediately trigger validation for loaded value
                        trayInput.dispatchEvent(new Event('input', { bubbles: true }));
                        trayInput.dispatchEvent(new Event('blur', { bubbles: true }));
                        trayInput.style.backgroundColor = '#fff3cd';
                        trayInput.style.borderColor = '#f39c12';
                        trayInput.style.borderWidth = '2px';
                        
                        if (scan.tray_qty) {
                          trayInput.setAttribute('data-tray-qty', scan.tray_qty);
                        }
                        
                        console.log(`  🔄 Re-loaded tray ${index + 1}: ${scan.tray_id}`);
                      } else {
                        console.warn('⚠️ [loadDraftDataIntoForm] Tray input is null or invalid at index', index);
                      }
                    }
                  });
                }, 100);
              }
            }
          }
        }
      });
    }, 500); // Wait for tray inputs to be generated
  }
  
  console.log('✅ [loadDraftDataIntoForm] Draft loading completed');
  
  // Set draft mode flag
  window.isDraftMode = true;
  
  // ✅ CRITICAL: Trigger validation to restore dynamic alerts after loading
  setTimeout(() => {
    console.log('🔄 [loadDraftDataIntoForm] Triggering validation to restore dynamic alerts');
    // Trigger duplicate validation to show proper alerts
    const isDuplicateValid = validateDuplicateTrayIds();
    console.log(`✅ [loadDraftDataIntoForm] Post-load validation completed: valid=${isDuplicateValid}`);
  }, 2000); // Increased delay to ensure async API calls complete and set global data
  
  // ✅ CRITICAL FIX: Force enable draft buttons after loading draft data
  setTimeout(function() {
    forceEnableRejectionDraftButtons();
    console.log('✅ [loadDraftDataIntoForm] Force-enabled draft buttons after loading data');
    
    // ✅ NEW: Update form validation state to enable proceed button if all trays are valid
    setTimeout(() => {
      if (typeof updateFormValidationState === 'function') {
        updateFormValidationState();
        console.log('✅ [loadDraftDataIntoForm] Updated form validation state after draft load');
      }
    }, 500);
  }, 100);
  
  // ✅ NEW FIX: Re-fetch and restore verification symbols for validated tray IDs
  setTimeout(async function() {
    try {
      // Get the current lot_id from the modal or form
      const stockLotId = document.querySelector('[data-stock-lot-id]')?.getAttribute('data-stock-lot-id');
      if (!stockLotId) {
        console.log('⚠️ No lot_id found, skipping verification symbol restoration');
        return;
      }
      
      console.log('🔄 Fetching verification status to restore symbols for lot:', stockLotId);
      
      // Fetch verification status from backend
      const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
      const verifyResult = await verifyResp.json();
      
      if (verifyResult.success && verifyResult.verification_data) {
        const verificationData = verifyResult.verification_data;
        console.log('✅ Fetched verification data:', verificationData);
        
        // Update verification indicators for all validated trays
        Object.keys(verificationData).forEach(position => {
          const verification = verificationData[position];
          if (verification.is_verified) {
            // Find the input at this position in the tray validate modal
            const trayInput = document.querySelector(`input[data-position="${position}"]`);
            if (trayInput) {
              const parentTd = trayInput.closest('td');
              if (parentTd) {
                // Find or create verification indicator
                let indicator = parentTd.querySelector('small');
                if (indicator) {
                  // Update existing indicator
                  indicator.style.color = '#28a745';
                  indicator.style.fontWeight = 'bold';
                  indicator.innerHTML = '✓ Verified';
                } else {
                  // Create new indicator if not found
                  indicator = document.createElement('small');
                  indicator.style.color = '#28a745';
                  indicator.style.fontWeight = 'bold';
                  indicator.innerHTML = '✓ Verified';
                  parentTd.appendChild(indicator);
                }
                
                // Update input styling to show it's verified
                trayInput.style.backgroundColor = '#f5f5f5';
                trayInput.style.borderColor = '#28a745';
                trayInput.style.color = '#155724';
                trayInput.value = verification.tray_id || trayInput.value;
                
                console.log(`✅ Restored verification symbol for position ${position}: ${verification.tray_id}`);
              }
            }
          }
        });
        
        console.log('✅ Verification symbols restored successfully');
      }
    } catch (error) {
      console.error('❌ Error restoring verification symbols:', error);
    }
  }, 600); // Wait for draft data to be fully loaded
}
   
   // ✅ UPDATED: Function to add event listeners WITH draft functionality
     function addEditableFormEventListeners(row, batchId, stockLotId) {
       // Get tray capacity from the row data
       const trayCapacity = parseInt(row.getAttribute('data-tray-capacity')) || 10;
       console.log('Tray capacity:', trayCapacity);
   
       // Quantity validation with dynamic tray scan generation
       const availableQty = parseInt(row.getAttribute('data-available-qty'), 10) || 0;        
   
       // Enhanced quantity validation with proactive limiting
       // ✅ UPDATED: Enhanced quantity validation with dynamic tray ID generation
   document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
   // Real-time validation on input
   input.addEventListener('input', function() {
   const currentInput = this;
   const currentValue = parseInt(currentInput.value) || 0;
   const row = currentInput.closest('tr');
   const trayIdCell = row.querySelector('td:last-child'); // Tray ID column
   
   // Remove all previous qty errors
   document.querySelectorAll('.qty-error').forEach(function(span) { span.remove(); });
   
   // Calculate total from all OTHER inputs (excluding current)
   let totalFromOthers = 0;
   let hasQuantity = false;
   
   allInputs.forEach(function(otherInput) {
     if (otherInput !== currentInput) {
       const val = parseInt(otherInput.value) || 0;
       totalFromOthers += val;
       if (val > 0) hasQuantity = true;
     }
   });
   
   // Calculate maximum allowed value for current input
   const maxAllowed = Math.max(0, availableQty - totalFromOthers);
   
   // If current value exceeds maximum allowed, automatically adjust it
   if (currentValue > maxAllowed) {
     currentInput.value = maxAllowed;
     
     // Show helpful message
     let helpSpan = document.createElement('span');
     helpSpan.className = 'qty-help';
     helpSpan.style.color = '#f39c12';
     helpSpan.style.fontSize = '12px';
     helpSpan.style.display = 'block';
     helpSpan.style.marginTop = '2px';
     helpSpan.textContent = `Max allowed: ${maxAllowed} (Total limit: ${availableQty})`;
     currentInput.parentElement.appendChild(helpSpan);
     
     // Auto-hide the help message after 3 seconds
     setTimeout(() => {
       if (helpSpan.parentNode) {
         helpSpan.parentNode.removeChild(helpSpan);
       }
     }, 3000);
   }
   
   // Get final adjusted value
   const adjustedValue = parseInt(currentInput.value) || 0;
   const finalTotal = totalFromOthers + adjustedValue;
   
   // ✅ NEW: Generate dynamic tray ID inputs based on quantity
   generateDynamicTrayIdInputs(row, adjustedValue, trayIdCell);
   
   // ✅ Check tray capacity violations after generating tray inputs
   setTimeout(() => {
     const capacityViolation = validateAllTrayCapacities();
     if (capacityViolation) {
       console.log('❌ Capacity violation detected after tray input generation:', capacityViolation);
       showErrorMessage(capacityViolation);
     }
   }, 200); // Wait for tray inputs to be fully generated
   
   // Update total display
   document.getElementById('rejection-total-qty').textContent = finalTotal;
   
   // Always recalculate the sum from all rejection-qty-input fields
   const lotRejectionCheckbox = document.getElementById('batchRejection');
   if (lotRejectionCheckbox) {
     let totalQty = 0;
     document.querySelectorAll('.rejection-qty-input').forEach(function(input) {
       const val = parseInt(input.value, 10) || 0;
       totalQty += val;
     });
     if (window.currentLotQty && totalQty === window.currentLotQty) {
       if (!lotRejectionCheckbox.checked) {
         lotRejectionCheckbox.checked = true;
         lotRejectionCheckbox.dispatchEvent(new Event('change'));
       }
     } else {
       if (lotRejectionCheckbox.checked) {
         lotRejectionCheckbox.checked = false;
         lotRejectionCheckbox.dispatchEvent(new Event('change'));
       }
     }
   }
   });
   });
   
   // ✅ SIMPLIFIED: Calculate required trays based on standard capacity
   function calculateRequiredTrays(rejectionQty, trayCapacity = 16) {
   if (rejectionQty <= 0) {
   return [];
   }
   
   const traysNeeded = Math.ceil(rejectionQty / trayCapacity);
   const traysWithQuantity = [];
   let remainingQty = rejectionQty;
   
   for (let i = 0; i < traysNeeded; i++) {
   const qtyForThisTray = Math.min(remainingQty, trayCapacity);
   traysWithQuantity.push({
     trayIndex: i,
     trayCapacity: trayCapacity,
     trayQty: qtyForThisTray,
     isTopTray: i === 0,
     isComplete: qtyForThisTray === trayCapacity,
     isPartial: qtyForThisTray < trayCapacity
   });
   remainingQty -= qtyForThisTray;
   }
   
   console.log(`✅ Simplified calculation for qty ${rejectionQty} with capacity ${trayCapacity}:`, 
   traysWithQuantity.map(t => `Tray ${t.trayIndex + 1}: ${t.trayQty}/${t.trayCapacity}`).join(', '));
   return traysWithQuantity;
   }
   
   
   // ✅ FIXED: Corrected column indices for proper tray distribution
   function getActualTrayQuantitiesForCurrentLot() {
   const modal = document.getElementById("trayScanModal");
   const currentRow = document.querySelector('tr.highlighted-tray-scan');
   
   if (currentRow) {
   // Option 1: Get from data attribute if available
   const trayQtyList = currentRow.getAttribute('data-tray-qty-list');
   if (trayQtyList) {
     try {
       const parsed = JSON.parse(trayQtyList);
       if (parsed && parsed.length > 0) {
         console.log('Found actual tray quantities:', parsed);
         return parsed;
       }
     } catch (e) {
       console.log('Could not parse tray qty list:', e);
     }
   }
   
   // Option 2: Get from modal data if available
   if (modal && modal.traysData && modal.traysData.length > 0) {
     const actualQties = modal.traysData.map(tray => tray.tray_quantity || 0);
     console.log('Found actual tray quantities from modal:', actualQties);
     return actualQties;
   }
   }
   
   // Option 3: Fallback - Return standard capacity array for rejection calculation
   const trayCapacityText = currentRow?.cells[7]?.textContent || '';
   const standardCapacity = trayCapacityText.includes('-') ? 
                         parseInt(trayCapacityText.split('-')[1]) : 12;
   
   console.log(`Fallback: Using standard capacity ${standardCapacity} for rejection calculation`);
   
   // ✅ FIXED: For rejection scenarios, return an array of standard capacities
   // This allows the rejection calculation to work with standard tray sizes
   return Array(10).fill(standardCapacity); // Return 10 trays of standard capacity
   }
   
   // ✅ CORRECTED: Calculate complete tray rejections based on ACTUAL tray distribution
   function calculateCompleteTraysFromActualDistribution(rejectionQty) {
   const actualTrayQties = getActualTrayQuantitiesForCurrentLot();
   const traysWithQuantity = [];
   let remainingQty = rejectionQty;
   
   console.log(`Calculating trays for rejection qty: ${rejectionQty}`);
   console.log(`Actual tray distribution: [${actualTrayQties.join(', ')}]`);
   
   // Go through trays in order (top tray first)
   for (let i = 0; i < actualTrayQties.length && remainingQty > 0; i++) {
   const trayCapacity = actualTrayQties[i];
   const qtyForThisTray = Math.min(remainingQty, trayCapacity);
   
   // ✅ NEW: Include ANY tray that gets some quantity (complete OR partial)
   traysWithQuantity.push({
     trayIndex: i,
     trayCapacity: trayCapacity,
     trayQty: qtyForThisTray,
     isTopTray: i === 0,
     isComplete: qtyForThisTray === trayCapacity,
     isPartial: qtyForThisTray < trayCapacity
   });
   
   remainingQty -= qtyForThisTray;
   
   console.log(`  Tray ${i + 1}: ${qtyForThisTray}/${trayCapacity} qty (${qtyForThisTray === trayCapacity ? 'Complete' : 'Partial'})`);
   }
   
   const result = {
   traysWithQuantity: traysWithQuantity,
   totalQtyDistributed: rejectionQty - remainingQty,
   // Only skip tray scanning for partial top tray (not complete)
   needsTrayScanning: traysWithQuantity.length > 0 && !(traysWithQuantity.length === 1 && traysWithQuantity[0].isPartial)
   };
   
   console.log(`Result:`, result);
   return result;
   }
   

// ✅ ENHANCED: Improved generateDynamicTrayIdInputs to ensure proper count
function generateDynamicTrayIdInputs(row, quantity, trayIdCell) {
  // Get current reason to check if it's SHORTAGE
  const reasonCell = row.cells[2];
  const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
  const reasonId = row.querySelector('.rejection-qty-input').getAttribute('data-reason-id');
  
  // Clear existing tray ID inputs
  trayIdCell.innerHTML = '';
  
  if (quantity <= 0) {
    trayIdCell.innerHTML = '<span style="color: #999; font-style: italic;">Enter quantity first</span>';
    return;
  }
  
  if (reasonText === 'SHORTAGE') {
    trayIdCell.innerHTML = '<span style="color: #666; font-style: italic;">N/A (Shortage)</span>';
    return;
  }
  
  // ✅ FIXED: Use direct calculation instead of complex distribution logic
  const currentRow =  document.querySelector('tr.highlighted-tray-scan') || 
                      document.querySelector('[data-stock-lot-id]') ||
                      document.querySelector('tbody tr');
  let trayCapacity = 16; // Default to Normal capacity
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      // ✅ ENHANCED: Use proper default based on tray type
      const trayTypeName = trayCapacityText.split('-')[0]?.toLowerCase() || '';
      const defaultCapacity = trayTypeName.includes('jumbo') ? 12 : 16;
      trayCapacity = parseInt(trayCapacityText.split('-')[1]) || defaultCapacity;
    }
  }
  
  // ✅ FIXED: Simple calculation - exactly what you expect!
  const traysNeeded = Math.ceil(quantity / trayCapacity);
  
  console.log(`🔧 Generating tray inputs for qty: ${quantity}, capacity: ${trayCapacity}, traysNeeded: ${traysNeeded}`);
  
  // Generate tray ID inputs for required trays
  const trayIdContainer = document.createElement('div');
  trayIdContainer.className = 'tray-id-container';
  trayIdContainer.style.cssText = `
    display: flex; flex-direction: column; gap: 6px; padding: 8px;
    background-color: #f8f9fa; border: 2px solid #007bff; border-radius: 8px;z-index: 9 !important;
  `;
  
  // Add header for tray container
  const headerDiv = document.createElement('div');
  headerDiv.style.cssText = `
    font-weight: bold; font-size: 12px; color: #007bff; margin-bottom: 4px;
    text-align: center; border-bottom: 1px solid #007bff; padding-bottom: 4px;z-index: 9 !important;
  `;
  headerDiv.textContent = `${traysNeeded} Tray${traysNeeded > 1 ? 's' : ''} Required`;
  trayIdContainer.appendChild(headerDiv);
  
  // Generate inputs for all required trays
  for (let i = 0; i < traysNeeded; i++) {
    let remainingQty = quantity - (i * trayCapacity);
    let trayQty = Math.min(trayCapacity, remainingQty);
    
    const trayInputGroup = document.createElement('div');
    trayInputGroup.style.cssText = `
      display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
      padding: 6px; background-color: #ffffff; border: 1px solid #dee2e6;
      border-radius: 6px; transition: all 0.2s ease;
    `;
    
    // Tray number indicator
    const trayNumber = document.createElement('span');
    trayNumber.style.cssText = `
      font-size: 11px; font-weight: bold; color: #007bff;
      background-color: #e3f2fd; padding: 4px 8px; border-radius: 12px;
      min-width: 24px; text-align: center; border: 1px solid #2196f3;
    `;
    trayNumber.textContent = `${i + 1}`;
    
    // Tray ID input
    const trayInput = document.createElement('input');
    trayInput.type = 'text';
    trayInput.className = 'form-control rejection-tray-id-input';
    trayInput.style.cssText = `
      flex: 1; font-size: 12px; padding: 6px 10px;
      border: 2px solid #ced4da; border-radius: 6px;
      transition: all 0.2s ease; text-align: left; font-weight: 500;
    `;
    trayInput.placeholder = `Scan Tray ID ${i + 1}`;
    
    // Set data attributes
    trayInput.setAttribute('data-tray-index', i);
    trayInput.setAttribute('data-tray-capacity', trayCapacity);
    trayInput.setAttribute('data-tray-qty', trayQty);
    trayInput.setAttribute('data-is-complete', trayQty === trayCapacity);
    trayInput.setAttribute('data-is-partial', trayQty < trayCapacity);
    trayInput.setAttribute('data-reason-id', reasonId);
    trayInput.setAttribute('data-rejection-qty', quantity);
    trayInput.setAttribute('data-rejection-reason', reasonText);
    trayInput.setAttribute('data-expected-total-trays', traysNeeded);
    trayInput.setAttribute('data-tray-position-in-rejection', i + 1);
    
    // ✅ NEW: Add event listeners for duplicate validation
    trayInput.addEventListener('change', function() {
      setTimeout(() => {
        validateDuplicateTrayIds();
      }, 100);
    });
    
    trayInput.addEventListener('paste', function() {
      setTimeout(() => {
        validateDuplicateTrayIds();
      }, 200);
    });
    
    // Error span for this specific tray
    const errorSpan = document.createElement('span');
    errorSpan.className = 'rejection-tray-error';
    
        errorSpan.style.cssText = `
          color: #dc3545; font-size: 10px; display: none;
          background: #ffd6d6; border: 1px solid #dc3545;
          border-radius: 4px; padding: 4px 8px; margin-top: 4px;
          width: 100%; box-sizing: border-box;
        `;
    
    
    // Container for input group with error message below
    trayInputGroup.style.flexDirection = 'column';
    trayInputGroup.style.alignItems = 'stretch';
    
    // Inner wrapper for tray number and input (horizontal)
    const trayInputRow = document.createElement('div');
    trayInputRow.style.cssText = `
      display: flex; align-items: center; gap: 8px;
    `;
    
    trayInputRow.appendChild(trayNumber);
    trayInputRow.appendChild(trayInput);
    
    trayInputGroup.appendChild(trayInputRow);
    trayInputGroup.appendChild(errorSpan);
    
    trayIdContainer.appendChild(trayInputGroup);
  }
  
  // Add summary footer
  const footerDiv = document.createElement('div');
  footerDiv.style.cssText = `
    font-size: 10px; color: #6c757d; text-align: center;
    margin-top: 6px; padding-top: 6px; border-top: 1px solid #dee2e6; font-style: italic;
  `;
  footerDiv.textContent = `Total quantity: ${quantity} across ${traysNeeded} tray${traysNeeded > 1 ? 's' : ''}`;
  trayIdContainer.appendChild(footerDiv);
  
  trayIdCell.appendChild(trayIdContainer);
  
  // ✅ INSTANT VALIDATION: Add real-time validation to all tray inputs
  addInstantTrayValidationToInputs(trayIdCell);
  
  // ✅ FALLBACK: Direct event listener attachment for immediate validation
  setTimeout(() => {
    trayIdCell.querySelectorAll('.rejection-tray-id-input').forEach(input => {
      console.log('🔧 [Fallback] Setting up direct validation for:', input);
      
      // Direct validation without function wrapper
      input.addEventListener('input', function() {
        console.log('🔧 [Fallback] Direct input event:', this.value);
        
        // Visual feedback that input is working
        this.style.borderColor = '#007bff';
        this._isValid = false;
        
        if (this.value.trim()) {
          // Simple validation call
          setTimeout(() => {
            console.log('🔧 [Fallback] Calling validation for:', this.value.trim());
            validateTrayIdSimple(this, this.value.trim());
            
            // ✅ Check capacity violation after tray ID validation (fallback)
            const capacityViolation = validateAllTrayCapacities();
            if (capacityViolation) {
              console.log('❌ [Fallback] Capacity violation detected:', capacityViolation);
              showErrorMessage(capacityViolation);
            }
          }, 300);
        } else {
          // Empty input - reset state
          this.style.borderColor = '#ced4da';
          this.style.backgroundColor = '#ffffff';
          this._isValid = false;
          
          // ✅ FIX: Go up to trayInputGroup to find error span
          const errorSpan = this.parentElement.parentElement.querySelector('.rejection-tray-error');
          if (errorSpan) {
            errorSpan.style.display = 'none';
          }
          
          // ✅ Check capacity violations when tray ID is cleared
          setTimeout(() => {
            const capacityViolation = validateAllTrayCapacities();
            if (capacityViolation) {
              console.log('❌ [Fallback] Capacity violation detected after clearing tray ID:', capacityViolation);
              showErrorMessage(capacityViolation);
            }
          }, 100);
          
          updateFormValidationState();
        }
      });
      
      // Test basic input functionality
      input.addEventListener('keyup', function() {
        console.log('🔧 [Fallback] Keyup event:', this.value);
      });
    });
  }, 100);
  
  console.log(`✅ Generated ${traysNeeded} tray inputs for reason ${reasonId}`);
  
  // ✅ DEBUGGING: Log all created inputs for verification
  setTimeout(() => {
    const createdInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
    console.log('🔧 [DEBUG] Verification - Created inputs count:', createdInputs.length);
    createdInputs.forEach((input, idx) => {
      console.log(`🔧 [DEBUG] Input ${idx + 1}:`, {
        element: input,
        className: input.className,
        placeholder: input.placeholder,
        disabled: input.disabled,
        readonly: input.readOnly
      });
    });
  }, 50);
}

// ✅ UPDATED: Duplicate Tray ID Detection with proper capacity validation
function validateDuplicateTrayIds() {
  // Only check for duplicate tray IDs and mark errors, no tray re-use or perfect quantity logic
  const duplicates = new Map();
  const allTrayInputs = document.querySelectorAll('.rejection-tray-id-input');

  // Clear previous duplicate errors
  allTrayInputs.forEach(input => {
    input.classList.remove('duplicate-error');
    const errorSpan = input.parentElement?.parentElement?.querySelector('.rejection-tray-error');
    if (errorSpan && errorSpan.textContent.includes('Duplicate')) {
      errorSpan.style.display = 'none';
      errorSpan.textContent = '';
    }
  });

  // Collect all non-empty tray IDs
  allTrayInputs.forEach((input, index) => {
    const trayId = input.value.trim().toUpperCase();
    if (trayId) {
      if (!duplicates.has(trayId)) {
        duplicates.set(trayId, []);
      }
      duplicates.get(trayId).push({ input, index });
    }
  });

  // Mark duplicates - REMOVED to allow backend reuse validation
  // duplicates.forEach((inputsArray, trayId) => {
  //   if (inputsArray.length > 1) {
  //     inputsArray.forEach(({ input }) => {
  //       input.classList.add('duplicate-error');
  //       input.style.borderColor = '#dc3545';
  //       input.style.backgroundColor = '#f8d7da';
  //       const errorSpan = input.parentElement?.parentElement?.querySelector('.rejection-tray-error');
  //       if (errorSpan) {
  //         errorSpan.innerHTML = `❌ Duplicate tray ID: ${trayId}`;
  //         errorSpan.style.display = 'block';
  //         errorSpan.style.color = '#721c24';
  //         errorSpan.style.backgroundColor = '#f8d7da';
  //         errorSpan.style.border = '1px solid #f5c6cb';
  //         errorSpan.style.padding = '6px 10px';
  //         errorSpan.style.borderRadius = '4px';
  //         errorSpan.style.fontSize = '12px';
  //         errorSpan.style.fontWeight = '500';
  //         errorSpan.style.marginTop = '4px';
  //       }
  //     });
  //   }
  // });

  // Return true if no duplicates - always return true to allow reuse
  return true;
}

// Show available quantities for all tray inputs in draft mode
if (window.isDraftMode) {
  const availableQuantities = window.currentLotAvailableQuantities || [12];
  document.querySelectorAll('.rejection-tray-id-input').forEach(input => {
    if (input.value.trim()) {
      const errorSpan = input.parentElement?.parentElement?.querySelector('.rejection-tray-error');
      if (errorSpan) {
        errorSpan.innerHTML = `Available: ${availableQuantities.join(' or ')}`;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#155724';
        errorSpan.style.backgroundColor = '#d4edda';
        errorSpan.style.border = '1px solid #c3e6cb';
        errorSpan.style.padding = '6px 10px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '12px';
        errorSpan.style.fontWeight = '500';
        errorSpan.style.marginTop = '4px';
      }
    }
  });
}

// Make the function globally available
window.validateDuplicateTrayIds = validateDuplicateTrayIds;


function addInstantTrayValidationToInputs(trayIdCell) {
  const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
  trayInputs.forEach(function(input, index) {
    // Remove any existing instant validation listeners to avoid duplicates
    if (input._instantValidationHandler) {
      input.removeEventListener('input', input._instantValidationHandler);
      input.removeEventListener('change', input._instantValidationHandler);
      input.removeEventListener('blur', input._instantValidationHandler);
    }

    // Remove any pending validation for this input before adding new one
    if (input._pendingValidationTimeout) {
      clearTimeout(input._pendingValidationTimeout);
      input._pendingValidationTimeout = null;
    }

    input._instantValidationHandler = function(event) {
      const trayId = this.value.trim();
      const errorSpan = this.parentElement.parentElement.querySelector('.rejection-tray-error');

      // Clear previous validation state
      this.style.borderColor = '#ced4da';
      this.style.backgroundColor = '#ffffff';
      this._isValid = false;

      if (errorSpan) {
        errorSpan.style.display = 'none';
        errorSpan.textContent = '';
      }

      // Remove any pending validation for this input
      if (this._pendingValidationTimeout) {
        clearTimeout(this._pendingValidationTimeout);
        this._pendingValidationTimeout = null;
      }

      // Skip validation if input is empty
      if (!trayId) {
        this._isValid = false;
        updateFormValidationState();
        return;
      }

      // Validation logic (capacity, duplicates, etc.)
      const lotId = getCurrentLotId();
      const rejectionQty = parseInt(this.getAttribute('data-tray-qty')) || 0;
      const rejectionReasonId = this.getAttribute('data-reason-id') || '';
      const cacheKey = `${trayId}_${lotId}_${rejectionQty}_${rejectionReasonId}`;
      if (window.trayValidationCache && window.trayValidationCache[cacheKey]) {
        // Use cached result instantly, skip loading style
        const cached = window.trayValidationCache[cacheKey];
        if (cached && cached.data) {
          if (cached.data.exists && cached.data.valid_for_rejection) {
            this.style.borderColor = '#28a745';
            this.style.backgroundColor = '#d4edda';
            this._isValid = true;
            if (errorSpan) {
              errorSpan.innerHTML = `✅ ${cached.data.status_message || 'Valid tray - Ready to proceed'} <small>(cached)</small>`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#155724';
              errorSpan.style.backgroundColor = '#d4edda';
              errorSpan.style.border = '1px solid #c3e6cb';
              errorSpan.style.padding = '6px 10px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '12px';
              errorSpan.style.fontWeight = '500';
              errorSpan.style.marginTop = '4px';
            }
          } else {
            this.style.borderColor = '#dc3545';
            this.style.backgroundColor = '#f8d7da';
            this._isValid = false;
            if (errorSpan) {
              const errorMessage = cached.data.status_message || cached.data.error || 'Invalid tray ID';
              errorSpan.innerHTML = `❌ ${errorMessage} <small>(cached)</small>`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#721c24';
              errorSpan.style.backgroundColor = '#f8d7da';
              errorSpan.style.border = '1px solid #f5c6cb';
              errorSpan.style.padding = '6px 10px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '12px';
              errorSpan.style.fontWeight = '500';
              errorSpan.style.marginTop = '4px';
            }
          }
          updateFormValidationState();
          return;
        }
      }

      // --- REMOVE LOADING... STATE ---
      // Do not show any "loading..." or buffering indicator

      // API call for validation
      const currentSessionAllocations = collectCurrentSessionAllocations();
      const queryParams = new URLSearchParams({
        tray_id: trayId,
        lot_id: lotId,
        rejection_qty: rejectionQty,
        rejection_reason_id: rejectionReasonId,
        current_session_allocations: JSON.stringify(currentSessionAllocations),
        is_draft: isDraftMode ? 'true' : 'false'
      });
      const apiUrl = '/inputscreening/reject_check_tray_id_simple/';
      const fullUrl = `${apiUrl}?${queryParams}`;

      fetch(fullUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          ...(window.csrfToken && { 'X-CSRFToken': window.csrfToken })
        },
        credentials: 'same-origin'
      })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          this._backendResponseData = data;
          if (data.available_quantities) {
            window.currentLotAvailableQuantities = Array.isArray(data.available_quantities)
              ? data.available_quantities
              : Array.from(data.available_quantities);
          }
          if (data.tray_actual_quantity) {
            this._backendTrayQuantity = data.tray_actual_quantity;
          } else if (data.error && data.error.includes('but tray has')) {
            const match = data.error.match(/but tray has (\d+) pieces/);
            if (match) {
              const actualQty = parseInt(match[1]);
              this._extractedTrayQuantity = actualQty;
            }
          }
          if (data.exists && data.valid_for_rejection) {
            this.style.borderColor = '#28a745';
            this.style.backgroundColor = '#d4edda';
            this._isValid = true;
            this.classList.remove('duplicate-warning', 'duplicate-error');
            if (errorSpan) {
              let successMessage = data.status_message || 'Valid tray - Ready to proceed';
              if (data.validation_type === 'perfect_capacity_match_draft') {
                successMessage = '✅ Perfect capacity match - Tray reuse approved!';
              }
              errorSpan.innerHTML = `✅ ${successMessage}`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#155724';
              errorSpan.style.backgroundColor = '#d4edda';
              errorSpan.style.border = '1px solid #c3e6cb';
              errorSpan.style.padding = '6px 10px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '12px';
              errorSpan.style.fontWeight = '500';
              errorSpan.style.marginTop = '4px';
            }
            updateFormValidationState();
            if (data.validation_type !== 'perfect_capacity_match_draft') {
              setTimeout(() => {
                validateDuplicateTrayIds();
                updateFormValidationState();
              }, 100);
            }
          } else {
            this.style.borderColor = '#dc3545';
            this.style.backgroundColor = '#f8d7da';
            this._isValid = false;
            if (errorSpan) {
              const errorMessage = data.status_message || data.error || 'Invalid tray ID';
              errorSpan.innerHTML = `❌ ${errorMessage}`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#721c24';
              errorSpan.style.backgroundColor = '#f8d7da';
              errorSpan.style.border = '1px solid #f5c6cb';
              errorSpan.style.padding = '6px 10px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '12px';
              errorSpan.style.fontWeight = '500';
              errorSpan.style.marginTop = '4px';
            }
            if (this._shouldAutoSelectOnError && this.value.trim().length >= 9) {
              setTimeout(() => {
                this.select();
              }, 100);
            }
          }
          updateFormValidationState();
        })
        .catch(error => {
          this.style.borderColor = '#ffc107';
          this.style.backgroundColor = '#fff3cd';
          this._isValid = false;
          if (errorSpan) {
            let errorMessage = '⚠️ Validation failed';
            if (error.message.includes('HTTP')) {
              errorMessage = `⚠️ Server error: ${error.message}`;
            } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
              errorMessage = '⚠️ Network connection failed - Check server status';
            } else {
              errorMessage = `⚠️ Validation error: ${error.message}`;
            }
            errorSpan.innerHTML = errorMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#856404';
            errorSpan.style.backgroundColor = '#fff3cd';
            errorSpan.style.border = '1px solid #ffeaa7';
            errorSpan.style.padding = '6px 10px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '12px';
            errorSpan.style.fontWeight = '500';
            errorSpan.style.marginTop = '4px';
          }
          if (this._shouldAutoSelectOnError && this.value.trim().length >= 9) {
            setTimeout(() => {
              this.select();
            }, 100);
          }
          updateFormValidationState();
        });

      // Always refocus input after validation (for fast scanning)
      setTimeout(() => {
        this.focus();
        this.select();
      }, 0);
    };

    // Attach instant validation to input event (NO debounce, always instant)
    input.addEventListener('input', input._instantValidationHandler);

    // Also validate on 'change' and 'blur' to catch skipped scans
    input.addEventListener('change', input._instantValidationHandler);
    input.addEventListener('blur', input._instantValidationHandler);
  });
}



    // Attach instant validation to input event (NO debounce, always instant)
    input.addEventListener('input', input._instantValidationHandler);

    // Also add a simple test to verify the input is working
    input.addEventListener('focus', function() {
      // For debug only
    });

    input.addEventListener('keydown', function(e) {
      // For debug only
    });
  });

  console.log('🔧 [addInstantTrayValidationToInputs] ✅ Setup complete');
}



// ✅ Helper function to get current lot ID
function getCurrentLotId() {
  console.log('🔧 [getCurrentLotId] Called');
  
  const highlightedRow = document.querySelector('tr.highlighted-tray-scan');
  if (highlightedRow) {
    const lotId = highlightedRow.getAttribute('data-stock-lot-id') || '';
    console.log('🔧 [getCurrentLotId] Found highlighted row lotId:', lotId);
    return lotId;
  }
  
  const activeRow = document.querySelector('[data-stock-lot-id]');
  if (activeRow) {
    const lotId = activeRow.getAttribute('data-stock-lot-id') || '';
    console.log('🔧 [getCurrentLotId] Found active row lotId:', lotId);
    return lotId;
  }
  
  console.log('🔧 [getCurrentLotId] ❌ No lot ID found');
  return '';
}

// ✅ ENHANCED: Validation cache and debounce system initialization
if (!window.trayValidationCache) {
  window.trayValidationCache = {};
  console.log('🔧 [INIT] Tray validation cache initialized');
}
if (!window.trayValidationPending) {
  window.trayValidationPending = {};
  console.log('🔧 [INIT] Tray validation pending tracker initialized');
}
const VALIDATION_DEBOUNCE_MS = 300; // 300ms debounce
const CACHE_EXPIRY_MS = 30000; // 30 seconds cache

// ✅ ENHANCED: Validate tray capacity with detailed console calculations
function validateTrayCapacityAcrossRejections(trayId, currentInputElement) {
  console.log('🔧 [validateTrayCapacityAcrossRejections] ========= STARTING VALIDATION =========');
  console.log('🔧 [validateTrayCapacityAcrossRejections] Tray ID:', trayId);
  console.log('🔧 [validateTrayCapacityAcrossRejections] Current element:', currentInputElement);
  
  if (!trayId || !trayId.trim()) {
    console.log('⏭️ [validateTrayCapacityAcrossRejections] Empty tray ID, skipping');
    return { valid: true, error: null };
  }
  
  const currentReasonId = currentInputElement.getAttribute('data-reason-id');
  const currentRejectionQty = parseInt(currentInputElement.getAttribute('data-tray-qty')) || 0;
  
  console.log('🔧 [validateTrayCapacityAcrossRejections] Current reason ID:', currentReasonId);
  console.log('🔧 [validateTrayCapacityAcrossRejections] Current rejection qty:', currentRejectionQty);
  
  // ✅ Get tray capacity
  let trayCapacity = 12; // Default
  const currentRow = document.querySelector('tr.highlighted-tray-scan') || document.querySelector('[data-stock-lot-id]');
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      const trayTypeName = trayCapacityText.split('-')[0]?.toLowerCase() || '';
      const defaultCapacity = trayTypeName.includes('jumbo') ? 12 : 16;
      trayCapacity = parseInt(trayCapacityText.split('-')[1]) || defaultCapacity;
    }
  }
  
  console.log('📦 [validateTrayCapacityAcrossRejections] Tray capacity:', trayCapacity);
  
  // ✅ Calculate total session allocations with detailed logging
  let totalSessionQty = 0;
  let sessionAllocations = [];
  
  console.log('📋 [validateTrayCapacityAcrossRejections] === COLLECTING SESSION ALLOCATIONS ===');
  
  document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
    const qty = parseInt(qtyInput.value) || 0;
    const reasonId = qtyInput.getAttribute('data-reason-id');
    
    if (qty > 0) {
      const row = qtyInput.closest('tr');
      const reasonCell = row.cells[2];
      const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
      
      sessionAllocations.push({
        reason_id: reasonId,
        reason_text: reasonText,
        qty: qty
      });
      
      totalSessionQty += qty;
      
      console.log(`📋 [validateTrayCapacityAcrossRejections] Found allocation: ${reasonText} (${reasonId}) = ${qty} qty`);
    }
  });
  
  console.log('📊 [validateTrayCapacityAcrossRejections] Total session qty:', totalSessionQty);
  console.log('📊 [validateTrayCapacityAcrossRejections] Session allocations:', sessionAllocations);
  
  // ✅ Get actual tray distribution for the current lot from modal data or API
  let originalDistribution = [];
  try {
    // Try to get from modal data (if available)
    const modal = document.getElementById("trayScanModal");
    if (modal && modal.traysData && modal.traysData.length > 0) {
      originalDistribution = modal.traysData.map(tray => tray.tray_quantity || 0);
    }
    // Fallback: Try to get from a global variable if set
    if ((!originalDistribution || originalDistribution.length === 0) && window.currentLotTrayDistribution) {
      originalDistribution = window.currentLotTrayDistribution;
    }
    // Final fallback: Use trayCapacity and number of trays
    if (!originalDistribution || originalDistribution.length === 0) {
      const trayCount = 4; // Default to 4 trays if unknown
      originalDistribution = Array(trayCount).fill(trayCapacity);
      // Optionally, set the first tray to the remainder if you have total qty
    }
  } catch (e) {
    originalDistribution = [trayCapacity, trayCapacity, trayCapacity, trayCapacity];
  }
  console.log('📦 [validateTrayCapacityAcrossRejections] Original distribution:', originalDistribution);
  
  // ✅ Calculate trays emptied by sequential subtraction
  let remaining = totalSessionQty;
  let traysEmptied = [];
  
  console.log('🧮 [validateTrayCapacityAcrossRejections] ===== SUBTRACTION CALCULATION =====');
  console.log(`🧮 [validateTrayCapacityAcrossRejections] Starting with remaining: ${remaining}`);
  
  for (let i = 0; i < originalDistribution.length; i++) {
    const trayQty = originalDistribution[i];
    
    console.log(`🧮 [validateTrayCapacityAcrossRejections] Tray ${i + 1}: qty=${trayQty}, remaining=${remaining}`);
    
    if (remaining <= 0) {
      console.log(`🧮 [validateTrayCapacityAcrossRejections] No more remaining, breaking`);
      break;
    }
    
    if (remaining >= trayQty) {
      traysEmptied.push(i + 1); // Use 1-based index for display
      remaining -= trayQty;
      console.log(`✅ [validateTrayCapacityAcrossRejections] 🎯 Tray ${i + 1} will be emptied! Remaining: ${remaining}`);
    } else {
      console.log(`❌ [validateTrayCapacityAcrossRejections] Tray ${i + 1} partially used (${remaining}/${trayQty}) - breaking`);
      break;
    }
  }
  
  const reuseAllowedByEmptying = traysEmptied.length > 0;
  console.log('🎯 [validateTrayCapacityAcrossRejections] Trays that will be emptied:', traysEmptied);
  console.log('🎯 [validateTrayCapacityAcrossRejections] Reuse allowed by emptying:', reuseAllowedByEmptying);
  
  // ✅ NEW: Allow reuse for small quantities that don't exceed first tray
  const allowSmallQuantities = totalSessionQty <= originalDistribution[0];
  console.log('🎯 [validateTrayCapacityAcrossRejections] Allow small quantities:', allowSmallQuantities, `(${totalSessionQty} <= ${originalDistribution[0]})`);
  
  const reuseAllowed = reuseAllowedByEmptying || allowSmallQuantities;
  
  // ✅ Enhanced: Check for conflicts with other rejection reasons
  let isAvailable = true;
  let conflictReasons = [];
  
  document.querySelectorAll('.rejection-tray-id-input').forEach(input => {
    if (input !== currentInputElement && input.value.trim() === trayId) {
      const inputReasonId = input.getAttribute('data-reason-id');
      if (inputReasonId !== currentReasonId) {
        isAvailable = false;
        conflictReasons.push(inputReasonId);
        console.log(`⚠️ [validateTrayCapacityAcrossRejections] CONFLICT: Tray already used by reason ${inputReasonId}`);
      }
    }
  });
  
  console.log('🔧 [validateTrayCapacityAcrossRejections] Final results:');
  console.log('  - Is available (no conflicts):', isAvailable);
  console.log('  - Reuse allowed by logic:', reuseAllowed);
  console.log('  - Overall valid:', isAvailable && reuseAllowed);
  console.log('🔧 [validateTrayCapacityAcrossRejections] ========= VALIDATION COMPLETE =========');
  
  if (!isAvailable) {
    return {
      valid: false,
      error: `Tray already allocated to reason(s): ${conflictReasons.join(', ')}`
    };
  }
  
  if (!reuseAllowed) {
    return {
      valid: false,
      error: `Reuse restricted: Total qty ${totalSessionQty} doesn't qualify for reuse (distribution: ${originalDistribution.join(', ')})`
    };
  }
  
  return {
    valid: true,
    error: null,
    details: {
      totalSessionQty,
      traysEmptied,
      originalDistribution,
      allowedBySmallQty: allowSmallQuantities
    }
  };
}



// ✅ Simple validation function for fallback
function validateTrayIdSimple(inputElement, trayId) {


// ADD THIS LINE if not present:
// const trayId = inputElement.value.trim();

  // ✅ UPDATED: Check tray capacity and rejection reason compatibility
  const validationResult = validateTrayCapacityAcrossRejections(trayId, inputElement);
  if (!validationResult.valid) {
    inputElement.style.borderColor = '#dc3545';
    inputElement.style.backgroundColor = '#f8d7da';
    inputElement._isValid = false;
    const errorSpan = inputElement.parentElement.querySelector('.rejection-tray-error');
    if (errorSpan) {
      errorSpan.innerHTML = `❌ ${validationResult.error}`;
      errorSpan.style.display = 'block';
      errorSpan.style.color = '#721c24';
      errorSpan.style.backgroundColor = '#f8d7da';
      errorSpan.style.border = '1px solid #f5c6cb';
    }
    updateFormValidationState();
    return;
  }



  console.log('🔧 [validateTrayIdSimple] Called with:', trayId);
  
  // Get basic info
  const lotId = getCurrentLotId();
  const rejectionQty = parseInt(inputElement.getAttribute('data-tray-qty')) || 0;
  const rejectionReasonId = inputElement.getAttribute('data-reason-id') || '';
  const errorSpan = inputElement.parentElement.querySelector('.rejection-tray-error');
  
  if (!lotId) {
    console.log('🔧 [validateTrayIdSimple] ❌ No lot ID found');
    inputElement.style.borderColor = '#ffc107';
    inputElement.style.backgroundColor = '#fff3cd';
    inputElement._isValid = false;
    
    if (errorSpan) {
      errorSpan.innerHTML = '⚠️ No lot ID found - Cannot validate';
      errorSpan.style.display = 'block';
      errorSpan.style.color = '#856404';
      errorSpan.style.backgroundColor = '#fff3cd';
      errorSpan.style.border = '1px solid #ffeaa7';
      errorSpan.style.padding = '6px 10px';
      errorSpan.style.borderRadius = '4px';
      errorSpan.style.fontSize = '12px';
      errorSpan.style.marginTop = '4px';
    }
    updateFormValidationState();
    return;
  }

  
  console.log('🔧 [validateTrayIdSimple] Params:', {trayId, lotId, rejectionQty, rejectionReasonId});
  
  // ✅ Define cache key for duplicate check and caching
  const cacheKey = `${trayId}_${lotId}_${rejectionReasonId}`;
  
  // ✅ ENHANCED: Check for duplicate tray IDs across ALL rejection reasons BEFORE checking cache
  if (trayId && trayId.trim()) {
    const normalizedTrayId = trayId.trim().toUpperCase();
    const currentRejectionRow = inputElement.closest('tr');
    const currentReasonId = currentRejectionRow.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id');
    const currentReasonText = currentRejectionRow.querySelector('td:nth-child(3)')?.textContent.trim();
    
    let duplicateInSameReason = false;
    let duplicateInOtherReason = false;
    let otherReasonText = '';
    let otherReasonId = '';
    
    // Check ALL rejection rows in the table
    document.querySelectorAll('#rejection-table-body tr').forEach(row => {
      const rowReasonId = row.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id');
      const rowReasonText = row.querySelector('td:nth-child(3)')?.textContent.trim();
      
      // Get all tray inputs in this row
      const rowTrayInputs = row.querySelectorAll('.rejection-tray-id-input');
      rowTrayInputs.forEach(input => {
        if (input !== inputElement && input.value.trim().toUpperCase() === normalizedTrayId) {
          if (rowReasonId === currentReasonId) {
            duplicateInSameReason = true;
          } else {
            duplicateInOtherReason = true;
            otherReasonText = rowReasonText;
            otherReasonId = rowReasonId;
          }
        }
      });
    });
    
    // ✅ FIXED: Block duplicate tray IDs completely - same tray cannot be used twice  
    if (duplicateInSameReason || duplicateInOtherReason) {
      console.log('🔧 [validateTrayIdSimple] ❌ Duplicate tray ID detected - BLOCKING:', {
        duplicateInSameReason,
        duplicateInOtherReason,
        otherReason: otherReasonText
      });
      
      // ✅ CRITICAL FIX: Clear any pending validation timeouts to prevent API call overwriting duplicate error
      if (window.trayValidationPending[cacheKey]) {
        console.log('🔧 [validateTrayIdSimple] 🛑 Clearing pending validation timeout to prevent API override');
        clearTimeout(window.trayValidationPending[cacheKey]);
        delete window.trayValidationPending[cacheKey];
      }
      
      // Show error style and block validation
      inputElement.style.borderColor = '#dc3545';
      inputElement.style.backgroundColor = '#f8d7da';
      inputElement._isValid = false;
      
      if (errorSpan) {
        let errorMessage = '';
        if (duplicateInOtherReason) {
          errorMessage = `❌ Error: Tray "${trayId}" already used in "${otherReasonText}" (${otherReasonId}) - Each tray can only be used once`;
        } else {
          errorMessage = `❌ Error: Tray "${trayId}" already used in this rejection reason - Each tray can only be used once`;
        }
        
        errorSpan.innerHTML = errorMessage;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#721c24';
        errorSpan.style.backgroundColor = '#f8d7da';
        errorSpan.style.border = '1px solid #f5c6cb';
        errorSpan.style.padding = '6px 10px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '12px';
        errorSpan.style.marginTop = '4px';
      }
      updateFormValidationState();
      return; // Block further validation for duplicate trays
    }
  }
  
  // ✅ NEW: Check cache first (only if no duplicates)
  const cached = window.trayValidationCache[cacheKey];
  const now = Date.now();
  
  if (cached && (now - cached.timestamp < CACHE_EXPIRY_MS)) {
    console.log('🔧 [validateTrayIdSimple] Using cached result:', cached.data);
    applyCachedValidationResult(inputElement, errorSpan, cached.data, trayId);
    return;
  }
  
  // ✅ NEW: Debounce API calls
  if (window.trayValidationPending[cacheKey]) {
    clearTimeout(window.trayValidationPending[cacheKey]);
  }
  
  // Show loading state
  inputElement.style.borderColor = '#007bff';
  inputElement.style.backgroundColor = '#e3f2fd';
  inputElement._isValid = false;
  
  if (errorSpan) {
    errorSpan.innerHTML = '🔄 Validating tray ID...';
    errorSpan.style.display = 'block';
    errorSpan.style.color = '#007bff';
    errorSpan.style.backgroundColor = '#e3f2fd';
    errorSpan.style.border = '1px solid #b3d7ff';
    errorSpan.style.padding = '6px 10px';
    errorSpan.style.borderRadius = '4px';
    errorSpan.style.fontSize = '12px';
    errorSpan.style.marginTop = '4px';
  }
  
  // ✅ NEW: Debounced API call
  window.trayValidationPending[cacheKey] = setTimeout(() => {
    performTrayValidation(inputElement, errorSpan, trayId, lotId, rejectionQty, rejectionReasonId, isDraftMode, cacheKey);
    delete window.trayValidationPending[cacheKey];
  }, VALIDATION_DEBOUNCE_MS);
}

// ✅ UPDATED: Apply cached validation result with duplicate warning clearance
function applyCachedValidationResult(inputElement, errorSpan, data, trayId) {
  if (data.exists && data.valid_for_rejection) {
    inputElement.style.borderColor = '#28a745';
    inputElement.style.backgroundColor = '#d4edda';
    inputElement._isValid = true;
    
    // ✅ Clear any duplicate warnings when backend validates perfect match
    inputElement.classList.remove('duplicate-warning', 'duplicate-error');
    
    if (errorSpan) {
      // ✅ Show validation type in success message for perfect matches
      let successMessage = data.status_message || 'Valid tray - Ready to proceed';
      if (data.validation_type === 'perfect_capacity_match_draft') {
        successMessage = '✅ Perfect capacity match - Tray reuse approved!';
      }
      
      errorSpan.innerHTML = `✅ ${successMessage} <small>(cached)</small>`;
      errorSpan.style.display = 'block';
      errorSpan.style.color = '#155724';
      errorSpan.style.backgroundColor = '#d4edda';
      errorSpan.style.border = '1px solid #c3e6cb';
      errorSpan.style.padding = '6px 10px';
      errorSpan.style.borderRadius = '4px';
      errorSpan.style.fontSize = '12px';
      errorSpan.style.fontWeight = '500';
      errorSpan.style.marginTop = '4px';
    }
    
    // ✅ NEW: Auto-focus next input after successful validation
    moveToNextTrayInput(inputElement);
  } else {
    inputElement.style.borderColor = '#dc3545';
    inputElement.style.backgroundColor = '#f8d7da';
    inputElement._isValid = false;
    
    if (errorSpan) {
      const errorMessage = data.status_message || data.error || 'Invalid tray ID';
      errorSpan.innerHTML = `❌ ${errorMessage} <small>(cached)</small>`;
      errorSpan.style.display = 'block';
      errorSpan.style.color = '#721c24';
      errorSpan.style.backgroundColor = '#f8d7da';
      errorSpan.style.border = '1px solid #f5c6cb';
      errorSpan.style.padding = '6px 10px';
      errorSpan.style.borderRadius = '4px';
      errorSpan.style.fontSize = '12px';
      errorSpan.style.fontWeight = '500';
      errorSpan.style.marginTop = '4px';
    }
  }
  updateFormValidationState();
}

// ✅ NEW: Perform actual API validation
function performTrayValidation(inputElement, errorSpan, trayId, lotId, rejectionQty, rejectionReasonId, isDraftMode, cacheKey) {
  
  // ✅ FIXED: Collect current session allocations excluding the current input
  const currentSessionAllocations = collectCurrentSessionAllocations(inputElement);
  
  const queryParams = new URLSearchParams({
    tray_id: trayId,
    lot_id: lotId,
    rejection_qty: rejectionQty,
    rejection_reason_id: rejectionReasonId,
    current_session_allocations: JSON.stringify(currentSessionAllocations),
    is_draft: isDraftMode ? 'true' : 'false'
  });
  
  console.log('🔧 [performTrayValidation] Making API call...');
  
  const apiUrl = '/inputscreening/reject_check_tray_id_simple/';
  const fullUrl = `${apiUrl}?${queryParams}`;
  
  console.log('🔧 [performTrayValidation] Full API URL:', fullUrl);
  
  fetch(fullUrl, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
      ...(window.csrfToken && { 'X-CSRFToken': window.csrfToken })
    },
    credentials: 'same-origin'
  })
    .then(response => {
      console.log('🔧 [performTrayValidation] Response status:', response.status, response.statusText);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    })
    .then(data => {
      console.log('🔧 [performTrayValidation] Response data:', data);
      
      // ✅ CRITICAL FIX: Double-check for duplicates before applying API response
      // This prevents race conditions where API response overwrites duplicate errors
      const trayId = inputElement.value.trim().toUpperCase();
      const currentRejectionRow = inputElement.closest('tr');
      const currentReasonId = currentRejectionRow.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id');
      
      let duplicateFound = false;
      document.querySelectorAll('#rejection-table-body tr').forEach(row => {
        const rowReasonId = row.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id');
        const rowTrayInputs = row.querySelectorAll('.rejection-tray-id-input');
        rowTrayInputs.forEach(input => {
          if (input !== inputElement && input.value.trim().toUpperCase() === trayId) {
            duplicateFound = true;
          }
        });
      });
      
      if (duplicateFound) {
        console.log('🔧 [performTrayValidation] 🛑 Duplicate detected in API response - BLOCKING override');
        // Don't apply the API response, leave the duplicate error in place
        return;
      }
      
      // ✅ NEW: Cache the result
      window.trayValidationCache[cacheKey] = {
        data: data,
        timestamp: Date.now()
      };
      
      if (data.exists && data.valid_for_rejection) {
        // Valid
        inputElement.style.borderColor = '#28a745';
        inputElement.style.backgroundColor = '#d4edda';
        inputElement._isValid = true;
        
        if (errorSpan) {
          errorSpan.innerHTML = `✅ ${data.status_message || 'Valid tray - Ready to proceed'}`;
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#155724';
          errorSpan.style.backgroundColor = '#d4edda';
          errorSpan.style.border = '1px solid #c3e6cb';
          errorSpan.style.padding = '6px 10px';
          errorSpan.style.borderRadius = '4px';
          errorSpan.style.fontSize = '12px';
          errorSpan.style.fontWeight = '500';
          errorSpan.style.marginTop = '4px';
        }
        
        updateFormValidationState();
        console.log('🔧 [performTrayValidation] ✅ Valid tray');
        
        // ✅ NEW: Auto-focus next input after successful validation
        setTimeout(() => {
          moveToNextTrayInput(inputElement);
        }, 200);
        
      } else {
        // Invalid
        inputElement.style.borderColor = '#dc3545';
        inputElement.style.backgroundColor = '#f8d7da';
        inputElement._isValid = false;
        
        if (errorSpan) {
          const errorMessage = data.status_message || data.error || 'Invalid tray ID';
          errorSpan.innerHTML = `❌ ${errorMessage}`;
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#721c24';
          errorSpan.style.backgroundColor = '#f8d7da';
          errorSpan.style.border = '1px solid #f5c6cb';
          errorSpan.style.padding = '6px 10px';
          errorSpan.style.borderRadius = '4px';
          errorSpan.style.fontSize = '12px';
          errorSpan.style.fontWeight = '500';
          errorSpan.style.marginTop = '4px';
        }
        
        // ✅ FIXED: Auto-select invalid input only after entering 9 characters
        if (trayId.length >= 9) {
          setTimeout(() => {
            inputElement.focus();
            inputElement.select(); // Select all text for easy replacement
          }, 100);
          console.log('🔧 [performTrayValidation] ❌ Invalid tray - auto-selected for re-scan');
        }
      }
      
      updateFormValidationState();
    })
    .catch(error => {
      console.error('🔧 [performTrayValidation] ❌ Error Details:', {
        error: error,
        message: error.message,
        stack: error.stack,
        url: fullUrl
      });
      
      inputElement.style.borderColor = '#ffc107';
      inputElement.style.backgroundColor = '#fff3cd';
      inputElement._isValid = false;
      
      if (errorSpan) {
        let errorMessage = '⚠️ Validation failed';
        
        if (error.message.includes('HTTP 404')) {
          errorMessage = '⚠️ API endpoint not found - Check server configuration';
        } else if (error.message.includes('HTTP 500')) {
          errorMessage = '⚠️ Server error - Contact system administrator';
        } else if (error.message.includes('HTTP 403')) {
          errorMessage = '⚠️ Access denied - Check authentication';
        } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
          errorMessage = '⚠️ Network connection failed - Check server status';
        } else {
          errorMessage = `⚠️ Validation error: ${error.message}`;
        }
        
        errorSpan.innerHTML = errorMessage;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#856404';
        errorSpan.style.backgroundColor = '#fff3cd';
        errorSpan.style.border = '1px solid #ffeaa7';
        errorSpan.style.padding = '6px 10px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '12px';
        errorSpan.style.fontWeight = '500';
        errorSpan.style.marginTop = '4px';
      }
      
      // ✅ NEW: Auto-select input on validation error for immediate re-scan
      setTimeout(() => {
        inputElement.focus();
        inputElement.select(); // Select all text for easy replacement
      }, 100);
      
      updateFormValidationState();
    });
}

// ✅ NEW: Helper function to move focus to next tray input
function moveToNextTrayInput(currentInput) {
  if (!currentInput) return;
  
  const currentRow = currentInput.closest('tr');
  if (!currentRow) return;
  
  // Get all tray inputs in the current rejection reason row
  const trayInputs = Array.from(currentRow.querySelectorAll('.rejection-tray-id-input'));
  const currentIndex = trayInputs.indexOf(currentInput);
  
  console.log('🔧 [moveToNextTrayInput] Current index:', currentIndex, 'Total inputs:', trayInputs.length);
  
  // Find the next empty or invalid input
  for (let i = currentIndex + 1; i < trayInputs.length; i++) {
    const nextInput = trayInputs[i];
    if (!nextInput.value.trim() || !nextInput._isValid) {
      console.log('🔧 [moveToNextTrayInput] Moving to input', i + 1);
      setTimeout(() => {
        nextInput.focus();
        nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 100);
      return;
    }
  }
  
  // If no next input in current row, check if there are other rejection reasons with pending trays
  const allRows = Array.from(document.querySelectorAll('#rejection-table-body tr'));
  const currentRowIndex = allRows.indexOf(currentRow);
  
  for (let i = currentRowIndex + 1; i < allRows.length; i++) {
    const nextRow = allRows[i];
    const nextRowInputs = Array.from(nextRow.querySelectorAll('.rejection-tray-id-input'));
    
    for (const nextInput of nextRowInputs) {
      if (!nextInput.value.trim() || !nextInput._isValid) {
        console.log('🔧 [moveToNextTrayInput] Moving to next rejection reason row');
        setTimeout(() => {
          nextInput.focus();
          nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
        return;
      }
    }
  }
  
  console.log('🔧 [moveToNextTrayInput] All trays scanned, staying at current input');
}

// ✅ Comprehensive test function for the complete rejection → accepted top tray flow
function testCompleteFlow() {
  console.log('🧪 [testCompleteFlow] Testing complete rejection → accepted flow...');
  
  alert(`🧪 TESTING COMPLETE FLOW\n\nThis will test:\n1. Click reject button\n2. Enter rejection qty and tray ID\n3. Click proceed\n4. Enter top tray ID\n5. Test submit button behavior\n\nCheck console for detailed logs.`);
  
  // Test current button states
  const rejectionSubmitBtns = document.querySelectorAll('#proceedBtn, [onclick*="proceed"]');
  const acceptedSubmitBtns = document.querySelectorAll('#acceptedTraySubmitBtn, #acceptedTrayFinalSubmitBtn');
  
  console.log('🧪 [testCompleteFlow] Found rejection submit buttons:', rejectionSubmitBtns.length);
  console.log('🧪 [testCompleteFlow] Found accepted submit buttons:', acceptedSubmitBtns.length);
  
  // Test validation functions
  console.log('🧪 [testCompleteFlow] Testing validation functions...');
  
  try {
    if (typeof updateFormValidationState === 'function') {
      updateFormValidationState();
      console.log('✅ updateFormValidationState works');
    } else {
      console.log('❌ updateFormValidationState not found');
    }
    
    if (typeof updateAcceptedFormValidationState === 'function') {
      updateAcceptedFormValidationState();
      console.log('✅ updateAcceptedFormValidationState works');
    } else {
      console.log('❌ updateAcceptedFormValidationState not found');
    }
    
    console.log('🧪 [testCompleteFlow] All validation functions working!');
    
  } catch (error) {
    console.error('❌ [testCompleteFlow] Validation function error:', error);
  }
  
  return true;
}

// Make the test function globally available
window.testCompleteFlow = testCompleteFlow;

// ✅ Test selector fix function
function testSelectorFix() {
  console.log('🔧 [testSelectorFix] Testing CSS selector fix...');
  
  try {
    // Test the old invalid selector would have failed
    console.log('🔧 [testSelectorFix] The old invalid selector :contains() has been replaced...');
    
    // Test the new valid selector approach that we implemented
    const allButtons = document.querySelectorAll('button[type="submit"], .btn-primary, .btn-success, button[onclick*="submit"], button[onclick*="proceed"], button[onclick*="save"]');
    const allPageButtons = document.querySelectorAll('button');
    const submitButtons = [];
    
    // Add buttons from CSS selector
    allButtons.forEach(btn => submitButtons.push(btn));
    
    // Add buttons that contain specific text
    allPageButtons.forEach(btn => {
      if (btn.textContent.toLowerCase().includes('proceed') || 
          btn.textContent.toLowerCase().includes('submit') ||
          btn.textContent.toLowerCase().includes('save')) {
        if (!submitButtons.includes(btn)) {
          submitButtons.push(btn);
        }
      }
    });
    
    console.log('✅ [testSelectorFix] New selector approach works perfectly!');
    console.log('🔧 [testSelectorFix] Found buttons:', submitButtons.length);
    console.log('🔧 [testSelectorFix] Button texts:', submitButtons.map(btn => btn.textContent.trim()));
    
    // Test updateFormValidationState function to ensure no errors
    try {
      updateFormValidationState();
      console.log('✅ [testSelectorFix] updateFormValidationState runs without errors!');
    } catch (error) {
      console.error('❌ [testSelectorFix] updateFormValidationState failed:', error);
      throw error;
    }
    
    // Test if accepted tray validation functions exist
    let acceptedTrayTestResult = '';
    try {
      if (typeof addInstantTopTrayValidation === 'function') {
        acceptedTrayTestResult += '\n✓ addInstantTopTrayValidation function exists';
      }
      if (typeof updateAcceptedFormValidationState === 'function') {
        acceptedTrayTestResult += '\n✓ updateAcceptedFormValidationState function exists';
      }
      if (typeof addAcceptedTrayFormInterceptor === 'function') {
        acceptedTrayTestResult += '\n✓ addAcceptedTrayFormInterceptor function exists';
      }
    } catch (error) {
      acceptedTrayTestResult += '\n❌ Error testing accepted tray functions: ' + error.message;
    }
    
    alert(`✅ Selector Fix Test PASSED!\n\n✓ Fixed invalid :contains() selector\n✓ Found ${submitButtons.length} submit buttons\n✓ updateFormValidationState works correctly\n✓ No more CSS selector errors\n\nThe tray validation is now working properly!\n\n🎯 Accepted Tray Validation:${acceptedTrayTestResult}`);
    
    return true;
    
  } catch (error) {
    console.error('❌ [testSelectorFix] Selector test failed:', error);
    alert(`❌ Selector test failed: ${error.message}`);
    return false;
  }
}

// ✅ API Connectivity Test Function
function testApiConnectivity() {
  console.log('🔧 [testApiConnectivity] Testing API connection...');
  
  // Test basic connectivity
  const testUrl = '/inputscreening/reject_check_tray_id_simple/?tray_id=TEST&lot_id=TEST&rejection_qty=1&rejection_reason_id=TEST&current_session_allocations=[]';
  
  fetch(testUrl, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    credentials: 'same-origin'
  })
  .then(response => {
    console.log('🔧 [testApiConnectivity] ✅ API is reachable:', response.status, response.statusText);
    return response.text(); // Get as text first to see what we're getting
  })
  .then(text => {
    console.log('🔧 [testApiConnectivity] Raw response:', text);
    try {
      const data = JSON.parse(text);
      console.log('🔧 [testApiConnectivity] Parsed JSON:', data);
    } catch (e) {
      console.log('🔧 [testApiConnectivity] Response is not JSON:', e);
    }
  })
  .catch(error => {
    console.error('🔧 [testApiConnectivity] ❌ API connection failed:', error);
    
    // Show user-friendly error
    alert(`API Connection Test Failed:\n\nError: ${error.message}\n\nPlease check:\n1. Is the Django server running?\n2. Is the URL correct?\n3. Are there any network issues?`);
  });
}

  // ✅ Test API connectivity when page loads
  setTimeout(testApiConnectivity, 2000);
  
  // ✅ Add manual test button for debugging (remove in production)
  const debugButton = document.createElement('button');
  debugButton.textContent = '🔧 Test API Connection';
  debugButton.style.cssText = `
    position: fixed; top: 10px; right: 10px; z-index: 9999;
    background: #007bff; color: white; border: none; padding: 8px 12px;
    border-radius: 4px; font-size: 12px; cursor: pointer;
  `;
  debugButton.onclick = function() {
    console.clear();
    console.log('🔧 Running comprehensive debugging tests...');
    testSelectorFix();
    testApiConnectivity();
    testCompleteFlow();
  };
  document.body.appendChild(debugButton);// ✅ Function to update overall form validation state and prevent proceeding with invalid trays



function updateFormValidationState() {
  console.log('🔧 [updateFormValidationState] Checking form validation state');
  
  // Find all rejection tray inputs
  const allTrayInputs = document.querySelectorAll('.rejection-tray-id-input');
  let allValid = true;
  let hasInputs = false;
  let validationSummary = [];
  let hasActiveErrors = false;
  
  allTrayInputs.forEach((input, index) => {
    const trayId = input.value.trim();
    if (trayId) {
      hasInputs = true;
      
      // ✅ NEW: Check for visible error messages (red styling indicates actual errors)
      const hasRedStyling = input.style.borderColor === 'rgb(220, 53, 69)' || 
                          input.style.borderColor === '#dc3545' ||
                          input.style.backgroundColor === 'rgb(248, 215, 218)' ||
                          input.style.backgroundColor === '#f8d7da';
      
      // Check for error spans with error messages
      const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
      const hasErrorMessage = errorSpan && 
                            errorSpan.style.display !== 'none' && 
                            errorSpan.textContent.includes('❌');
      
      // ✅ UPDATED: More intelligent validation checking
      // Only consider it invalid if it's explicitly marked as invalid OR has visible errors
      const isExplicitlyInvalid = input._isValid === false;
      const hasVisibleError = hasRedStyling || hasErrorMessage;
      const isValid = !isExplicitlyInvalid && !hasVisibleError;
      
      validationSummary.push({
        index: index + 1,
        trayId: trayId,
        isValid: isValid,
        _isValid: input._isValid,
        hasRedStyling: hasRedStyling,
        hasErrorMessage: hasErrorMessage,
        isExplicitlyInvalid: isExplicitlyInvalid
      });
      
      if (!isValid) {
        allValid = false;
        hasActiveErrors = true;
      }
    }
  });
  
  console.log('🔧 [updateFormValidationState] Validation summary:', validationSummary);
  console.log('🔧 [updateFormValidationState] All valid:', allValid, 'Has inputs:', hasInputs, 'Has active errors:', hasActiveErrors);
  console.log('🔧 [updateFormValidationState] Should disable buttons:', hasInputs && hasActiveErrors);
  
  // Find submission buttons (Proceed, Submit, etc.) - using valid selectors only
  const allButtons = document.querySelectorAll('button[type="submit"], .btn-primary, .btn-success, button[onclick*="submit"], button[onclick*="proceed"], button[onclick*="save"]');
  
  // Also find buttons by text content (since :contains() is not valid in querySelectorAll)
  const allPageButtons = document.querySelectorAll('button');
  let submitButtons = [];
  
  // Add buttons from CSS selector
  allButtons.forEach(btn => submitButtons.push(btn));
  
  // Add buttons that contain specific text
  allPageButtons.forEach(btn => {
    if (btn.textContent.toLowerCase().includes('proceed') || 
        btn.textContent.toLowerCase().includes('submit') ||
        btn.textContent.toLowerCase().includes('save')) {
      if (!submitButtons.includes(btn)) {
        submitButtons.push(btn);
      }
    }
  });
  
  // ✅ CRITICAL FIX: Filter out ALL draft-related buttons from submitButtons
  submitButtons = submitButtons.filter(btn => {
    const buttonText = btn.textContent.toLowerCase();
    const buttonId = btn.id.toLowerCase();
    const buttonClass = btn.className.toLowerCase();
    
    return !buttonText.includes('draft') && 
           !buttonText.includes('cancel') &&
           !buttonId.includes('draft') && 
           !buttonId.includes('cancel') &&
           !buttonClass.includes('draft') &&
           !buttonClass.includes('cancel');
  });
  
  // ✅ ENHANCED: Find ALL possible draft buttons with multiple selectors
  const draftButtons = [
    document.getElementById('draftBtn'),
    
    document.querySelector('[onclick*="draft"]'),
    document.querySelector('button[data-action="draft"]'),
    ...document.querySelectorAll('button[id*="draft"]'),
    ...document.querySelectorAll('button[class*="draft"]'),
    ...Array.from(document.querySelectorAll('button')).filter(btn => 
      btn.textContent.toLowerCase().includes('update draft') ||
      btn.textContent.toLowerCase().includes('draft')
    )
  ].filter(btn => btn !== null);
  
  // ✅ ENHANCED: Find cancel buttons 
  const cancelButtons = [
    document.getElementById('cancelBtn'),
    document.querySelector('[onclick*="cancel"]'),
    ...Array.from(document.querySelectorAll('button')).filter(btn => 
      btn.textContent.toLowerCase().includes('cancel')
    )
  ].filter(btn => btn !== null);
  
  // Find specific buttons - ✅ UPDATED: Better proceed button detection
  const proceedButton = document.getElementById('proceedButton') || 
                       document.getElementById('proceedBtn') || 
                       document.querySelector('[onclick*="proceed"]');
  
  console.log('🔧 [updateFormValidationState] Found submit buttons:', submitButtons.length);
  console.log('🔧 [updateFormValidationState] Found draft buttons:', draftButtons.length);
  console.log('🔧 [updateFormValidationState] Found cancel buttons:', cancelButtons.length);
  
  // ✅ ENHANCED: Also check duplicate validation to enable proceed button correctly  
  const isDuplicateValid = validateDuplicateTrayIds();
  const shouldDisable = hasInputs && (hasActiveErrors || !isDuplicateValid);
  
  console.log(`🔧 [updateFormValidationState] Validation state: hasInputs=${hasInputs}, hasActiveErrors=${hasActiveErrors}, isDuplicateValid=${isDuplicateValid}, shouldDisable=${shouldDisable}`);
  
  // ✅ ONLY disable actual submit buttons for validation errors
  submitButtons.forEach(button => {
    if (shouldDisable) {
      button.disabled = true;
      button.style.opacity = '0.5';
      button.style.cursor = 'not-allowed';
      button.title = 'Please fix invalid tray IDs before proceeding';
    } else {
      button.disabled = false;
      button.style.opacity = '1';
      button.style.cursor = 'pointer';
      button.title = '';
    }
  });
  
  // ✅ CRITICAL: ALWAYS enable ALL draft buttons regardless of validation state
  draftButtons.forEach(draftButton => {
    if (draftButton) {
      draftButton.disabled = false;
      draftButton.style.opacity = '1';
      draftButton.style.cursor = 'pointer';
      draftButton.style.pointerEvents = 'auto';
      draftButton.title = 'Save as draft (validation not required)';
      draftButton.removeAttribute('disabled');
      draftButton.removeAttribute('aria-disabled');
      draftButton.classList.remove('disabled');
      console.log('✅ [updateFormValidationState] Force-enabled draft button:', draftButton.id || draftButton.textContent);
    }
  });
  
  // ✅ CRITICAL: ALWAYS enable ALL cancel buttons
  cancelButtons.forEach(cancelButton => {
    if (cancelButton) {
      cancelButton.disabled = false;
      cancelButton.style.opacity = '1';
      cancelButton.style.cursor = 'pointer';
      cancelButton.style.pointerEvents = 'auto';
      cancelButton.title = 'Cancel operation';
      cancelButton.removeAttribute('disabled');
      cancelButton.removeAttribute('aria-disabled');
      cancelButton.classList.remove('disabled');
      console.log('✅ [updateFormValidationState] Force-enabled cancel button:', cancelButton.id || cancelButton.textContent);
    }
  });
  
  if (proceedButton) {
    if (shouldDisable) {
      proceedButton.disabled = true;
      proceedButton.style.opacity = '0.5';
      proceedButton.style.cursor = 'not-allowed';
      proceedButton.title = 'Please fix all invalid tray IDs before proceeding';
    } else {
      proceedButton.disabled = false;
      proceedButton.style.opacity = '1';
      proceedButton.style.cursor = 'pointer';
      proceedButton.title = '';
    }
    console.log(`🔧 [updateFormValidationState] Proceed button state: disabled=${proceedButton.disabled}`);
  }
  
  // Add form validation summary message
  let summaryElement = document.getElementById('validation-summary');
  if (!summaryElement) {
    summaryElement = document.createElement('div');
    summaryElement.id = 'validation-summary';
    summaryElement.style.cssText = `
      padding: 10px 15px; margin: 10px 0; border-radius: 6px; 
      font-size: 13px; font-weight: 500; display: none;
    `;
    
    // Insert summary at the top of the rejection modal
    const rejectionModal = document.querySelector('.rejection-reason-list') || 
                          document.querySelector('.modal-body') || 
                          document.querySelector('.rejection-form');
    if (rejectionModal) {
      rejectionModal.insertBefore(summaryElement, rejectionModal.firstChild);
    }
  }
  
  if (hasInputs) {
    if (allValid) {
      summaryElement.innerHTML = '✅ All tray IDs are valid - Ready to proceed';
      summaryElement.style.display = 'block';
      summaryElement.style.backgroundColor = '#d4edda';
      summaryElement.style.color = '#155724';
      summaryElement.style.border = '1px solid #c3e6cb';
    } else {
      const invalidCount = validationSummary.filter(v => !v.isValid).length;
      summaryElement.innerHTML = `❌ ${invalidCount} invalid tray ID(s) found - Please fix before proceeding (Draft saving still available)`;
      summaryElement.style.display = 'block';
      summaryElement.style.backgroundColor = '#f8d7da';
      summaryElement.style.color = '#721c24';
      summaryElement.style.border = '1px solid #f5c6cb';
    }
  } else {
    summaryElement.style.display = 'none';
  }
  
  console.log('🔧 [updateFormValidationState] Form state updated. Should disable submit buttons:', shouldDisable);
  console.log('✅ [updateFormValidationState] Draft buttons remain enabled regardless of validation');
}

// ✅ Form submission interceptor to prevent submission with invalid tray IDs
function interceptFormSubmission() {
  console.log('🔧 [interceptFormSubmission] Setting up form submission interception');
  
  // Intercept all form submissions
  document.addEventListener('submit', function(event) {
    console.log('🔧 [interceptFormSubmission] Form submission attempted');
    
    const allTrayInputs = document.querySelectorAll('.rejection-tray-id-input');
    let hasInvalidTrayIds = false;
    let invalidTrayIds = [];
    
    allTrayInputs.forEach(input => {
      const trayId = input.value.trim();
      if (trayId && input._isValid !== true) {
        hasInvalidTrayIds = true;
        invalidTrayIds.push(trayId);
      }
    });
    
    if (hasInvalidTrayIds) {
      event.preventDefault();
      event.stopPropagation();
      
      alert(`❌ Cannot proceed with invalid tray IDs: ${invalidTrayIds.join(', ')}\n\nPlease fix all validation errors before submitting.`);
      console.log('🔧 [interceptFormSubmission] ❌ Submission blocked due to invalid tray IDs:', invalidTrayIds);
      return false;
    }
    
    console.log('🔧 [interceptFormSubmission] ✅ Submission allowed - all tray IDs valid');
    return true;
  });
  
  // Intercept button clicks that might trigger submission
  document.addEventListener('click', function(event) {
    const target = event.target;
    
    // ✅ CRITICAL: NEVER block draft or cancel operations
    const targetText = target.textContent.toLowerCase();
    const targetId = target.id.toLowerCase();
    const targetClass = target.className.toLowerCase();
    
    if (targetText.includes('draft') || 
        targetText.includes('cancel') ||
        targetId.includes('draft') ||
        targetId.includes('cancel') ||
        targetClass.includes('draft') ||
        targetClass.includes('cancel')) {
      console.log('✅ [interceptFormSubmission] Draft/Cancel operation - allowing without validation');
      return true; // Allow draft/cancel operations without validation
    }
    
    // Check if this is a proceed/submit button
    if (target.tagName === 'BUTTON' && 
        (targetText.includes('proceed') ||
         targetText.includes('submit') ||
         target.className.includes('btn-primary') ||
         target.className.includes('btn-success'))) {
      
      console.log('🔧 [interceptFormSubmission] Submit button clicked:', target.textContent);
      
      const allTrayInputs = document.querySelectorAll('.rejection-tray-id-input');
      let hasInvalidTrayIds = false;
      let invalidTrayIds = [];
      
      allTrayInputs.forEach(input => {
        const trayId = input.value.trim();
        if (trayId && input._isValid !== true) {
          hasInvalidTrayIds = true;
          invalidTrayIds.push(trayId);
        }
      });
      
      if (hasInvalidTrayIds) {
        event.preventDefault();
        event.stopPropagation();
        
        // Show validation error modal/alert
        const errorMessage = `❌ Cannot proceed with invalid tray IDs:\n\n${invalidTrayIds.map(id => `• ${id}`).join('\n')}\n\nPlease fix all validation errors before proceeding.`;
        
        // Try to show in a nicer modal if available
        if (typeof showModal === 'function') {
          showModal('Validation Error', errorMessage);
        } else {
          alert(errorMessage);
        }
        
        console.log('🔧 [interceptFormSubmission] ❌ Button click blocked due to invalid tray IDs:', invalidTrayIds);
        return false;
      }
    }
  });
}
   











// ✅ Helper function to get total rejection quantity for a specific reason
   function getTotalRejectionQuantityForReason(reasonId) {
   const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"].rejection-qty-input`);
   return qtyInput ? parseInt(qtyInput.value) || 0 : 0;
   }
   
   
   // ✅ NEW: Function to calculate tray distribution with remainder FIRST
   function calculateTrayDistribution(totalQuantity, trayCapacities) {
   const distribution = [];
   
   if (totalQuantity <= 0 || !trayCapacities.length) {
   return distribution;
   }
   
   // Use the first tray capacity as the standard capacity
   const standardCapacity = trayCapacities[0];
   
   // Calculate how many full trays we need and what the remainder is
   const fullTrays = Math.floor(totalQuantity / standardCapacity);
   const remainder = totalQuantity % standardCapacity;
   
   console.log(`Distribution calculation: total=${totalQuantity}, capacity=${standardCapacity}, fullTrays=${fullTrays}, remainder=${remainder}`);
   
   let trayIndex = 0;
   
   // ✅ FIXED: Put remainder FIRST (if there is one)
   if (remainder > 0) {
   distribution.push({
     capacity: trayCapacities[trayIndex] || standardCapacity,
     qty: remainder,
     index: trayIndex
   });
   trayIndex++;
   }
   
   // Then add full capacity trays
   for (let i = 0; i < fullTrays; i++) {
   const currentCapacity = trayCapacities[trayIndex] || standardCapacity;
   distribution.push({
     capacity: currentCapacity,
     qty: Math.min(standardCapacity, currentCapacity), // Use min to respect individual tray limits
     index: trayIndex
   });
   trayIndex++;
   }
   
   console.log(`Final distribution:`, distribution);
   return distribution;
   }
   
   // ✅ NEW: Function to get tray capacities for current lot
   
  function getTrayCapacitiesForCurrentLot() {
    // Try to get from modal data (populated by backend)
    const modal = document.getElementById("trayScanModal");
    if (modal && modal.traysData && modal.traysData.length > 0) {
      return modal.traysData.map(tray => tray.tray_quantity || tray.tray_capacity || 0);
    }
    // Fallback: fetch from backend API (synchronously or via promise)
    // Example API: /inputscreening/ip_completed_tray_id_list/?batch_id=...
    // Or, if not available, return empty array
    return [];
  }



   function addMultipleTrayIdValidationWithDynamic(trayIdCell) {
   const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
   
   trayInputs.forEach(function(input, idx) {
   // Remove existing event listeners
   input.removeEventListener('blur', input._blurHandler);
   input.removeEventListener('input', input._inputHandler);
   input.removeEventListener('keydown', input._keydownHandler);
   
   // Track validation state
   input._hasError = false;
   input._isValidating = false;
   
   // Input event for counter update
   input._inputHandler = function() {
     this._hasError = false;
     const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
     if (errorSpan) {
       errorSpan.style.display = 'none';
       errorSpan.textContent = '';
     }
     updateRejectionScanCounter();

       // --- NEW: On-the-fly validation as user types ---
  const trayId = this.value.trim();
  if (trayId) {
    // Call the same validation as blur, but do NOT block navigation
    // You can copy the blur handler logic here, but do not clear the field on error
    this._isValidating = true;
    fetch(`/inputscreening/delink_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
      .then(res => res.json())
      .then(data => {
        this._isValidating = false;
        if (errorSpan) {
          if (data.exists && data.valid_for_delink) {
            errorSpan.innerHTML = `✅ ${data.status_message || 'Available for Delink'}`;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#155724';
            errorSpan.style.backgroundColor = '#d4edda';
            this.style.backgroundColor = '#d4edda';
            this.style.borderColor = '#28a745';
            this.style.color = '#155724';
          } else {
            errorSpan.innerHTML = `❌ ${data.status_message || 'Invalid for Delink'}`;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
            this.style.backgroundColor = '#f8d7da';
            this.style.borderColor = '#dc3545';
            this.style.color = '#721c24';
          }
        }
      })
      .catch(() => {
        this._isValidating = false;
        if (errorSpan) {
          errorSpan.innerHTML = '❌ Connection Error';
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#721c24';
          errorSpan.style.backgroundColor = '#f8d7da';
        }
      });
  } else {
    // Reset styles if input is empty
    this.style.backgroundColor = '';
    this.style.borderColor = '';
    this.style.color = '';
  }
};
   
   input.addEventListener('input', input._inputHandler);
   
   // Keydown handler
   input._keydownHandler = function(e) {
     if (e.key === 'Enter') {
       e.preventDefault();
       
       if (this._hasError || this._isValidating || !this.value.trim()) {
         return;
       }
       
       const nextInput = trayInputs[idx + 1];
       if (nextInput) {
         nextInput.focus();
      // ✅ NEW: Auto-scroll to center the next input in the modal viewport
      nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
};
   input.addEventListener('keydown', input._keydownHandler);
   
   // ✅ ENHANCED: NEW tray aware validation
   input._blurHandler = function() {
     const trayId = this.value.trim();
     const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
     this._hasError = false;
   
     if (errorSpan) {
       errorSpan.textContent = '';
       errorSpan.style.display = 'none';
     }
   
     if (!trayId) {
       updateRejectionScanCounter();
       return;
     }
   
     this._isValidating = true;
   
     // Check for duplicates within current form
     let isDuplicate = false;
     let duplicateInSameReason = false;
     const currentRow = input.closest('tr');
     const currentReasonId = currentRow ? currentRow.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id') : null;
     
     document.querySelectorAll('.rejection-tray-id-input').forEach(function(otherInput) {
       if (otherInput !== input && otherInput.value.trim() === trayId) {
         isDuplicate = true;
         
         // Check if it's in the same rejection reason (which is not allowed)
         const otherRow = otherInput.closest('tr');
         const otherReasonId = otherRow ? otherRow.querySelector('.rejection-qty-input')?.getAttribute('data-reason-id') : null;
         
         if (currentReasonId && otherReasonId && currentReasonId === otherReasonId) {
           duplicateInSameReason = true;
         }
       }
     });
   
    if (isDuplicate) {
      this._hasError = true;
      this._isValidating = false;
      if (errorSpan) {
        if (duplicateInSameReason) {
          errorSpan.innerHTML = `❌ Same tray cannot be used multiple times for same rejection reason`;
        } else {
          errorSpan.innerHTML = `❌ Duplicate tray ID already used`;
        }
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#dc3545';
        errorSpan.style.backgroundColor = '#f8d7da';
        errorSpan.style.padding = '4px 8px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '11px';
      }
      // Do NOT clear the value. Just select all and keep focus.
      setTimeout(() => {
        this.focus();
        this.select();
        // Do NOT hide the error immediately, let user correct it.
        updateRejectionScanCounter();
      }, 100);
      return;
    }
   
     // ✅ ENHANCED: Collect session allocations with NEW tray tracking
     const currentSessionAllocations = collectCurrentSessionAllocationsWithNewTrayTracking(this);
     const currentLotId = getCurrentLotId();
     const individualTrayQty = parseInt(this.getAttribute('data-tray-qty')) || 0;
     
     const rejectionContext = {
       tray_id: trayId,
       lot_id: currentLotId,
       rejection_qty: individualTrayQty,
       current_session_allocations: JSON.stringify(currentSessionAllocations)
     };
     
     console.log('🔍 NEW tray aware validation context:', rejectionContext);
     
     const queryParams = new URLSearchParams(rejectionContext).toString();
     fetch(`/inputscreening/reject_check_tray_id_simple/?${queryParams}`)
       .then(res => res.json())
       .then(data => {
         this._isValidating = false;
         
         console.log('🔍 Session-aware validation response (with NEW tray logic):', data);
   
         if (errorSpan) {
           if (data.exists && data.valid_for_rejection) {
             this._hasError = false;
             
             // Show available tray quantities and tray count if present
             let availableMsg = '';
             if (Array.isArray(data.available_quantities)) {
               availableMsg = `<br><span style="color:#007bff;font-weight:normal;font-size:11px;">
               </span>`;
             }
   
             let successMessage = `✅ ${data.status_message}${availableMsg}`;
   
                         
            errorSpan.innerHTML = successMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#155724';
            errorSpan.style.backgroundColor = '#d4edda';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '11px';
            
            // Keep focus and select input, do not auto-hide
            setTimeout(() => {
              updateRejectionScanCounter();
            }, 100);
            // Do NOT
             
           } else {
             this._hasError = true;
             
             let errorMessage = `❌ ${data.status_message || 'Invalid'}`;
             
            errorSpan.innerHTML = errorMessage;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.fontSize = '11px';
            
            // Do NOT clear the value or hide the error. Just select all and keep focus.
            setTimeout(() => {
              this.focus();
              this.select();
              updateRejectionScanCounter();
            }, 100);
           }
         } else {
           updateRejectionScanCounter();
         }
       })
      .catch(() => {
        this._isValidating = false;
        this._hasError = true;
        if (errorSpan) {
          errorSpan.innerHTML = '❌ Connection Error';
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#721c24';
          errorSpan.style.backgroundColor = '#f8d7da';
          errorSpan.style.padding = '4px 8px';
          errorSpan.style.borderRadius = '4px';
          errorSpan.style.fontSize = '11px';
          setTimeout(() => {
            this.focus();
            this.select();
            updateRejectionScanCounter();
          }, 100);
        } else {
          updateRejectionScanCounter();
        }
      
       });
   };
   input.addEventListener('blur', input._blurHandler);
   });
   }
   
   // ✅ NEW: Enhanced session allocation collection with NEW tray tracking
   function collectCurrentSessionAllocationsWithNewTrayTracking(excludeInput) {
   const allocations = [];
   
   console.log('📊 [NEW Tray Aware Collection] Starting allocation collection...');
   
   document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
   const qty = parseInt(qtyInput.value) || 0;
   const reasonId = qtyInput.getAttribute('data-reason-id');
   
   if (qty > 0) {
     const row = qtyInput.closest('tr');
     const reasonCell = row.cells[2];
     const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     console.log(`📋 [NEW Tray Aware Collection] Processing reason ${reasonId} (${reasonText}): qty=${qty}, inputs=${trayInputs.length}`);
     
     const validTrayAllocations = [];
     let validTrayCount = 0;
     
     trayInputs.forEach((trayInput, index) => {
       const trayId = trayInput.value.trim();
       
       if (trayInput === excludeInput) {
         console.log(`   ⏭️ Skipping current input ${index + 1}: "${trayId}" (being validated)`);
         return;
       }
       
       if (trayId) {
         const errorSpan = trayInput.parentElement.querySelector('.rejection-tray-error');
         const hasError = errorSpan && 
                          errorSpan.style.display === 'block' && 
                          (errorSpan.textContent.includes('❌') || errorSpan.style.color === '#721c24');
         
         if (!hasError) {
           const individualTrayQty = parseInt(trayInput.getAttribute('data-tray-qty')) || 0;
           
           validTrayAllocations.push({
             tray_id: trayId,
             tray_qty: individualTrayQty,
             is_new_tray: isNewTrayId(trayId)  // ✅ Track if it's a NEW tray
           });
           validTrayCount++;
           console.log(`   ✅ Valid tray ${index + 1}: "${trayId}" (qty: ${individualTrayQty}, new: ${isNewTrayId(trayId)})`);
         } else {
           console.log(`   ❌ Invalid tray ${index + 1}: "${trayId}" (has error)`);
         }
       } else {
         console.log(`   ⭕ Empty tray ${index + 1}`);
       }
     });
     
     if (validTrayCount > 0) {
       validTrayAllocations.forEach(trayAllocation => {
         const allocation = {
           reason_id: reasonId,
           reason_text: reasonText,
           qty: trayAllocation.tray_qty,
           tray_count: 1,
           tray_ids: [trayAllocation.tray_id],
           is_new_tray: trayAllocation.is_new_tray  // ✅ Include NEW tray flag
         };
         
         allocations.push(allocation);
         console.log(`   ✅ Added individual tray allocation:`, allocation);
       });
     } else {
       console.log(`   ⚠️ No valid trays for reason ${reasonId}, skipping allocation`);
     }
   }
   });
   
   console.log('📊 [NEW Tray Aware Collection] FINAL allocations:', allocations);
   return allocations;
   }
               
   // ✅ NEW: Helper function to identify NEW tray IDs (frontend version)
   function isNewTrayId(trayId) {
   // Always return false; let backend decide if a tray is "new"
   return false;
   }
   
   
   // Place this after your existing .rejection-qty-input logic
       document.querySelectorAll('.rejection-qty-input').forEach(function(qtyInput) {
         qtyInput.addEventListener('input', function() {
           const row = qtyInput.closest('tr');
           const trayInput = row.querySelector('.rejection-tray-id-input');
           if (parseInt(qtyInput.value) > 0) {
             trayInput.disabled = false;
             trayInput.required = true;
           } else {
             trayInput.value = '';
             trayInput.disabled = true;
             trayInput.required = false;
           }
           
           // ✅ Check tray capacity violations after quantity change
           setTimeout(() => {
             const capacityViolation = validateAllTrayCapacities();
             if (capacityViolation) {
               console.log('❌ Capacity violation detected after quantity change:', capacityViolation);
               showErrorMessage(capacityViolation);
             }
           }, 100);
         });
         // Optionally, trigger once on page load to set initial state
         qtyInput.dispatchEvent(new Event('input'));
       });
   // Batch rejection checkbox event listener
        // ✅ UPDATED: Batch rejection checkbox event listener with remarks field
       // ✅ FIXED: Batch rejection checkbox event listener
   const batchRejectionCheckbox = document.getElementById("batchRejection");
   const rejectionTableBody = document.getElementById("rejection-table-body");
   const lotRejectionRemarksSection = document.getElementById("lotRejectionRemarksSection");
   const lotRejectionRemarksInput = document.getElementById("lotRejectionRemarksInput");
   const remarksCharCount = document.getElementById("remarksCharCount");
   
   if (batchRejectionCheckbox && rejectionTableBody) {
   batchRejectionCheckbox.addEventListener("change", function () {
   // ✅ FIXED: Target both quantity inputs and tray ID inputs specifically
   const qtyInputs = rejectionTableBody.querySelectorAll(".rejection-qty-input");
   const trayIdInputs = document.querySelectorAll(".rejection-tray-id-input");
   
   if (this.checked) {
     // ✅ Show remarks section when Lot Rejection is checked
     if (lotRejectionRemarksSection) {
       lotRejectionRemarksSection.style.display = "block";
       // Add smooth animation
       lotRejectionRemarksSection.style.opacity = "0";
       lotRejectionRemarksSection.style.transform = "translateY(-10px)";
       setTimeout(() => {
         lotRejectionRemarksSection.style.transition = "all 0.3s ease";
         lotRejectionRemarksSection.style.opacity = "1";
         lotRejectionRemarksSection.style.transform = "translateY(0)";
       }, 50);
       
       // Focus on remarks input
       if (lotRejectionRemarksInput) {
         setTimeout(() => {
           lotRejectionRemarksInput.focus();
         }, 300);
       }
     }
     
     // ✅ FIXED: Disable quantity inputs
     qtyInputs.forEach(input => {
       input.disabled = true;
       input.value = ""; // Clear values
     });
     
     // ✅ FIXED: Disable and clear tray ID inputs
     trayIdInputs.forEach(input => {
       input.disabled = true;
       input.value = "";
       // Clear any error messages
       const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
       if (errorSpan) {
         errorSpan.style.display = 'none';
         errorSpan.textContent = '';
       }
     });
     
     // ✅ FIXED: Hide tray ID containers completely
     document.querySelectorAll('.tray-id-container').forEach(container => {
       container.style.display = 'none';
     });
     
     // ✅ FIXED: Update all tray cells to show "N/A" message
     document.querySelectorAll('#rejection-table-body tr').forEach(row => {
       const trayCell = row.querySelector('td:last-child');
       if (trayCell && !trayCell.textContent.includes('Total Qty')) {
         trayCell.innerHTML = '<span style="color: #666; font-style: italic;">N/A (Lot Rejection)</span>';
       }
     });
     
     document.getElementById('rejection-total-qty').textContent = "0";
     
   } else {
     // ✅ FIXED: Hide remarks section when Lot Rejection is unchecked
     if (lotRejectionRemarksSection) {
       lotRejectionRemarksSection.style.transition = "all 0.3s ease";
       lotRejectionRemarksSection.style.opacity = "0";
       lotRejectionRemarksSection.style.transform = "translateY(-10px)";
       setTimeout(() => {
         lotRejectionRemarksSection.style.display = "none";
       }, 300);
     }
     
     // Clear remarks input
     if (lotRejectionRemarksInput) {
       lotRejectionRemarksInput.value = "";
       if (typeof updateCharCount === 'function') {
         updateCharCount();
       }
     }
     
     // ✅ FIXED: Re-enable quantity inputs
     qtyInputs.forEach(input => {
       input.disabled = false;
     });
     
     // ✅ FIXED: Re-enable existing tray ID inputs
     trayIdInputs.forEach(input => {
       input.disabled = false;
     });
     
     // ✅ FIXED: Show tray ID containers again
     document.querySelectorAll('.tray-id-container').forEach(container => {
       container.style.display = 'flex';
     });
     
     // ✅ FIXED: Restore proper tray cell content based on current quantities
     document.querySelectorAll('#rejection-table-body tr').forEach(row => {
       const qtyInput = row.querySelector('.rejection-qty-input');
       const trayCell = row.querySelector('td:last-child');
       
       if (qtyInput && trayCell && !trayCell.textContent.includes('Total Qty')) {
         const currentQty = parseInt(qtyInput.value) || 0;
         if (currentQty > 0) {
           // Regenerate tray ID inputs for this row
           generateDynamicTrayIdInputs(row, currentQty, trayCell);
         } else {
           // Show default message for empty quantities
           trayCell.innerHTML = '<span style="color: #999; font-style: italic;">Enter quantity first</span>';
         }
       }
     });
   }
   });
   }
       // ✅ NEW: Character count functionality for remarks
       if (lotRejectionRemarksInput && remarksCharCount) {
         function updateCharCount() {
           const currentLength = lotRejectionRemarksInput.value.length;
           remarksCharCount.textContent = currentLength;
   
             remarksCharCount.style.color = "#6c757d"; // Default gray
         
         }
         
         lotRejectionRemarksInput.addEventListener("input", updateCharCount);
         
         // Initialize character count
         updateCharCount();
       }
   
       // ✅ UPDATED: Button event listeners based on mode
       if (isDraftMode) {
         // Update Draft button (renamed to "Draft")

         const draftBtn = document.getElementById("draftButton");
         if (draftBtn) {
           draftBtn.addEventListener("click", () => {
             // ✅ NEW: Set manual draft flag when clicking draft
             window.isManualDraftMode = true;
             handleSaveDraft(stockLotId, batchId);
           });
         }
       }
   
       // Proceed button (works for both modes)
       const proceedBtn = document.getElementById("proceedButton");
       if (proceedBtn) {
         proceedBtn.addEventListener("click", () => handleProceed(stockLotId, batchId, isDraftMode));
       }
   
       // Cancel button
       const cancelBtn = document.getElementById("cancelButton");
      if (cancelBtn) {
   cancelBtn.addEventListener("click", () => {
   // ✅ FIX: Don't auto-save on cancel - only save on explicit draft button click
   console.log('🔄 [cancelButton] Closing modal without auto-save (process status should not be filled)');
   
   document.getElementById("trayScanModal").classList.remove("open");
   
   // ✅ NEW: Also close trayScanModal if it's open
   const trayScanModal = document.getElementById("trayScanModal");
   if (trayScanModal && trayScanModal.classList.contains("open")) {
     trayScanModal.classList.remove("open");
     trayScanModal.style.display = "none";
   }
   
   // Add a slight delay then refresh table data only
   setTimeout(() => {
     location.reload();
   }, 300);
   });
   }
     }
   
     // ✅ NEW: Handle save draft

            
      function handleSaveDraft(stockLotId, batchId) {
        const draftData = collectFormData(stockLotId, batchId);
      
        if (!validateDraftData(draftData)) {
          return;
        }
      
        // Add ip_onhold_picking flag for draft
        draftData.ip_onhold_picking = true;
        fetch('/inputscreening/save_rejection_draft/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(draftData)
        })
        .then(res => {
          if (!res.ok) {
            showErrorMessage('❌ Draft save failed: Network error');
            return;
          }
          return res.text().then(text => {
            let data = {};
            try {
              data = JSON.parse(text);
            } catch (e) {
              showErrorMessage('❌ Draft save failed: Invalid server response');
              return;
            }
            if (data.success) {
              // ✅ NEW: Close the rejection modal
              const trayScanModal = document.getElementById("trayScanModal");
              if (trayScanModal && trayScanModal.classList.contains("open")) {
                trayScanModal.classList.remove("open");
                trayScanModal.style.display = "none";
              }
              // ✅ NEW: Update lot status to "Draft" in the main table
              const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
              if (mainTableRow) {
                const lotStatusCell = mainTableRow.querySelector('td:nth-child(18)');
                if (lotStatusCell) {
                  lotStatusCell.innerHTML = `
                    <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                      style="border: 2px solid #4997ac; background-color: #d1f2f3; color: #03425d;
                      font-size: clamp(0.75rem, 2vw, 0.875rem); white-space: nowrap;
                      padding-top: 0.5rem; padding-bottom: 0.5rem;">
                      Draft
                    </div>
                  `;
                }
              }
              setTimeout(() => {
                location.reload();
              }, 300);
              // Do NOT show the success message
            } else {
              showErrorMessage('❌ Draft save failed: ' + (data.error || 'Unknown error'));
            }
          });
        })
        .catch(() => {
          showErrorMessage('❌ Draft save failed: Network error');
        });
        
      }
      






  

     // ✅ ENHANCED: Handle proceed with retry mechanism for large data sets
     function handleProceed(stockLotId, batchId, isDraftMode) {
       console.log('🚀 [handleProceed] Starting with retry mechanism for large data sets');
       
       const formData = collectFormData(stockLotId, batchId);
   
       // ✅ NEW: Validate total rejection quantity
       const totalQty = formData.total_rejection_qty || 0;
       if (totalQty > 100) {
         const confirmLarge = confirm(`⚠️ Large rejection count detected: ${totalQty} pieces.\n\nThis may take longer to process. Continue?`);
         if (!confirmLarge) {
           console.log('❌ [handleProceed] User cancelled large data submission');
           return;
         }
       }
           
       // Validate form data for final submission
       if (!validateFormDataForProceed(formData)) {
         return;
       }
   
       // If in draft mode, delete draft first, then proceed with normal flow
       if (isDraftMode) {
         fetch('/inputscreening/delete_rejection_draft/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({ lot_id: stockLotId })
         })
         .then(() => {
           // Proceed with normal rejection flow
           proceedWithRejection(formData, stockLotId, batchId);
         })
         .catch(error => {
           console.error('⚠️ [handleProceed] Draft deletion failed, proceeding anyway:', error);
           // Still proceed with rejection even if draft deletion fails
           proceedWithRejection(formData, stockLotId, batchId);
         });
       } else {
         // Normal flow
         proceedWithRejection(formData, stockLotId, batchId);
       }
     }
   
   // Update the collectFormData function to include remarks
   
   // ✅ FIXED: Update collectFormData to properly collect all data
   
   function collectFormData(stockLotId, batchId) {
   const rejection_data = [];
   const tray_scans = [];
  const batchRejectionElem = document.getElementById("batchRejection");
  const is_batch_rejection = batchRejectionElem ? batchRejectionElem.checked : false;
   
   // ✅ UPDATED: Always collect lot rejection remarks if batch rejection is checked
   let lot_rejection_remarks = "";
   if (is_batch_rejection) {
   const remarksInput = document.getElementById("lotRejectionRemarksInput");
   lot_rejection_remarks = remarksInput ? remarksInput.value.trim() : "";
   console.log("📝 Collected lot rejection remarks:", lot_rejection_remarks);
   }
   
   console.log("🔄 [collectFormData] Starting data collection...");
   console.log("📋 is_batch_rejection:", is_batch_rejection);
   
   // Only collect rejection data if NOT batch rejection
   if (!is_batch_rejection) {
   document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
     const qty = parseInt(qtyInput.value) || 0;
     const reasonId = qtyInput.getAttribute('data-reason-id');
     
     if (qty > 0) {
       const row = qtyInput.closest('tr');
       const reasonCell = row.cells[2];
       const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
       
       console.log(`📋 Processing reason ${reasonId} (${reasonText}): qty=${qty}`);
       
       // Add to rejection_data
       rejection_data.push({
         reason_id: reasonId,
         qty: qty,
         reason_text: reasonText
       });
       
       // ✅ FIXED: Collect tray scans for non-SHORTAGE reasons
       if (reasonText.toUpperCase() !== 'SHORTAGE') {
         const trayIdCell = row.querySelector('td:last-child');
         const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
         
         console.log(`   Found ${trayInputs.length} tray inputs for reason ${reasonId}`);
         
         trayInputs.forEach((trayInput, index) => {
           const trayId = trayInput.value ? trayInput.value.trim() : '';
           const individualTrayQty = parseInt(trayInput.getAttribute('data-tray-qty')) || 0;
           const trayCapacity = parseInt(trayInput.getAttribute('data-tray-capacity')) || 0;
           
           // ✅ CRITICAL FIX: Always save tray scan entry even if tray_id is empty (for draft restoration)
           const trayData = {
             reason_id: reasonId,
             tray_id: trayId,
             tray_qty: individualTrayQty,
             tray_index: index,
             reason_text: reasonText
           };
           
           tray_scans.push(trayData);
           console.log(`   ✅ Added tray scan [${index}]: trayId="${trayId}", qty=${individualTrayQty}, capacity=${trayCapacity}`);
         });
       } else {
         console.log(`   ⏭️ Skipping tray scans for SHORTAGE reason`);
       }
     }
   });
   }
   
   const result = {
   lot_id: stockLotId,
   batch_id: batchId,
   rejection_data: rejection_data,
   tray_scans: tray_scans,
   is_batch_rejection: is_batch_rejection,
   lot_rejection_remarks: lot_rejection_remarks,
   total_rejection_qty: rejection_data.reduce((sum, item) => sum + item.qty, 0)
   };
   
   console.log("📤 [collectFormData] Final result:");
   console.log("   - rejection_data:", result.rejection_data);
    console.log("   - is_batch_rejection:", result.is_batch_rejection);
    console.log("   - lot_rejection_remarks:", result.lot_rejection_remarks);
   console.log("   - tray_scans:", result.tray_scans);
   console.log("   - total_rejection_qty:", result.total_rejection_qty);
   
   return result;
   }
   
   // ✅ Make function globally accessible
   window.collectFormData = collectFormData;
   
     // Update validation functions to include remarks validation
     
     // ✅ FIXED: Update the validateDraftData function to properly recognize tray scans
     
     function validateDraftData(formData) {
       console.log('🔍 [validateDraftData] Validating form data:', formData);
       
       if (formData.is_batch_rejection) {
         const remarksInput = document.getElementById("lotRejectionRemarksInput");
         const remarks = remarksInput ? remarksInput.value.trim() : "";
         
         // ✅ FIXED: For draft, only require remarks to be present (not minimum length)
         if (!remarks) {
           showErrorMessage('Please enter some remarks before saving as draft.');
           if (remarksInput) {
             remarksInput.focus();
             remarksInput.style.borderColor = "#dc3545";
             remarksInput.style.boxShadow = "0 0 0 0.2rem rgba(220, 53, 69, 0.25)";
           }
           return false;
         }
         
         console.log("✅ Lot rejection draft with remarks - validation passed");
         return true;
       }
     
       // ✅ FIXED: Check for rejection data OR tray scans (not AND)
       const hasRejectionData = formData.rejection_data && formData.rejection_data.length > 0;
       const hasTrayScans = formData.tray_scans && formData.tray_scans.length > 0;
       
       console.log('🔍 [validateDraftData] Data check:');
       console.log('   - hasRejectionData:', hasRejectionData);
       console.log('   - hasTrayScans:', hasTrayScans);
       console.log('   - rejection_data:', formData.rejection_data);
       console.log('   - tray_scans:', formData.tray_scans);
       
       // ✅ FIXED: Allow draft save if we have EITHER rejection quantities OR tray scans
       if (!hasRejectionData && !hasTrayScans) {
         showErrorMessage('Please enter at least some rejection data before saving as draft.');
         return false;
       }
     
       console.log("✅ Draft validation passed");
       return true;
     }
   
   
   // ✅ SIMPLIFIED: Update validation logic to use new calculation
   function validateFormDataForProceed(formData) {
   
   if (formData.is_batch_rejection) {
   // ✅ Validate lot rejection remarks
   const remarksInput = document.getElementById("lotRejectionRemarksInput");
   const remarks = remarksInput ? remarksInput.value.trim() : "";
   
   if (!remarks) {
     showErrorMessage('Lot rejection remarks are required when rejecting the entire lot.');
     if (remarksInput) {
       remarksInput.focus();
       remarksInput.style.borderColor = "#dc3545";
       remarksInput.style.boxShadow = "0 0 0 0.2rem rgba(220, 53, 69, 0.25)";
     }
     return false;
   }
   
   
   console.log("✅ Lot rejection with valid remarks - validation passed");
   return true;
   }
   
   if (formData.rejection_data.length === 0) {
   showErrorMessage('Please enter at least one rejection quantity.');
   return false;
   }
   
   // Check if ALL rejections are SHORTAGE
   const isAllShortage = formData.rejection_data.every(item => {
   const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
   if (reasonElement) {
     const reasonCell = reasonElement.closest('tr').cells[2];
     const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
     return reasonText === 'SHORTAGE';
   }
   return false;
   });
   
   if (isAllShortage) {
   console.log("✅ All SHORTAGE rejections - no tray scans required");
   return true;
   }
   
   // ✅ SIMPLIFIED: Validate tray scanning requirements
   let validationErrors = [];
   
   // Get tray capacity
   const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                    document.querySelector('[data-stock-lot-id]') ||
                    document.querySelector('tbody tr');
   let trayCapacity = 16; // Default to Normal capacity
   if (currentRow) {
   const trayCapacityText = currentRow.cells[7]?.textContent || '';
   if (trayCapacityText.includes('-')) {
     // ✅ ENHANCED: Use proper default based on tray type
     const trayTypeName = trayCapacityText.split('-')[0]?.toLowerCase() || '';
     const defaultCapacity = trayTypeName.includes('jumbo') ? 12 : 16;
     trayCapacity = parseInt(trayCapacityText.split('-')[1]) || defaultCapacity;
   }
   }
   
   console.log(`🔧 Using tray capacity: ${trayCapacity} for validation`);
   
   formData.rejection_data.forEach(item => {
   const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
   if (!reasonElement) return;
   
   const reasonCell = reasonElement.closest('tr').cells[2];
   const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
   
   if (reasonText !== 'SHORTAGE') {
     const row = reasonElement.closest('tr');
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     // ✅ SIMPLIFIED: Calculate expected number of trays
     const expectedTrays = Math.ceil(item.qty / trayCapacity);
     
     console.log(`🔍 Validating ${reasonText}: qty=${item.qty}, expectedTrays=${expectedTrays}, foundInputs=${trayInputs.length}`);
     
     // Check if we have the right number of inputs
     if (trayInputs.length !== expectedTrays) {
       validationErrors.push(`${reasonText}: Expected ${expectedTrays} tray input(s), found ${trayInputs.length}`);
     }
     
     // ✅ NEW: Check for duplicate tray IDs within this rejection reason
     const trayIds = [];
     const duplicates = [];
     trayInputs.forEach((input, index) => {
       const trayId = input.value.trim().toUpperCase();
       if (trayId) {
         if (trayIds.includes(trayId)) {
           duplicates.push(trayId);
         } else {
           trayIds.push(trayId);
         }
       }
     });
     
     if (duplicates.length > 0) {
       validationErrors.push(`${reasonText}: Duplicate tray IDs found: ${duplicates.join(', ')}`);
     }
     
     // ✅ NEW: Check for invalid tray IDs (check the _isValid property set by validation)
     const invalidTrays = [];
     trayInputs.forEach((input, index) => {
       const trayId = input.value.trim();
       if (trayId && input._isValid === false) {
         invalidTrays.push(trayId);
       }
     });
     
     if (invalidTrays.length > 0) {
       validationErrors.push(`${reasonText}: Invalid tray IDs: ${invalidTrays.join(', ')}`);
     }
     
     // ✅ NEW: Check for empty tray IDs in required positions
     const emptyTrays = [];
     trayInputs.forEach((input, index) => {
       const trayId = input.value.trim();
       if (!trayId) {
         emptyTrays.push(`Tray ${index + 1}`);
       }
     });
     
     if (emptyTrays.length > 0) {
       validationErrors.push(`${reasonText}: Missing tray IDs for: ${emptyTrays.join(', ')}`);
     }
     
     // Check if all inputs are filled
     let missingTrayIds = 0;
     trayInputs.forEach((trayInput, index) => {
       const trayId = trayInput.value.trim();
       if (!trayId) {
         missingTrayIds++;
       }
     });
     
     if (missingTrayIds > 0) {
       validationErrors.push(`${reasonText}: Missing ${missingTrayIds} tray ID(s)`);
     }
   }
   });
   
   if (validationErrors.length > 0) {
   showErrorMessage(`Validation errors:\n• ${validationErrors.join('\n• ')}`);
   console.log("❌ Validation errors:", validationErrors);
   return false;
   }
   
   console.log("✅ Validation passed");
   return true;
   }
   
   
   
   // ✅ UPDATED: Enhanced error message display
   function showErrorMessage(message) {
   const msgDiv = document.getElementById("batchRejectionMsg");
   if (msgDiv) {
   msgDiv.style.color = "#d32f2f";
   msgDiv.style.backgroundColor = "#ffebee";
   msgDiv.style.border = "1px solid #f44336";
   msgDiv.style.padding = "8px 12px";
   msgDiv.style.borderRadius = "4px";
   msgDiv.style.marginTop = "10px";
   msgDiv.textContent = message;
   
   // Auto-hide after 8 seconds
   setTimeout(() => {
     msgDiv.textContent = "";
     msgDiv.style.backgroundColor = "";
     msgDiv.style.border = "";
     msgDiv.style.padding = "";
      }, 8000);
   }
   
   // Also log to console
   console.log("❌ Error:", message);
   }
   
   
   
     // ✅ NEW: Proceed with actual rejection (existing logic)
     function proceedWithRejection(formData, stockLotId, batchId) {
       if (formData.is_batch_rejection) {
         // Handle batch rejection
         handleBatchRejection(batchId, stockLotId);
       } else {
         // Handle tray-wise rejection  
         handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData);
       }
     }
   
     // ✅ ENHANCED: Handle tray-wise rejection with improved error handling for large data sets
   function handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData) {
   const msgDiv = document.getElementById("batchRejectionMsg");
   const proceedButton = document.getElementById("proceedButton");
   
   if (proceedButton) {
     proceedButton.disabled = true;
     proceedButton.textContent = 'Processing...';
   }
   
   // Show progress message for large data sets
   const totalQty = formData.total_rejection_qty || 0;
   if (totalQty > 50 && msgDiv) {
     msgDiv.style.color = "#007bff";
     msgDiv.textContent = `Processing ${totalQty} pieces... Please wait.`;
   }
   
   console.log('📤 [handleTrayWiseRejection] Sending data:', {
     tray_scans: formData.tray_scans.length,
     rejection_data: formData.rejection_data.length,
     total_qty: totalQty
   });
   
   // ✅ NEW: Configure timeout based on data size (20 seconds base + 1 second per 10 pieces)
   const timeoutMs = 20000 + Math.ceil(totalQty / 10) * 1000;
   const controller = new AbortController();
   const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
   
   console.log(`⏱️ [handleTrayWiseRejection] Configured timeout: ${timeoutMs}ms for ${totalQty} pieces`);
   
   // Send to server with correct parameter names
   fetch('/inputscreening/tray_rejection/', {
   method: 'POST',
   headers: {
     'Content-Type': 'application/json',
     'X-CSRFToken': getCookie('csrftoken')
   },
   body: JSON.stringify({
     lot_id: stockLotId,
     batch_id: batchId,
     tray_scans: formData.tray_scans,
     rejection_data: formData.rejection_data
   }),
   signal: controller.signal
   })
   .then(res => {
     clearTimeout(timeoutId);
     if (!res.ok) {
       throw new Error(`Server responded with status: ${res.status}`);
     }
     return res.json();
   })
   .then(data => {
   console.log('📤 [handleTrayWiseRejection] Server response received:', data);
   if (data.success) {
     console.log('✅ [handleTrayWiseRejection] Rejection saved successfully!');
     // Disable all inputs
     document.querySelectorAll('.rejection-qty-input, .rejection-tray-id-input').forEach(input => {
       input.disabled = true;
     });
     
     window.trayRejectionSaved = true;
     
     if (msgDiv) {
       msgDiv.style.color = "#388e3c";
       msgDiv.textContent = "Rejected Tray saved!";
     }

     // Disable Draft and Proceed buttons after success
    const draftBtn = document.getElementById("draftButton");
    const proceedBtn = document.getElementById("proceedButton");
    if (draftBtn) {
      draftBtn.disabled = true;
      draftBtn.style.opacity = "0.6";
      draftBtn.style.cursor = "not-allowed";
    }
    if (proceedBtn) {
      proceedBtn.disabled = true;
      proceedBtn.style.opacity = "0.6";
      proceedBtn.style.cursor = "not-allowed";
    }
   
     // Update main table row
     const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
     if (mainTableRow) {
       // Update Lot Status cell
       const lotStatusCell = mainTableRow.querySelector('td:nth-child(18)');
       
       if (lotStatusCell) {
         lotStatusCell.innerHTML = `
           <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
             style="border: 2px solid #4997ac; background-color: #d1f2f3; color: #03425d;
             font-size: clamp(0.75rem, 2vw, 0.875rem); white-space: nowrap;
             padding-top: 0.5rem; padding-bottom: 0.5rem;">
             Draft
           </div>
         `;
       }
   
       // Disable Accept button
       const acceptBtn = mainTableRow.querySelector('.btn-twitter');
       if (acceptBtn) {
         acceptBtn.disabled = true;
         acceptBtn.style.pointerEvents = 'none';
         acceptBtn.style.opacity = '0.6';
         acceptBtn.style.cursor = 'not-allowed';
         acceptBtn.innerHTML = `<i class="fa fa-check-circle"></i>Accept`;
         acceptBtn.classList.add('disabled');
       }
     
// Enable Reject button (not Set Top Tray - user is in rejection workflow)
     const partialRejectBtn = mainTableRow.querySelector('.btn-youtube.tray-scan-btn');
     if (partialRejectBtn) {
       partialRejectBtn.disabled = false;
       partialRejectBtn.style.pointerEvents = 'auto';
       partialRejectBtn.style.opacity = '1';
       partialRejectBtn.style.cursor = 'pointer';
       partialRejectBtn.innerHTML = `<i class="fa fa-times-circle"></i>Reject`;
         partialRejectBtn.style.backgroundColor = '#e57373';
         partialRejectBtn.classList.remove('disabled');
       }
     
       // Set Process Status "S" icon to half-filled
       const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
       if (processIcons.length > 1) {
         processIcons[1].style.background = 'linear-gradient(to right, #0c8249 50%, #bdbdbd 50%)';
       }
   
       // Update quantities if provided in response
       if (data.lot_qty !== undefined) {
         const lotQtySpan = mainTableRow.querySelector('td:nth-child(11) .lot-qty');
         if (lotQtySpan) {
           lotQtySpan.textContent = data.lot_qty;
           lotQtySpan.style.backgroundColor = '#fff3cd';
           lotQtySpan.style.borderRadius = '4px';
           setTimeout(() => { lotQtySpan.style.backgroundColor = ''; }, 1200);
         }
       }
       
       if (data.physical_qty !== undefined) {
         const physicalQtyInput = mainTableRow.querySelector('td:nth-child(12) .physical-qty-input');
         if (physicalQtyInput) {
           physicalQtyInput.value = data.physical_qty;
           physicalQtyInput.style.backgroundColor = '#fff3cd';
           physicalQtyInput.style.borderColor = '#ffc107';
           setTimeout(() => { 
             physicalQtyInput.style.backgroundColor = ''; 
             physicalQtyInput.style.borderColor = ''; 
           }, 1200);
         }
       }
     }
     
     // Continue with accepted tray modal
     console.log('🚀 [handleTrayWiseRejection] SUCCESS - Now opening set top tray window');
     console.log('🚀 [handleTrayWiseRejection] About to close rejection modal');
     
     // First close the rejection modal
     const rejectionModal = document.getElementById("trayScanModal");
     if (rejectionModal) {
       rejectionModal.style.display = "none";
       rejectionModal.classList.remove("open");
       console.log('🚀 [handleTrayWiseRejection] Rejection modal closed');
     }
     
     console.log('🚀 [handleTrayWiseRejection] About to fetch accepted tray scan data for lot:', stockLotId);
     
     fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
       .then(res => {
         console.log('🚀 [handleTrayWiseRejection] API Response status:', res.status);
         return res.json();
       })
       .then(rescanData => {
         console.log('🚀 [handleTrayWiseRejection] API Response data:', rescanData);
         if (rescanData.success) {
           console.log('🚀 [handleTrayWiseRejection] About to call showAcceptedTrayModal');
           showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
           console.log('🚀 [handleTrayWiseRejection] showAcceptedTrayModal called successfully');
         } else {
           console.error('❌ [handleTrayWiseRejection] API returned error:', rescanData.error);
           alert('Failed to load accepted tray data: ' + (rescanData.error || 'Unknown error'));
         }
       })
       .catch(error => {
         console.error('❌ [handleTrayWiseRejection] Error fetching accepted tray data:', error);
         alert('Error opening set top tray window: ' + error.message);
       });
       
   } else {
     // ✅ ENHANCED: Detailed error handling
     const errorMessage = data.error || "Failed to save tray rejection";
     console.error('❌ [handleTrayWiseRejection] Server error:', errorMessage, data);
     
     if (msgDiv) {
       msgDiv.style.color = "#d32f2f";
       // ✅ NEW: More specific error messages
       if (errorMessage.includes('timeout') || errorMessage.includes('Timeout')) {
         msgDiv.innerHTML = `⏱️ ${errorMessage}<br><small>Large data set may require longer processing time. Data has been saved as draft.</small>`;
       } else if (errorMessage.includes('duplicate') || errorMessage.includes('Duplicate')) {
         msgDiv.innerHTML = `❌ ${errorMessage}<br><small>Please check for duplicate tray IDs.</small>`;
       } else {
         msgDiv.textContent = errorMessage;
       }
     }
     
     if (proceedButton) {
       proceedButton.disabled = false;
       proceedButton.textContent = 'Proceed';
     }
   }
   })
   .catch((error) => {
   clearTimeout(timeoutId);
   console.error('❌ [handleTrayWiseRejection] Network error:', error);
   
   if (msgDiv) {
     msgDiv.style.color = "#d32f2f";
     
     // ✅ ENHANCED: Specific error messages based on error type
     if (error.name === 'AbortError') {
       msgDiv.innerHTML = `⏱️ Request timed out after ${Math.ceil(timeoutMs/1000)} seconds.<br><small>Processing ${totalQty} pieces took too long. Your data has been auto-saved as draft. Please try again or contact support.</small>`;
       
       // ✅ NEW: Auto-save as draft on timeout
       setTimeout(() => {
         const draftBtn = document.getElementById("draftButton");
         if (draftBtn) {
           console.log('🔄 [handleTrayWiseRejection] Auto-saving as draft after timeout');
           draftBtn.click();
         }
       }, 2000);
       
     } else if (error.message.includes('Failed to fetch')) {
       msgDiv.innerHTML = `❌ Network connection failed.<br><small>Check your internet connection and try again.</small>`;
     } else if (error.message.includes('status: 500')) {
       msgDiv.innerHTML = `❌ Server error occurred.<br><small>Contact system administrator. Error: ${error.message}</small>`;
     } else if (error.message.includes('status: 413')) {
       msgDiv.innerHTML = `❌ Data size too large (${totalQty} pieces).<br><small>Try processing in smaller batches.</small>`;
     } else {
       msgDiv.innerHTML = `❌ Error: ${error.message}<br><small>Your data may have been saved as draft. Please refresh and check.</small>`;
     }
   }
   
   if (proceedButton) {
     proceedButton.disabled = false;
     proceedButton.textContent = 'Retry';
   }
   });
   }
    //showSuccessMessage
    function showSuccessMessage(message, color = '#28a745') {
      // Remove existing indicator
      let indicator = document.getElementById('auto-save-indicator');
      if (indicator) indicator.remove();
    
      indicator = document.createElement('div');
      indicator.id = 'auto-save-indicator';
      indicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 999999;
        background: ${color};
        color: #fff;
        padding: 18px 36px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: 600;
        box-shadow: 0 4px 24px rgba(0,0,0,0.18);
        opacity: 1;
        transition: opacity 0.3s;
        text-align: center;
        pointer-events: none;
      `;
      indicator.textContent = message;
      document.body.appendChild(indicator);
    
      setTimeout(() => {
        indicator.style.opacity = '0';
        setTimeout(() => indicator.remove(), 400);
      }, 2000);
    }
   
    function showErrorNotification(message) {
      let notification = document.getElementById('error-notification');
      if (!notification) {
        notification = document.createElement('div');
        notification.id = 'error-notification';
        notification.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 999999;
          background: #dc3545;
          color: #fff;
          padding: 18px 36px;
          border-radius: 10px;
          font-size: 18px;
          font-weight: 600;
          box-shadow: 0 4px 24px rgba(0,0,0,0.18);
          opacity: 1;
          transition: opacity 0.3s;
          text-align: center;
          pointer-events: none;
        `;
        document.body.appendChild(notification);
      }
      notification.textContent = message;
      notification.style.opacity = '1';
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 400);
      }, 2000);
    }


        function showLoadingOverlay() {
      if (document.getElementById('loading-overlay')) return;
      const overlay = document.createElement('div');
      overlay.id = 'loading-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.35);
        z-index: 1000000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      overlay.innerHTML = `
        <div style="background: #fff; padding: 32px 48px; border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.18); display: flex; flex-direction: column; align-items: center;">
          <div class="spinner" style="border: 6px solid #f3f3f3; border-top: 6px solid #028084; border-radius: 50%; width: 48px; height: 48px; animation: spin 1s linear infinite;"></div>
          <div style="margin-top: 18px; font-size: 20px; color: #028084; font-weight: 600;">Draft Save Successfully</div>
        </div>
        <style>
          @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
        </style>
      `;
      document.body.appendChild(overlay);
    }
    function hideLoadingOverlay() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) overlay.remove();
    }
   
    // Make functions globally available
    window.showLoadingOverlay = showLoadingOverlay;
    window.hideLoadingOverlay = hideLoadingOverlay;
   
   
     
     // Helper function to get current lot ID
     function getCurrentLotId() {
       const modal = document.getElementById("trayScanModal");
       return modal?.dataset?.stockLotId || '';
     }
   
   // ✅ SIMPLIFIED: collectCurrentSessionAllocations function for frontend compatibility
   function collectCurrentSessionAllocations(excludeInput) {
     const allocations = [];
     
     console.log('📊 [collectCurrentSessionAllocations] Starting allocation collection...');
     
     document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
       const qty = parseInt(qtyInput.value) || 0;
       const reasonId = qtyInput.getAttribute('data-reason-id');
       
       if (qty > 0) {
         const row = qtyInput.closest('tr');
         const reasonCell = row.cells[2];
         const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
         
         console.log(`📋 [collectCurrentSessionAllocations] Processing reason ${reasonId} (${reasonText}): qty=${qty}`);
         
         // For the new simplified logic, we just need the basic rejection quantities
         allocations.push({
           reason_id: reasonId,
           reason_text: reasonText,
           qty: qty,
           rejection_qty: qty  // Add both for compatibility
         });
       }
     });
     
     console.log('📊 [collectCurrentSessionAllocations] FINAL allocations:', allocations);
     return allocations;
   }

   // ✅ ENHANCED: Update rejection scan counter with quantity tracking
   function updateRejectionScanCounter() {
   const counter = document.getElementById('rejectionScanCounter');
   const status = document.getElementById('rejectionScanStatus');
   const progressBar = document.querySelector('#rejectionScanProgress > div');
   const distributionInfo = document.getElementById('trayDistributionInfo');
   const distributionDetails = document.getElementById('trayDistributionDetails');
   
   if (!counter) return;
   
   let totalRequiredScans = 0;
   let completedScans = 0;
   let distributionHTML = '';
   let shortageOnly = [];
   
   // Get current session allocations for better tracking
   const currentAllocations = collectCurrentSessionAllocations(null);
   
   console.log('🔄 [Counter Update] Current allocations:', currentAllocations);
   
   // Calculate total required scans and completed scans
   document.querySelectorAll('.rejection-qty-input').forEach(input => {
   const qty = parseInt(input.value) || 0;
   const row = input.closest('tr');
   const reasonCell = row.cells[2];
   const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
   const reasonId = input.getAttribute('data-reason-id');
   
   if (qty > 0 && reasonText !== 'SHORTAGE') {
     const trayIdCell = row.querySelector('td:last-child');
     const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
     
     // Calculate expected trays for this quantity
     const trayCapacity = getCurrentTrayCapacity();
     const expectedTrays = Math.ceil(qty / trayCapacity);
     totalRequiredScans += expectedTrays;
     
     // Find matching allocation for accurate count
     const matchingAllocation = currentAllocations.find(alloc => alloc.reason_id === reasonId);
     const actualCompletedTrays = matchingAllocation ? matchingAllocation.tray_count : 0;
     
     completedScans += actualCompletedTrays;
     
     // Enhanced distribution info
     let status = '';
     if (actualCompletedTrays === 0) {
       status = '⏳ Pending';
     } else if (actualCompletedTrays < expectedTrays) {
       status = `🔄 ${actualCompletedTrays}/${expectedTrays}`;
     } else {
       status = '✅ Complete';
     }
     
     distributionHTML += `
       <div style="margin-bottom: 4px; padding: 6px; border-radius: 4px; ${actualCompletedTrays === expectedTrays ? 'background-color: #d4edda;' : actualCompletedTrays > 0 ? 'background-color: #fff3cd;' : 'background-color: #f8d7da;'}">
         <span style="font-weight: 600; color: #007bff;">${reasonText}:</span>
         <span>Qty ${qty} → ${expectedTrays} tray${expectedTrays > 1 ? 's' : ''} ${status}</span>
       </div>
     `;
   } else if (qty > 0 && reasonText === 'SHORTAGE') {
     shortageOnly.push(`${reasonText}: ${qty}`);
   }
   });
   
   // Update distribution info
   if (distributionHTML) {
   distributionDetails.innerHTML = distributionHTML;
   distributionInfo.style.display = 'block';
   } else {
   distributionInfo.style.display = 'none';
   }
   
   // Update counter with enhanced information
   if (counter) {
   counter.textContent = `${completedScans}/${totalRequiredScans}`;
   
   // Enhanced color coding
   if (completedScans === totalRequiredScans && totalRequiredScans > 0) {
     counter.style.color = '#28a745'; // Green when complete
     counter.style.backgroundColor = '#d4edda';
   } else if (completedScans > 0) {
     counter.style.color = '#ffc107'; // Yellow when in progress  
     counter.style.backgroundColor = '#fff3cd';
   } else {
     counter.style.color = '#dc3545'; // Red when not started
     counter.style.backgroundColor = '#f8d7da';
   }
   
   counter.style.padding = '4px 8px';
   counter.style.borderRadius = '12px';
   counter.style.fontWeight = 'bold';
   }
   
   console.log(`🔄 [Counter Update] Total: ${completedScans}/${totalRequiredScans}`);
   }
   
   // ✅ REMOVE: Delete the old calculateCompleteTraysFromActualDistribution function
   // This function is no longer needed with the simplified logic
   
   console.log("✅ Simplified tray logic loaded - now supports:");
   console.log("   • Qty 1-12 (with capacity 12): 1 tray");
   console.log("   • Qty 13-24 (with capacity 12): 2 trays");
   console.log("   • Qty 25-36 (with capacity 12): 3 trays");
   console.log("   • etc.");
   
   // ✅ NEW: Initialize enhanced counter
   document.addEventListener('DOMContentLoaded', function() {
   updateRejectionScanCounter();
   });
   
   
   // ✅ HELPER: Get current tray capacity
   function getCurrentTrayCapacity() {
   const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                    document.querySelector('[data-stock-lot-id]') ||
                    document.querySelector('tbody tr');
   
   if (currentRow) {
   const trayCapacityText = currentRow.cells[7]?.textContent || '';
   if (trayCapacityText.includes('-')) {
     return parseInt(trayCapacityText.split('-')[1]) || 12;
   }
   }
   
   return 12; // Default capacity
   }
   
     // ✅ EXISTING: Handle batch rejection (unchanged)
     function handleBatchRejection(batchId, stockLotId) {
       const msgDiv = document.getElementById("batchRejectionMsg");
       const proceedButton = document.getElementById("proceedButton");
       const totalQty = document.getElementById('rejection-total-qty').textContent || "0";

       if (!batchId || !stockLotId) {
         if (msgDiv) msgDiv.textContent = "Batch ID or Lot ID not found.";
         if (proceedButton) proceedButton.disabled = false;
         return;
       }
       
       fetch('/inputscreening/batch_rejection/', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': getCookie('csrftoken')
         },
         body: JSON.stringify({
           batch_id: batchId,
           lot_id: stockLotId,
           total_qty: totalQty,
           lot_rejection_remarks: document.getElementById('lotRejectionRemarksInput')?.value?.trim() || ""


           
         })
       })
       .then(res => res.json())
       .then(data => {
         if (data.success) {
           if (msgDiv) {
             msgDiv.style.color = "#388e3c";
             msgDiv.textContent = "Lot rejection saved!";
           }
           updateUIForBatchRejection(batchId);
           setTimeout(() => {
             trayModal.classList.remove("open");
             if (msgDiv) msgDiv.textContent = "";
             window.location.reload();
           }, 1200);
         } else {
           if (msgDiv) {
             msgDiv.style.color = "#d32f2f";
             msgDiv.textContent = data.error || "Failed to save batch rejection";
           }
           if (proceedButton) proceedButton.disabled = false;
         }
       })
       .catch(() => {
         if (msgDiv) {
           msgDiv.style.color = "#d32f2f";
           msgDiv.textContent = "Network error";
         }
         if (proceedButton) proceedButton.disabled = false;
       });
     }
   
     // ✅ NEW: Add redo functionality for rejection tray scan
     document.addEventListener('click', function(e) {
       if (e.target.id === 'rejectionTrayRedoBtn') {
         document.querySelectorAll('.rejection-tray-id-input').forEach(function(input) {
           input.value = '';
           const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
           if (errorSpan) {
             errorSpan.style.display = 'none';
             errorSpan.textContent = '';
           }
         });
         updateRejectionScanCounter();
       }
     });
   
   
   
     // Function to fetch and show normal accepted tray data
     function fetchAndShowAcceptedTrayData(lotId) {
       fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
         .then(res => res.json())
         .then(rescanData => {
           if (rescanData.success) {
             showAcceptedTrayModal(rescanData, lotId, false);
           }
         })
         .catch(error => {
         });
     }
   
   // ✅ NEW: Centralized modal close handler to prevent conflicts
   function closeAcceptedTrayModalHandler() {
     console.log('🔴 Closing accepted tray modal with proper cleanup');
     
     // Close modal
     const modal = document.getElementById("newPopupModal");
     if (modal) {
       modal.classList.remove("open");
     }
     
     // Restore row position (if function exists)
     if (typeof restoreRowPosition === 'function') {
       restoreRowPosition();
     }
     
     // Use a single, delayed reload to prevent conflicts
     if (!window.modalReloadPending) {
       window.modalReloadPending = true;
       setTimeout(() => {
         window.location.reload();
       }, 400); // Slightly longer delay for smooth transition
     }
   }
   
     // Function to show read-only accepted tray data (for draft mode)
     function showReadOnlyAcceptedTrayData(lotId, detailsDiv) {
       fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
         .then(res => res.json())
         .then(data => {
           if (data.success && data.has_draft) {
             showAcceptedTrayModal(data, lotId, true);
           } else {
             // No draft exists, proceed with normal flow
             fetchAndShowAcceptedTrayData(lotId);
           }
         })
         .catch(error => {
           // Fallback to normal flow
           fetchAndShowAcceptedTrayData(lotId);
         });
     }
   
   // ✅ FIXED: Function to check if a tray ID is a placeholder
   function isPlaceholderTrayId(trayId) {
   return trayId && trayId.startsWith('DELINK_ONLY_');
   }
   
// ✅ NEW: Global function to force enable draft buttons
function forceEnableDraftButtons() {
  console.log('🔧 [forceEnableDraftButtons] Forcing draft buttons to be enabled');
  
  const draftButtonIds = [
    'acceptedTrayDraftBtn',
    'acceptedTrayUpdateDraftBtn',
    'acceptedTrayCancelBtn'
  ];
  
  draftButtonIds.forEach(btnId => {
    const btn = document.getElementById(btnId);
    if (btn) {
      // Remove all disabling attributes and styles
      btn.disabled = false;
      btn.removeAttribute('disabled');
      btn.removeAttribute('aria-disabled');
      btn.classList.remove('disabled');
      
      // Force enable styles with !important
      btn.style.setProperty('pointer-events', 'auto', 'important');
      btn.style.setProperty('z-index', '900004', 'important');
      btn.style.setProperty('cursor', 'pointer', 'important');
      btn.style.setProperty('opacity', '1', 'important');
      btn.style.setProperty('filter', 'none', 'important');
      btn.style.setProperty('background-color', '', 'important'); // Reset to default
      
      // Remove any blocking event handlers
      btn.onclick = null;
      
      console.log(`✅ [forceEnableDraftButtons] Force-enabled: ${btnId}`);
    }
  });
  
  return true; // Indicate success
}

// ✅ Make the function globally available
window.forceEnableDraftButtons = forceEnableDraftButtons;

// ✅ NEW: Global function to force enable rejection form draft buttons
function forceEnableRejectionDraftButtons() {
  console.log('🔧 [forceEnableRejectionDraftButtons] Forcing rejection draft buttons to be enabled');
  
  // Find all possible draft button selectors for rejection form
  const draftButtonSelectors = [
    '#draftBtn',
    'button[onclick*="draft"]',
    'button[data-action="draft"]',
    'button[id*="draft"]',
    'button[class*="draft"]'
  ];
  
  const cancelButtonSelectors = [
    '#cancelBtn',
    '#cancelButton',
    'button[onclick*="cancel"]',
    'button[id*="cancel"]',
    'button[class*="cancel"]'
  ];
  
  // Force enable all draft buttons
  [...draftButtonSelectors, ...cancelButtonSelectors].forEach(selector => {
    const buttons = document.querySelectorAll(selector);
    buttons.forEach(btn => {
      if (btn) {
        btn.disabled = false;
        btn.removeAttribute('disabled');
        btn.removeAttribute('aria-disabled');
        btn.classList.remove('disabled');
        
        // ✅ ENHANCED: Force original colors based on button type
        let originalColor = '#f39c12'; // Default orange for draft
        if (btn.textContent.toLowerCase().includes('cancel')) {
          originalColor = '#dc3545'; // Red for cancel
        } else if (btn.textContent.toLowerCase().includes('update')) {
          originalColor = '#f39c12'; // Orange for update draft
        }
        
        // Force enable styles with !important
        btn.style.setProperty('pointer-events', 'auto', 'important');
        btn.style.setProperty('cursor', 'pointer', 'important');
        btn.style.setProperty('opacity', '1', 'important');
        btn.style.setProperty('filter', 'none', 'important');
        btn.style.setProperty('background-color', originalColor, 'important');
        btn.style.setProperty('color', 'white', 'important');
        btn.style.setProperty('border', 'none', 'important');
        btn.style.setProperty('border-radius', '30px', 'important');
        
        console.log(`✅ [forceEnableRejectionDraftButtons] Force-enabled: ${btn.id || btn.textContent} with color ${originalColor}`);
      }
    });
  });
  
  // Also find buttons by text content
  const allButtons = document.querySelectorAll('button');
  allButtons.forEach(btn => {
    const text = btn.textContent.toLowerCase();
    if (text.includes('draft') || text.includes('cancel')) {
      btn.disabled = false;
      btn.removeAttribute('disabled');
      btn.removeAttribute('aria-disabled');
      btn.classList.remove('disabled');
      
      // ✅ ENHANCED: Set original colors
      let originalColor = '#f39c12'; // Default orange for draft
      if (text.includes('cancel')) {
        originalColor = '#dc3545'; // Red for cancel
      }
      
      btn.style.setProperty('pointer-events', 'auto', 'important');
      btn.style.setProperty('cursor', 'pointer', 'important');
      btn.style.setProperty('opacity', '1', 'important');
      btn.style.setProperty('filter', 'none', 'important');
      btn.style.setProperty('background-color', originalColor, 'important');
      btn.style.setProperty('color', 'white', 'important');
      btn.style.setProperty('border', 'none', 'important');
      btn.style.setProperty('border-radius', '30px', 'important');
      
      console.log(`✅ [forceEnableRejectionDraftButtons] Text-based force-enabled: ${btn.textContent} with color ${originalColor}`);
    }
  });
  
  return true;
}

// ✅ Make globally available
window.forceEnableRejectionDraftButtons = forceEnableRejectionDraftButtons;

// ✅ CRITICAL: Global monitoring system for rejection draft buttons
function startDraftButtonMonitoring() {
  console.log('🔧 [startDraftButtonMonitoring] Starting continuous draft button monitoring');
  
  // Create MutationObserver to watch for DOM changes
  const observer = new MutationObserver(function(mutations) {
    let shouldCheck = false;
    
    mutations.forEach(function(mutation) {
      // Check if any buttons were added or modified
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === 1 && (node.tagName === 'BUTTON' || node.querySelector('button'))) {
            shouldCheck = true;
          }
        });
      }
      
      // Check if button attributes were modified
      if (mutation.type === 'attributes' && mutation.target.tagName === 'BUTTON') {
        const btn = mutation.target;
        const text = btn.textContent.toLowerCase();
        if (text.includes('draft') || text.includes('cancel')) {
          shouldCheck = true;
        }
      }
    });
    
    if (shouldCheck) {
      setTimeout(forceEnableRejectionDraftButtons, 10);
    }
  });
  
  // Start observing
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['disabled', 'class', 'style']
  });
  
  // Periodic safety check every 2 seconds
  setInterval(function() {
    forceEnableRejectionDraftButtons();
  }, 2000);
  
  console.log('✅ [startDraftButtonMonitoring] Draft button monitoring system active');
}

// Start monitoring when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(startDraftButtonMonitoring, 1000);
});
   
function showAcceptedTrayModal(rescanData, lotId, isDraft) {
  console.log('🔍 [showAcceptedTrayModal] === STARTING ===');
  console.log('🔍 Input rescanData:', rescanData);
  console.log('🔍 Input lotId:', lotId);
  console.log('🔍 Input isDraft:', isDraft);
  console.log('🔍 rescanData.has_draft:', rescanData.has_draft);
  console.log('🔍 rescanData.delink_trays:', rescanData.delink_trays);

  // ✅ Get model_no from the current row's data-model-no attribute
  const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
  let modelNo = '';
  
  if (currentRow) {
    modelNo = currentRow.getAttribute('data-model-no') || '';
    console.log('✅ Got model_no from row:', modelNo);
  } else {
    // Fallback to backend data if row not found
    modelNo = rescanData.model_no || 'N/A';
    console.log('⚠️ Fallback to backend model_no:', modelNo);
  }
  
  let topTrayQty = rescanData.top_tray_qty; // ✅ Get from backend
  let draftTrayId = rescanData.draft_tray_id || ''; // ✅ Get draft data
  
  // ✅ FIXED: Don't show placeholder values to the user
  if (isPlaceholderTrayId(draftTrayId)) {
    draftTrayId = ''; // Show empty input instead of placeholder
    console.log('✅ Hiding placeholder tray ID from user interface');
  }
  
  // ✅ NEW: Draft mode styling and indicators (matching rejection form)
  const draftIndicator = isDraft ? '' : '';
  const draftAlert = isDraft ? `

  ` : '';

  const headerColor = isDraft ? '#f39c12' : '#028084';
  const inputStyle = isDraft ? 'background-color: #fff3cd; border-color: #f39c12; border-width: 2px;' : '';
  
  // ✅ COMPLETE: Full modal HTML
  let html = `
    ${draftAlert}
    <!-- ✅ UPDATED: Compact header section -->
    <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 8px 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid ${isDraft ? '#f39c12' : '#028084'}; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
      <h4 class="mb-0" style="font-size: 18px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px; white-space: nowrap; overflow: hidden;">
        <i class="fa fa-layer-group" style="color: ${headerColor}; font-size: 12px;"></i>
        Input Screening / <span style="color: #616161;">${modelNo}</span>${draftIndicator}
      </h4>
      
      <button id="closeAcceptedTrayModal" style="background: none; border: none; font-size: 20px; color: #6c757d; cursor: pointer; padding: 4px; line-height: 1; border-radius: 50%; transition: all 0.3s ease;" title="Close">
        <i class="fa fa-times"></i>
      </button>
    </div>

    <!-- ✅ UPDATED: Delink Section with premium styling -->
    <div id="delinkSection">
      <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
        <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
          Delink Trays
        </h5>

        <div style="display: flex; align-items: center; gap: 10px;">
          <img id="delinkTrayRedoBtn"
               src="{% static 'assets/icons/redo2.png' %}"
               alt="Redo"
               style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
               title="Clear Top Tray ID" />
        </div>
      </div>

      <!-- ✅ REDESIGNED: Compact table styling matching rejection form colors -->
      <div class="table-responsive" style="border: 1px solid #dee2e6; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); background: #fff; scrollbar-width: none; -ms-overflow-style: none; display: grid; grid-template-columns: 1fr; overflow: auto !important;  margin-bottom: 12px;">
        <table class="table table-bordered text-center mb-0" style="font-size: 11px; border-collapse: collapse; border-color: #028084;">
          <thead style="background: linear-gradient(135deg, #028084 0%, #0056b3 100%); position: relative;">
            <tr style="border: 1px solid #282f3a;">
              <th style="background-color: #028084 !important; padding: 8px 6px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; width: 50px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                S.No
              </th>
              <th style="background-color: #028084 !important; padding: 8px 10px; font-size: 10px; font-weight: 700; border: 1px solid #282f3a; border-left: 1px solid rgba(255,255,255,0.2); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                De-Link Tray ID
              </th>
            </tr>
          </thead>
          <tbody id="delinkTableBody" style="background: #fff;">
            <tr>
              <td colspan="2" style="padding: 20px;">
                <i class="fa fa-spinner fa-spin"></i> Loading delink data...
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- ✅ UPDATED: Compact Top Tray Scan Section with matching colors -->
    <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 6px 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 6px; border-left: 3px solid #028084; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
      <h5 class="mb-0" style="font-size: 16px; font-weight: 600; color: #2c3e50; display: flex; align-items: center; gap: 6px;">
        Accepted - Top Tray Scan
      </h5>
      
      <div style="display: flex; align-items: center; gap: 10px;">
        <img id="topTrayRedoBtn"
             src="{% static 'assets/icons/redo2.png' %}"
             alt="Redo"
             style="width: 20px; height: 20px; cursor: pointer; background: none; border: none; box-shadow: none; padding: 0;"
             title="Clear Top Tray ID" />
      </div>
    </div>

    <!-- ✅ UPDATED: Compact input section -->
    <div style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: #ffffff; box-shadow: 0 1px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: end; gap: 15px; width: 100%;">
        <div style="flex: 1; min-width: 0;">
          <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px; display: flex; align-items: center; gap: 4px;">
            Scan top tray ID:
          </label>
          <input type="text" 
                 id="topTrayIdInput" 
                 placeholder="Scan Tray ID..." 
                 value="${draftTrayId}"
                 style="width: 100%; max-width: 280px; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s ease; background: #fff; ${inputStyle} ${draftTrayId ? 'background-color: #d4edda; border-color: #28a745;' : ''}" 
                 class="top-tray-id-input" 
                 ${(!isDraft && draftTrayId) ? 'readonly' : ''} />
          <div id="topTrayError" style="color: #dc3545; font-size: 11px; margin-top: 4px; display: none; font-weight: 500;"></div>
        </div>
        
        <div style="text-align: center;">
          <label style="font-weight: 700; margin-bottom: 6px; display: block; color: #495057; font-size: 15px;">Tray Qty:</label>
          <input type="number" 
                 value="${topTrayQty}" 
                 readonly 
                 style="width: 70px; padding: 8px 6px; text-align: center; border: 2px solid #ddd; border-radius: 6px; font-weight: 700; font-size: 14px;" />
        </div>
      </div>
    </div>

    <div id="acceptedTrayMsg" style="margin-top: 10px; text-align: center; font-weight: bold;"></div>

    <!-- ✅ ENHANCED: Simple button design as requested by client -->
    <div style="display: flex; justify-content: center; gap: 10px; margin-top: 30px;">
      ${isDraft ? `
        
        <button id="acceptedTrayFinalSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      ` : `
        <button id="acceptedTrayDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
        <button id="acceptedTraySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      `}
      <button id="acceptedTrayCancelBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 30px;">Cancel</button>
    </div>
  `;

  // ✅ SET THE MODAL CONTENT
  const newPopupModal = document.getElementById("newPopupModal");
  document.querySelector("#newPopupModal .tray-scan-modal-content").innerHTML = html;
  newPopupModal.classList.add("open");

  // ✅ CRITICAL FIX: Force enable draft buttons immediately after HTML insertion
  setTimeout(function() {
    forceEnableDraftButtons();
    console.log('✅ [showAcceptedTrayModal] Applied immediate button fix after modal open');
    
    // ✅ NEW: Check tray verification status and disable submit if not all verified
    fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        const verificationData = data.verification_data;
        const allVerified = Object.values(verificationData).every(status => status === true);
        if (!allVerified) {
          // Disable submit buttons
          const submitBtn = document.getElementById('acceptedTraySubmitBtn');
          const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
          if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.style.opacity = '0.5';
            submitBtn.title = 'All trays must be verified before submitting';
          }
          if (finalSubmitBtn) {
            finalSubmitBtn.disabled = true;
            finalSubmitBtn.style.opacity = '0.5';
            finalSubmitBtn.title = 'All trays must be verified before submitting';
          }
          console.log('✅ [showAcceptedTrayModal] Submit disabled - not all trays verified');
        } else {
          console.log('✅ [showAcceptedTrayModal] All trays verified - submit enabled');
        }
      }
    })
    .catch(err => console.error('Error checking verification status:', err));
  }, 50);

  // ✅ ENHANCED: Event listener for close button with proper modal management
  const closeBtn = document.getElementById('closeAcceptedTrayModal');
  if (closeBtn) {
    // Remove any existing listeners to prevent duplicates
    closeBtn.removeEventListener('click', closeAcceptedTrayModalHandler);
    closeBtn.addEventListener('click', closeAcceptedTrayModalHandler);

    // Add enhanced hover effect
    closeBtn.addEventListener('mouseenter', function() {
      this.style.backgroundColor = '#dc3545';
      this.style.color = '#fff';
      this.style.transform = 'scale(1.1)';
    });

    closeBtn.addEventListener('mouseleave', function() {
      this.style.backgroundColor = 'transparent';
      this.style.color = '#6c757d';
      this.style.transform = 'scale(1)';
    });
  }

  // Add event listeners
  addTopTrayEventListeners(lotId, isDraft, topTrayQty);

  // ✅ NEW: Listen for delink table ready event
  let draftLoadAttempted = false;
  
  const handleDelinkReady = (event) => {
    console.log('✅ [showAcceptedTrayModal] Delink table ready event received:', event.detail);
    
    if (!draftLoadAttempted && event.detail.lotId === lotId) {
      draftLoadAttempted = true;
      
      console.log('✅ [showAcceptedTrayModal] Starting draft loading now that table is ready');
      
      if (rescanData.has_draft) {
        // ✅ Load draft immediately and with retries
        loadDraftDataDirectly(rescanData);
        setTimeout(() => loadDraftDataDirectly(rescanData), 200);
        setTimeout(() => loadDraftDataDirectly(rescanData), 500);
      } else {
        console.log('⏭️ [showAcceptedTrayModal] No draft data to load');
      }
      
      // Remove event listener after use
      document.removeEventListener('delinkTableReady', handleDelinkReady);
    }
  };
  
  // ✅ Add event listener BEFORE loading delink data
  document.addEventListener('delinkTableReady', handleDelinkReady);
  
  // ✅ NOW load delink data - this will trigger the event when ready
  console.log('🔍 [showAcceptedTrayModal] Loading delink data...');
  loadDelinkTrayData(lotId);
  
  // ✅ BACKUP: If event doesn't fire within 3 seconds, try anyway
  setTimeout(() => {
    if (!draftLoadAttempted && rescanData.has_draft) {
      console.log('⚠️ [showAcceptedTrayModal] BACKUP: Event timeout, trying draft load anyway');
      loadDraftDataDirectly(rescanData);
    }
  }, 3000);

    setTimeout(() => {
    const topTrayInput = document.getElementById('topTrayIdInput');
    if (topTrayInput) {
      topTrayInput.focus();
      topTrayInput.select();
    }
  }, 200);

    setTimeout(() => {
    const firstDelinkInput = document.querySelector('.delink-tray-input');
    if (firstDelinkInput) {
      firstDelinkInput.focus();
      firstDelinkInput.select();
    }
  }, 200);

  // ✅ UPDATED: Show initial success message only if we have a real tray ID (not placeholder)
  if (draftTrayId && !isPlaceholderTrayId(rescanData.draft_tray_id)) {
    showAcceptedTrayMessage('✅ Draft data loaded', '#28a745');
  } else if (isDraft && isPlaceholderTrayId(rescanData.draft_tray_id)) {
    showAcceptedTrayMessage('✅ Draft loaded (delink-only)', '#28a745');
  }
  
  // ✅ ADDITIONAL SAFETY: Force enable buttons after all setup is complete
  setTimeout(function() {
    forceEnableDraftButtons();
    console.log('✅ [showAcceptedTrayModal] Applied final button fix after complete setup');
  }, 1000);
}
// ✅ NEW: Direct draft loading function
function loadDraftDataDirectly(rescanData) {
  console.log('🔄 [loadDraftDataDirectly] STARTING DIRECT LOAD...');
  console.log('🔍 [loadDraftDataDirectly] has_draft:', rescanData.has_draft);
  console.log('🔍 [loadDraftDataDirectly] delink_trays:', rescanData.delink_trays);
  
  // 1. Load top tray (this already works)
  const topTrayInput = document.getElementById('topTrayIdInput');
  if (topTrayInput && rescanData.draft_tray_id && !isPlaceholderTrayId(rescanData.draft_tray_id)) {
    const oldTopValue = topTrayInput.value;
    topTrayInput.value = rescanData.draft_tray_id;
    console.log(`✅ [loadDraftDataDirectly] Top tray: "${oldTopValue}" → "${topTrayInput.value}"`);
  } else {
    console.log('⏭️ [loadDraftDataDirectly] No top tray to load');
  }
  
  // 2. Load delink trays - THIS IS THE CRITICAL PART
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  console.log(`🔍 [loadDraftDataDirectly] Found ${delinkInputs.length} delink inputs`);
  
  if (delinkInputs.length === 0) {
    console.log('❌ [loadDraftDataDirectly] NO DELINK INPUTS FOUND - RETRYING...');
    return; // Will retry with next timeout
  }
  
  // Log all current values BEFORE loading
  console.log('🔍 [loadDraftDataDirectly] BEFORE loading:');
  delinkInputs.forEach((input, index) => {
    console.log(`  - Input[${index}]: "${input.value}"`);
  });
  
  // ✅ LOAD DELINK TRAYS
  if (Array.isArray(rescanData.delink_trays) && rescanData.delink_trays.length > 0) {
    console.log(`🔍 [loadDraftDataDirectly] Loading ${rescanData.delink_trays.length} delink trays...`);
    
    rescanData.delink_trays.forEach((tray, arrayIndex) => {
      console.log(`🔍 [loadDraftDataDirectly] Processing tray ${arrayIndex}:`, tray);
      
      const position = tray.position !== undefined ? tray.position : arrayIndex;
      const trayId = tray.tray_id || '';
      const trayQty = tray.tray_qty || 0;
      
      console.log(`  - position: ${position}, tray_id: "${trayId}", tray_qty: ${trayQty}`);
      
      if (position >= 0 && position < delinkInputs.length) {
        const targetInput = delinkInputs[position];
        const oldValue = targetInput.value;
        
        // ✅ SET THE VALUE
        targetInput.value = trayId;
        targetInput.setAttribute('data-expected-qty', trayQty);
        
        // ✅ ADD VISUAL STYLING
        targetInput.style.backgroundColor = '#d4edda';
        targetInput.style.borderColor = '#28a745';
        targetInput.style.color = '#155724';
        targetInput.style.fontWeight = '600';
        
        console.log(`✅ [loadDraftDataDirectly] Input[${position}]: "${oldValue}" → "${targetInput.value}"`);
        
        // ✅ TRIGGER EVENTS
        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
        
      } else {
        console.log(`❌ [loadDraftDataDirectly] Invalid position ${position} (max: ${delinkInputs.length - 1})`);
      }
    });
    
    // Log all values AFTER loading
    console.log('🔍 [loadDraftDataDirectly] AFTER loading:');
    delinkInputs.forEach((input, index) => {
      console.log(`  - Input[${index}]: "${input.value}"`);
    });
    
    console.log('✅ [loadDraftDataDirectly] DRAFT LOADING COMPLETED!');
    
    // ✅ UPDATE COUNTER
    if (typeof updateDelinkScanCounter === 'function') {
      updateDelinkScanCounter();
    }
    
  } else {
    console.log('⏭️ [loadDraftDataDirectly] No delink_trays to load');
  }
  
  // ✅ CRITICAL FIX: Force enable draft buttons after loading draft data
  setTimeout(function() {
    const draftButtons = document.querySelectorAll('#acceptedTrayUpdateDraftBtn, #acceptedTrayDraftBtn, #acceptedTrayCancelBtn');
    draftButtons.forEach(btn => {
      btn.disabled = false;
      btn.style.pointerEvents = 'auto !important';
      btn.style.zIndex = '900004 !important';
      btn.style.cursor = 'pointer !important';
      btn.style.opacity = '1 !important';
      btn.style.filter = 'none !important';
      btn.classList.remove('disabled');
      btn.removeAttribute('aria-disabled');
      console.log('✅ [loadDraftDataDirectly] Force-enabled button after draft load:', btn.id);
    });
  }, 100);
}


function loadDelinkTrayData(lotId) {
  console.log('🔍 [loadDelinkTrayData] Called with lotId:', lotId);
  
  const delinkSection = document.getElementById('delinkSection');
  const url = `/inputscreening/get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`;

  fetch(url)
    .then(res => {
      console.log('🔍 [loadDelinkTrayData] Response status:', res.status);
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      return res.json();
    })
    .then(data => {
      console.log('🔍 [loadDelinkTrayData] Response data:', data);

      // Hide or show the delink section based on tray count
      if (delinkSection) {
        if (data.delink_trays && data.delink_trays.length === 0) {
          delinkSection.style.display = 'none';
          console.log('🔍 [loadDelinkTrayData] Hiding delink section - no trays');
        } else {
          delinkSection.style.display = '';
          console.log('🔍 [loadDelinkTrayData] Showing delink section');
        }
      }

      const tableBody = document.getElementById('delinkTableBody');
      if (!tableBody) {
        console.log('❌ [loadDelinkTrayData] delinkTableBody not found');
        return;
      }

      if (data.success && data.delink_trays && data.delink_trays.length > 0) {
        console.log('🔍 [loadDelinkTrayData] Building table for', data.delink_trays.length, 'trays');
        
        tableBody.innerHTML = '';
        data.delink_trays.forEach((tray, index) => {
          console.log(`🔍 [loadDelinkTrayData] Building row ${index} for tray:`, tray);
          
          const row = document.createElement('tr');
          row.style.cssText = 'border-bottom: 1px solid #f1f3f4; transition: all 0.2s ease;';
          row.innerHTML = `
            <td style="padding: 4px; font-size: 11px; font-weight: 600; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); color: #495057; border-right: 1px solid #f1f3f4; vertical-align: middle;">${tray.sno}</td>
            <td style="padding: 4px 6px; border-right: 1px solid #f1f3f4; background: #fafbfc; vertical-align: middle;">
              <input type="text" 
                     class="form-control delink-tray-input" 
                     placeholder="Scan Tray ID for Delink" 
                     value=""
                     style="width: 100%; padding: 4px 6px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; background: #fff; height: 24px;" 
                     data-row="${tray.sno}"
                     data-expected-qty="${tray.tray_quantity}" />
              <span class="delink-tray-error" style="color: #d32f2f; font-size: 10px; margin-left: 2px; display: none;"></span>
            </td>
          `;
          tableBody.appendChild(row);
        });
        
        console.log('✅ [loadDelinkTrayData] Table built successfully');
        
        // Add delink tray validation
        addDelinkTrayValidation(lotId);

        // ✅ NEW: Focus on first delink tray input for immediate scanning
        setTimeout(() => {
          const firstDelinkInput = document.querySelector('.delink-tray-input');
          if (firstDelinkInput) {
            firstDelinkInput.focus();
            console.log('✅ [loadDelinkTrayData] Focused on first delink tray input');
          }
        }, 100);

        // ✅ CRITICAL: Notify that table is ready
        console.log('✅ [loadDelinkTrayData] DELINK TABLE READY - TRIGGERING DRAFT LOAD');
        
        // ✅ NEW: Dispatch custom event to notify draft loading can start
        const delinkReadyEvent = new CustomEvent('delinkTableReady', {
          detail: { lotId: lotId, inputCount: data.delink_trays.length }
        });
        document.dispatchEvent(delinkReadyEvent);

      } else {
        console.log('🔍 [loadDelinkTrayData] No delink data or empty array');
        
        // ✅ NEW: Focus on top tray input when no delink trays exist
        setTimeout(() => {
          const topTrayInput = document.getElementById('topTrayIdInput');
          if (topTrayInput) {
            topTrayInput.focus();
            console.log('✅ [loadDelinkTrayData] Focused on top tray input (no delink trays)');
          }
        }, 100);
        
        // ✅ STILL DISPATCH EVENT even if no delink trays
        const delinkReadyEvent = new CustomEvent('delinkTableReady', {
          detail: { lotId: lotId, inputCount: 0 }
        });
        document.dispatchEvent(delinkReadyEvent);
      }

      // Setup redo functionality
      setupDelinkRedoFunctionality();
      
    })
    .catch(error => {
      console.error('❌ [loadDelinkTrayData] Error:', error);
      
      // ✅ NEW: Focus on top tray input on error
      setTimeout(() => {
        const topTrayInput = document.getElementById('topTrayIdInput');
        if (topTrayInput) {
          topTrayInput.focus();
          console.log('✅ [loadDelinkTrayData] Focused on top tray input (error fallback)');
        }
      }, 100);
      
      // ✅ DISPATCH EVENT even on error
      const delinkReadyEvent = new CustomEvent('delinkTableReady', {
        detail: { lotId: lotId, inputCount: 0, error: error.message }
      });
      document.dispatchEvent(delinkReadyEvent);
    });
}


// ✅ NEW: Define the missing setupDelinkRedoFunctionality function
     function setupDelinkRedoFunctionality() {
       
       // Remove existing event listener if any
       const existingBtn = document.getElementById('delinkTrayRedoBtn');
       if (existingBtn) {
         existingBtn.removeEventListener('click', existingBtn._clickHandler);
       }
       
       // Add event listener for delink redo button
       const delinkRedoBtn = document.getElementById('delinkTrayRedoBtn');
       if (delinkRedoBtn) {
         const clickHandler = function() {
           
           // Clear all delink tray input values
           document.querySelectorAll('.delink-tray-input').forEach(function(input) {
             input.value = '';
             // Clear any error messages
             const errorSpan = input.parentElement.querySelector('.delink-tray-error');
             if (errorSpan) {
               errorSpan.style.display = 'none';
               errorSpan.textContent = '';
             }
           });
           
           // Update the delink scan counter
           updateDelinkScanCounter();
           
         };
         
         // Store reference for potential removal later
         delinkRedoBtn._clickHandler = clickHandler;
         delinkRedoBtn.addEventListener('click', clickHandler);
         
       } 
     }
   
     // ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
   // ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
   function addTopTrayEventListeners(lotId, isDraft, topTrayQty) {
   const topTrayInput = document.getElementById('topTrayIdInput');
   const topTrayError = document.getElementById('topTrayError');
   const redoBtn = document.getElementById('topTrayRedoBtn');
   const counter = document.getElementById('topTrayScanCounter');
   
   // Input validation on blur - only for visual feedback, not blocking
   topTrayInput.addEventListener('blur', function() {
   const trayId = this.value.trim();
   if (!trayId || topTrayInput.readonly) {
     return;
   }
   
   // ✅ UPDATED: Only validate for visual feedback, don't block submission
   validateTopTrayIdForDisplay(trayId, lotId);
   });
   
   // Input change event
  
  
  topTrayInput.addEventListener('input', function() {
    if (topTrayInput.readonly) return;
  
    const trayId = this.value.trim();
  
    // --- ADD THIS BLOCK IMMEDIATELY AFTER trayId IS SET ---
    let isDuplicate = false;
    const delinkInputs = document.querySelectorAll('.delink-tray-input');
    delinkInputs.forEach(input => {
      if (input.value.trim() && input.value.trim() === trayId) {
        isDuplicate = true;
      }
    });
  
    if (isDuplicate) {
      errorDiv.textContent = '❌ Same tray cannot be used for both Delink and Top Tray';
      errorDiv.style.display = 'block';
      errorDiv.style.color = '#dc3545';
      errorDiv.style.backgroundColor = '#f8d7da';
      topTrayInput.style.backgroundColor = '#f8d7da';
      topTrayInput.style.borderColor = '#dc3545';
      topTrayInput._isValid = false;
      updateAcceptedFormValidationState();
      return; // Stop further validation
    }
    // --- END BLOCK ---
  
    // ...existing validation logic...
    hideError();
    updateButtonStates(!!trayId); // Enable buttons when tray ID is entered
    updateCounter(!!trayId);
  });
  
   
   // Redo button
   if (redoBtn) {
   redoBtn.addEventListener('click', function() {
     topTrayInput.value = '';
     topTrayInput.readonly = false;
     topTrayInput.style.backgroundColor = '';
     topTrayInput.style.borderColor = '#ddd';
     hideError();
     updateSubmitButtonStates(false); // ✅ Keep draft buttons enabled when clearing input
     updateCounter(false);
     topTrayInput.focus();
   });
     topTrayInput.addEventListener('input', checkForDuplicateTrayId);
   
   }
   
   // Button event listeners
   addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty);
   
   // ✅ FIXED: Ensure validation state is properly initialized after DOM updates
   setTimeout(() => {
     updateAcceptedFormValidationState();
   }, 100);
   
   function validateTopTrayIdForDisplay(trayId, lotId) {
   showError('Validating...', '#007bff');
   
   fetch(`/inputscreening/check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
   .then(res => res.json())
   .then(data => {
     
     // Check for duplicate with delink trays
     let isDuplicate = false;
     const delinkInputs = document.querySelectorAll('.delink-tray-input');
     delinkInputs.forEach(input => {
       if (input.value.trim() && input.value.trim() === trayId) {
         isDuplicate = true;
       }
     });
   
    if (isDuplicate) {
      showError('❌ Same tray cannot be used for both Delink and Top Tray', '#dc3545');
      updateSubmitButtonStates(false); // ✅ Keep draft buttons enabled
      updateCounter(false);
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      return;
    }
   
    if (data.error === 'Tray id is not verified' || data.tray_status === 'not_verified') {
      showError('❌ Tray id is not verified', '#dc3545');
      updateSubmitButtonStates(false); // ✅ Keep draft buttons enabled
      updateCounter(false);
      topTrayInput.style.backgroundColor = '#f8d7da';
      topTrayInput.style.borderColor = '#dc3545';
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      return;
    }
   
     if (data.exists || data.already_used_in_acceptance) {
      showError('✅ Valid tray ID', '#28a745');
      updateButtonStates(true);
      updateCounter(true);
      topTrayInput.style.backgroundColor = '#d4edda';
      topTrayInput.style.borderColor = '#28a745';
      // Do NOT focus/select or auto-hide on success
      } else {
      // ❌ Only show error for genuinely invalid trays
      let errorMsg = 'Invalid tray ID';
      if (data.already_rejected) errorMsg = 'Tray already rejected';
      else if (data.not_in_same_lot) errorMsg = 'Tray not in same lot';
      else errorMsg = 'Tray ID not found';

      showError('❌ ' + errorMsg, '#dc3545');
      updateSubmitButtonStates(false); // ✅ Keep draft buttons enabled
      updateCounter(false);
      topTrayInput.style.backgroundColor = '#f8d7da';
      topTrayInput.style.borderColor = '#dc3545';

      // Do NOT clear the value or hide the error. Just select all and keep focus.
      setTimeout(() => {
        topTrayInput.focus();
        topTrayInput.select();
      }, 100);
      }
     })
     .catch(error => {
       // ✅ UPDATED: Don't block on connection errors, just show warning
       showError('⚠️ Connection issue - will validate on submit', '#ffc107');
       updateButtonStates(true); // Allow submission anyway
       updateCounter(true);
     });
   }
   
   function updateButtonStates(hasValidTray) {
   const draftBtn = document.getElementById('acceptedTrayDraftBtn');
   const submitBtn = document.getElementById('acceptedTraySubmitBtn');
   const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
   const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
   
   // ✅ CRITICAL FIX: Draft buttons should ALWAYS be enabled (allow saving work in progress)
   if (draftBtn) {
     draftBtn.disabled = false; // Always enable draft saving
     draftBtn.style.opacity = '1';
     draftBtn.style.cursor = 'pointer';
     draftBtn.style.pointerEvents = 'auto';
     draftBtn.style.zIndex = '900004';
   }
   if (updateDraftBtn) {
     updateDraftBtn.disabled = false; // Always enable update draft
     updateDraftBtn.style.opacity = '1';
     updateDraftBtn.style.cursor = 'pointer';
     updateDraftBtn.style.pointerEvents = 'auto';
     updateDraftBtn.style.zIndex = '900004';
   }
   
   // Only submission buttons require valid tray
   if (submitBtn) submitBtn.disabled = !hasValidTray;
   if (finalSubmitBtn) finalSubmitBtn.disabled = !hasValidTray;
   }
   
   // ✅ ENHANCED: Function that only disables submit buttons, keeps draft buttons enabled
   function updateSubmitButtonStates(hasValidTray) {
   const draftBtn = document.getElementById('acceptedTrayDraftBtn');
   const submitBtn = document.getElementById('acceptedTraySubmitBtn');
   const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
   const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
   
   // ✅ CRITICAL FIX: Draft buttons always stay enabled with full visibility
   if (draftBtn) {
     draftBtn.disabled = false;
     draftBtn.style.opacity = '1';
     draftBtn.style.cursor = 'pointer';
     draftBtn.style.pointerEvents = 'auto';
     draftBtn.style.zIndex = '900004';
   }
   if (updateDraftBtn) {
     updateDraftBtn.disabled = false;
     updateDraftBtn.style.opacity = '1';
     updateDraftBtn.style.cursor = 'pointer';
     updateDraftBtn.style.pointerEvents = 'auto';
     updateDraftBtn.style.zIndex = '900004';
   }
   
   // Only submission buttons are controlled by validation
   if (submitBtn) submitBtn.disabled = !hasValidTray;
   if (finalSubmitBtn) finalSubmitBtn.disabled = !hasValidTray;
   }
   
   function updateCounter(isValid) {
   if (counter) {
     if (isValid) {
       counter.textContent = `${topTrayQty}/${topTrayQty}`;
       counter.style.color = '#28a745';
     } else {
       counter.textContent = `0/${topTrayQty}`;
       counter.style.color = '#dc3545';
     }
   }
   }
   
   function showError(message, color) {
   topTrayError.textContent = message;
   topTrayError.style.color = color;
   topTrayError.style.display = 'block';
   }
   
   function hideError() {
   topTrayError.style.display = 'none';
   }
   }
   
   
   // ✅ UPDATED: Button event listeners remain the same but now work directly with input validation
// ✅ NEW: Instant validation for accepted top tray input
function addInstantTopTrayValidation(lotId) {
  console.log('🔧 [addInstantTopTrayValidation] Setting up validation for lot:', lotId);
  
  const topTrayInput = document.getElementById('topTrayIdInput');
  const errorDiv = document.getElementById('topTrayError');
  
  if (!topTrayInput) {
    console.log('⚠️ [addInstantTopTrayValidation] Top tray input not found');
    return;
  }
  
  if (!errorDiv) {
    console.log('⚠️ [addInstantTopTrayValidation] Error div not found');
    return;
  }
  
  // Add instant validation on input change
  topTrayInput.addEventListener('input', function() {
    const trayId = this.value.trim();

       // --- ADD THIS BLOCK IMMEDIATELY AFTER trayId IS SET ---
  let isDuplicate = false;
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  delinkInputs.forEach(input => {
    if (input.value.trim() && input.value.trim() === trayId) {
      isDuplicate = true;
    }
  });

  if (isDuplicate) {
    errorDiv.textContent = '❌ Same tray cannot be used for both Delink and Top Tray';
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#dc3545';
    errorDiv.style.backgroundColor = '#f8d7da';
    topTrayInput.style.backgroundColor = '#f8d7da';
    topTrayInput.style.borderColor = '#dc3545';
    topTrayInput._isValid = false;
    updateAcceptedFormValidationState();
    return; // Stop further validation
  }
  // --- END BLOCK ---

    // Clear previous validation state
    this.classList.remove('top-tray-valid', 'top-tray-invalid', 'top-tray-loading');
    this._isValid = false;
    
    if (!trayId) {
      // Empty input - neutral state
      this.style.borderColor = '#ddd';
      this.style.backgroundColor = '#fff';
      errorDiv.style.display = 'none';
      this._isValid = false; // ✅ FIXED: Mark as invalid when empty
      updateAcceptedFormValidationState();
      return;
    }
    
    // Show loading state
    this.classList.add('top-tray-loading');
    this.style.borderColor = '#007bff';
    this.style.backgroundColor = '#e3f2fd';
    
    errorDiv.innerHTML = '🔄 Validating tray ID...';
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#007bff';
    errorDiv.style.backgroundColor = '#e3f2fd';
    errorDiv.style.border = '1px solid #b3d7ff';
    errorDiv.style.padding = '6px 10px';
    errorDiv.style.borderRadius = '4px';
    errorDiv.style.fontSize = '12px';
    errorDiv.style.fontWeight = '500';
    errorDiv.style.marginTop = '4px';
    
    console.log('🔧 [addInstantTopTrayValidation] Validating tray ID:', trayId);
    
    // Make API call to check tray ID
    const queryParams = new URLSearchParams({
      tray_id: trayId,
      lot_id: lotId
    });
    
    const apiUrl = `/inputscreening/check_tray_id/?${queryParams}`;
    
    fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      credentials: 'same-origin'
    })
    .then(response => {
      console.log('🔧 [addInstantTopTrayValidation] Response status:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    })
    .then(data => {
      console.log('🔧 [addInstantTopTrayValidation] Response data:', data);
      
      // Remove loading state
      this.classList.remove('top-tray-loading');
      
      if (data.exists && data.tray_status === 'valid') {
        // Valid tray
        this.classList.add('top-tray-valid');
        this.style.borderColor = '#28a745';
        this.style.backgroundColor = '#d4edda';
        this._isValid = true;
        
        errorDiv.innerHTML = '✅ Valid tray - Ready to proceed';
        errorDiv.style.color = '#155724';
        errorDiv.style.backgroundColor = '#d4edda';
        errorDiv.style.border = '1px solid #c3e6cb';
        
        console.log('🔧 [addInstantTopTrayValidation] ✅ Valid tray');
      } else {
        // Invalid tray
        this.classList.add('top-tray-invalid');
        this.style.borderColor = '#dc3545';
        this.style.backgroundColor = '#f8d7da';
        this._isValid = false;
        
        let errorMessage = '❌ Invalid tray ID';
        
        if (data.already_rejected) {
          errorMessage = '❌ Tray already rejected';
        } else if (data.not_in_same_lot) {
          errorMessage = '❌ Tray not from same lot';
        } else if (data.already_used_in_acceptance) {
          errorMessage = '❌ Tray already used in acceptance';
        } else if (data.error) {
          errorMessage = `❌ ${data.error}`;
        }
        
        errorDiv.innerHTML = errorMessage;
        errorDiv.style.color = '#721c24';
        errorDiv.style.backgroundColor = '#f8d7da';
        errorDiv.style.border = '1px solid #f5c6cb';
        
        console.log('🔧 [addInstantTopTrayValidation] ❌ Invalid tray:', errorMessage);
      }
      
      updateAcceptedFormValidationState();
    })
    .catch(error => {
      console.error('🔧 [addInstantTopTrayValidation] ❌ Error:', error);
      
      // Remove loading state
      this.classList.remove('top-tray-loading');
      this.classList.add('top-tray-invalid');
      this.style.borderColor = '#ffc107';
      this.style.backgroundColor = '#fff3cd';
      this._isValid = false;
      
      let errorMessage = '⚠️ Validation failed';
      
      if (error.message.includes('HTTP 404')) {
        errorMessage = '⚠️ API endpoint not found';
      } else if (error.message.includes('HTTP 500')) {
        errorMessage = '⚠️ Server error';
      } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
        errorMessage = '⚠️ Connection error';
      } else {
        errorMessage = `⚠️ ${error.message}`;
      }
      
      errorDiv.innerHTML = errorMessage;
      errorDiv.style.color = '#856404';
      errorDiv.style.backgroundColor = '#fff3cd';
      errorDiv.style.border = '1px solid #ffeaa7';
      
      updateAcceptedFormValidationState();
    });
  });
  
  // ✅ NEW: Initialize validation state on setup
  const initialTrayId = topTrayInput.value.trim();
  if (!initialTrayId) {
    topTrayInput._isValid = false;
  }
  updateAcceptedFormValidationState();
  
  console.log('✅ [addInstantTopTrayValidation] Validation listeners added');
}

// ✅ FIXED: Form validation state management for accepted tray modal
function updateAcceptedFormValidationState() {
  console.log('🔧 [updateAcceptedFormValidationState] Checking form validation state');
  
  const topTrayInput = document.getElementById('topTrayIdInput');
  if (!topTrayInput) {
    console.log('⚠️ [updateAcceptedFormValidationState] Top tray input not found');
    return;
  }
  
  const trayId = topTrayInput.value.trim();
  const isValid = topTrayInput._isValid === true;
  const hasInput = trayId.length > 0;
  
  console.log('🔧 [updateAcceptedFormValidationState] Tray ID:', trayId, 'Valid:', isValid, 'Has input:', hasInput);
  
  // Find submit buttons (not draft buttons)
  const submitButtons = document.querySelectorAll('#acceptedTraySubmitBtn, #acceptedTrayFinalSubmitBtn');
  const draftButtons = document.querySelectorAll('#acceptedTrayDraftBtn, #acceptedTrayUpdateDraftBtn');
  
  // ✅ FIXED: Submit should be enabled ONLY when there's input AND it's valid
  const shouldEnable = hasInput && isValid;
  
  // Update submit buttons
  submitButtons.forEach(button => {
    if (shouldEnable) {
      // Enable button when tray ID is valid
      button.disabled = false;
      button.style.opacity = '1';
      button.style.cursor = 'pointer';
      button.title = '';
      console.log('✅ [updateAcceptedFormValidationState] Enabling submit button:', button.id);
    } else {
      // Disable button when no input or invalid input
      button.disabled = true;
      button.style.opacity = '0.5';
      button.style.cursor = 'not-allowed';
      
      if (!hasInput) {
        button.title = 'Please enter top tray ID';
      } else if (!isValid) {
        button.title = 'Please fix invalid tray ID before proceeding';
      }
      console.log('🚫 [updateAcceptedFormValidationState] Disabling submit button:', button.id, 'Reason:', !hasInput ? 'No input' : 'Invalid input');
    }
  });
  
  // ✅ CRITICAL FIX: Draft buttons should ALWAYS be enabled regardless of validation state
  draftButtons.forEach(button => {
    button.disabled = false;
    button.style.opacity = '1';
    button.style.cursor = 'pointer';
    button.style.pointerEvents = 'auto';
    button.style.zIndex = '900004';
    button.title = 'Save as draft (validation not required)';
    console.log('✅ [updateAcceptedFormValidationState] Force-enabled draft button:', button.id);
  });
  
  console.log('🔧 [updateAcceptedFormValidationState] Form state updated. Should enable submit:', shouldEnable, 'Draft buttons: ALWAYS enabled');
}

// ✅ FIXED: Form submission interceptor for accepted tray modal
function addAcceptedTrayFormInterceptor() {
  console.log('🔧 [addAcceptedTrayFormInterceptor] Setting up form submission interceptor');
  
  const modal = document.getElementById('newPopupModal');
  if (!modal) {
    console.log('⚠️ [addAcceptedTrayFormInterceptor] Modal not found');
    return;
  }

  // Intercept button clicks for submit actions
  modal.addEventListener('click', function(event) {
    const button = event.target.closest('button');
    if (!button) return;

    // ✅ CRITICAL FIX: NEVER block draft or cancel buttons
    const isDraftButton = button.id === 'acceptedTrayDraftBtn' || 
                         button.id === 'acceptedTrayUpdateDraftBtn' ||
                         (button.textContent.toLowerCase().includes('draft') && 
                          !button.textContent.toLowerCase().includes('submit'));
    
    const isCancelButton = button.id === 'acceptedTrayCancelBtn' ||
                          button.textContent.toLowerCase().includes('cancel');
    
    // ✅ Allow draft and cancel buttons to always proceed
    if (isDraftButton || isCancelButton) {
      console.log('✅ [addAcceptedTrayFormInterceptor] Allowing draft/cancel button:', button.id);
      return true; // Allow the action to proceed
    }

    // Check if this is a submit type button (not draft/cancel)
    const isSubmitButton = button.id === 'acceptedTraySubmitBtn' || 
                          button.id === 'acceptedTrayFinalSubmitBtn' ||
                          (button.textContent.toLowerCase().includes('submit') && 
                           !button.textContent.toLowerCase().includes('draft'));
    
    if (isSubmitButton) {
      console.log('🖱️ [addAcceptedTrayFormInterceptor] Submit button clicked:', button.id);
      
      const topTrayInput = document.getElementById('topTrayIdInput');
      if (!topTrayInput) {
        console.log('⚠️ [addAcceptedTrayFormInterceptor] Top tray input not found');
        return;
      }
      
      const trayId = topTrayInput.value.trim();
      const isValid = topTrayInput._isValid === true;
      const hasInput = trayId.length > 0;

      // ✅ FIXED: Only prevent submission for submit buttons if no input OR invalid input
      if (!hasInput || !isValid) {
        console.log('🚫 [addAcceptedTrayFormInterceptor] Preventing submission. Has input:', hasInput, 'Is valid:', isValid);
        event.preventDefault();
        event.stopPropagation();
        
        // Show appropriate user feedback
        if (!hasInput) {
          alert('Please enter a top tray ID before proceeding.');
        } else if (!isValid) {
          alert('Please wait for tray validation to complete and fix any invalid tray IDs before proceeding.');
        }
        return false;
      }
      
      console.log('✅ [addAcceptedTrayFormInterceptor] Tray validation passed - allowing submission');
    }
  });
  
  console.log('✅ [addAcceptedTrayFormInterceptor] Form interceptor added');
}

   function addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty) {
   // ✅ NEW: Add instant validation for top tray input
   addInstantTopTrayValidation(lotId);
   
   if (isDraft) {
   const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
   const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");
   
   if (updateDraftBtn) {
     updateDraftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
   }
   
   if (finalSubmitBtn) {
     finalSubmitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
   }
   } else {
   const draftBtn = document.getElementById("acceptedTrayDraftBtn");
   const submitBtn = document.getElementById("acceptedTraySubmitBtn");
   
   if (draftBtn) {
     draftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
   }
   
   if (submitBtn) {
     submitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
   }
   }
   
   const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
   if (cancelBtn) {
   cancelBtn.addEventListener("click", () => {
   // ✅ FIX: Don't auto-save on cancel from accepted tray modal
   console.log('🔄 [acceptedTrayCancelBtn] Closing modal without auto-save (process status should not be filled)');
   
   const trayScanModal = document.getElementById("trayScanModal");
   if (trayScanModal && trayScanModal.classList.contains("open")) {
     trayScanModal.classList.remove("open");
     trayScanModal.style.display = "none";
   }
   
   // Close the newPopupModal (accepted tray modal)
   document.getElementById("newPopupModal").classList.remove("open");
   
   // Add a slight delay then refresh table data only
   setTimeout(() => {
     location.reload();
   }, 300);
   });
   }
   
   // ✅ NEW: Add form submission interceptor for accepted tray modal
   addAcceptedTrayFormInterceptor();
   }
   
   function refreshTableData() {
   // Get current page number for pagination
   const currentPage = new URLSearchParams(window.location.search).get('page') || 1;
   
   // Fetch fresh table data silently
   fetch(`${window.location.pathname}?page=${currentPage}`, {
   method: 'GET',
   headers: {
     'X-Requested-With': 'XMLHttpRequest', // Mark as AJAX request
   }
   })
   .then(response => response.text())
   .then(html => {
   // Create a temporary container to parse the response
   const tempDiv = document.createElement('div');
   tempDiv.innerHTML = html;
   
   // Extract the new table content
   const newTableBody = tempDiv.querySelector('#order-listing tbody');
   const currentTableBody = document.querySelector('#order-listing tbody');
   
   if (newTableBody && currentTableBody) {
     // Replace table body content silently
     currentTableBody.innerHTML = newTableBody.innerHTML;
   
     // Also update pagination if needed
     const newPagination = tempDiv.querySelector('.pagination-wrapper');
     const currentPagination = document.querySelector('.pagination-wrapper');
     if (newPagination && currentPagination) {
       currentPagination.innerHTML = newPagination.innerHTML;
     }
   
     // ✅ Re-attach modal open event listeners after table refresh
   
     // ✅ FIXED: Reject button with proper conditional logic
     document.querySelectorAll('.tray-scan-btn').forEach((link) => {
       link.addEventListener('click', (event) => {
         event.preventDefault();
   
         const row = event.target.closest("tr");
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         
         // ✅ Get the row attributes to determine which modal to show
         const ipOnholdPicking = row.getAttribute('data-ip-onhold-picking') === 'True';
         const fewCasesAcceptance = row.getAttribute('data-few-cases-acceptance') === 'True';

         console.log('🔴 REJECT BUTTON clicked:', {
           ipOnholdPicking,
           fewCasesAcceptance,
           stockLotId,
           action: 'ALWAYS_SHOW_REJECT_MODAL'
         });

         // ✅ FIXED: Reject button should ALWAYS show rejection modal, regardless of other conditions
         // This is the reject button, so the user explicitly wants to reject - don't redirect to accept modal
         // ✅ ALWAYS show rejection modal when reject button is clicked
         console.log('🔴 REJECT: Showing rejection modal flow');
         
         // ✅ Set up the modal data first
         const trayModal = document.getElementById("trayScanModal");
         const detailsDiv = document.getElementById("trayScanDetails");
         const modalHeader = document.getElementById("trayScanModalHeader");
         
         trayModal.dataset.batchId = batchId;
         trayModal.dataset.stockLotId = stockLotId;
         
         // Set modal header
         const modelNo = row.getAttribute('data-model-no') || '';
         if (modalHeader) {
           modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
         }
         
         // ✅ CONDITIONAL: Use appropriate logic for data display
         if (ipOnholdPicking) {
           // Show editable saved data (completed process)
           console.log('🔴 REJECT: Showing editable rejection data (completed process)');
           showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
           // ✅ ALWAYS set up auto-save functionality even in read-only mode
           setTimeout(() => addEditableFormEventListeners(row, batchId, stockLotId), 500);
         } else {
           // ✅ Check for draft first, then show form
           console.log('🔴 REJECT: Checking for existing draft or showing new rejection form');
           checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
         }
         
         // Show the modal
         console.log('🔴 REJECT: Displaying rejection modal');
         trayModal.style.display = "block";
         trayModal.classList.add("open");
       });
     });
   
     // View button (opens Input Screening modal - right side)
     document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach((link) => {
       link.addEventListener('click', async function (e) {
         e.preventDefault();
   
         // Get modal elements
         const modal = document.getElementById("trayScanModal_DayPlanning");
         const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
         const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
         modal.dataset.batchId = link.getAttribute('data-batch-id');
   
         // Get data attributes
         const batchId = link.getAttribute('data-batch-id');
         const stockLotId = link.getAttribute('data-stock-lot-id');
         const modelNo = link.getAttribute('data-model-no');
         const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
         const trayCapacity = link.getAttribute('data-tray-capacity') || "";
         const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';
   
         let trayQtyList = [];
         try {
           trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
         } catch (e) {
           trayQtyList = [];
         }
   
         // Set model number in modal
         if (modalModelNo && modelNo) {
           modalModelNo.textContent = modelNo;
         }
   
         // Set model image
         const modalUserImg = modal.querySelector('.user-profile img');
         const modelImage = link.getAttribute('data-model-image');
         if (modalUserImg) {
           if (modelImage) {
             modalUserImg.src = modelImage;
           } else {
             modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
           }
         }


               // --- Tray Type Identification ---
          const trayTypeCell = row.querySelector('td:nth-child(8)');
          const trayType = trayTypeCell ? trayTypeCell.textContent.trim() : 'N/A';
 
                  let trayTypeDiv = modal.querySelector('#modalTrayType');
          if (!trayTypeDiv) {
              trayTypeDiv = document.createElement('div');
              trayTypeDiv.id = 'modalTrayType';
              trayTypeDiv.style.fontWeight = '600';
              trayTypeDiv.style.color = '#222';
              trayTypeDiv.style.fontSize = '12px';
              modal.querySelector('.modal-top-header').appendChild(trayTypeDiv);
          }
          

    // choose size mode, apply class and display numeric size (Normal = 16, Jumbo = 12)
(function(){
  // parse base type from the trayType string (e.g. "Normal-16", "Jumbo-12", "CPSF-12")
  const rawType = (trayType || '').split('-')[0]?.trim().toLowerCase() || 'normal';

  // normalize known aliases -> logical type should be 'normal' or 'jumbo'
  let logicalType = rawType;
  if (logicalType === 'cpsf') logicalType = 'normal';
  // add other aliases if required, e.g. if (logicalType === 'xyz') logicalType = 'jumbo';

  const isJumbo = logicalType === 'jumbo';

  // correct sizes: Jumbo => 12, Normal => 16
  const sizeNumber = isJumbo ? 12 : 16;

  trayTypeDiv.classList.remove('tray-type-jumbo','tray-type-normal');
  trayTypeDiv.classList.add(isJumbo ? 'tray-type-jumbo' : 'tray-type-normal');

  const displayLabel = logicalType.charAt(0).toUpperCase() + logicalType.slice(1);

  trayTypeDiv.innerHTML = `
<span style="display: flex; align-items: center; gap: 8px;">
  <button type="button"
          style="
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #28a745;
            background: #f7fff7;
            color: #5e5959;
            font-weight: 600;
            font-size: 12px;
            border-radius: 20px;
            padding: 5px;
            box-shadow: 0 1px 4px rgba(40,167,69,0.08);
            cursor: default;
          "
          disabled
  >
    ${displayLabel} - ${sizeNumber}
  </button>
</span>
  `;
})();


   
         // Show/Hide validation buttons based on verification status
         const trayValidateSection = document.getElementById("trayValidateSection");
         const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");
   
         if (isQtyVerified) {
           if (trayValidateSection) trayValidateSection.style.display = "none";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
         } else {
           if (trayValidateSection) trayValidateSection.style.display = "flex";
           if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
         }
   
         // Fetch tray data with proper top tray handling using API
         let traysData = [];
         try {
           const resp = await fetch(`/inputscreening/ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
           const result = await resp.json();
           if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
             traysData = result.trays;
           }
         } catch (e) {
         }
   
         // Fetch existing verification status
         let verificationData = {};
         try {
           const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
           const verifyResult = await verifyResp.json();
           if (verifyResult.success) {
             verificationData = verifyResult.verification_data;
           }
         } catch (e) {
         }
   
         // TABLE BUILDING FUNCTION (reuse your existing buildTableHTML)
         function buildTableHTML(showValidationColumn = false) {
           let html = `
             <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
               <thead>
                 <tr>
                   <th style="width:50px;">S.no</th>
                   <th>Tray ID</th>
                   <th>Tray Qty</th>
                 </tr>
               </thead>
               <tbody>
           `;
           
           // If we have trays data from API, use it directly
           if (traysData && traysData.length > 0) {
             traysData.forEach((tray, index) => {
               const isTopTray = tray.is_top_tray || index === 0;
               const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
               const position = index + 1;
   
               // Check verification status
               const verification = this.verificationData[position];
               const isVerifiedByUser = verification ? verification.is_verified : false;
               const isVerifiedInDB = tray.IP_tray_verified || false;
               const isVerified = isVerifiedByUser || isVerifiedInDB;
               
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
   
               // Set input properties based on verification status
               let inputValue, inputStyle, verificationIndicator;
   
               if (isVerified) {
                 inputValue = verifiedTrayId || tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
                 console.log(`✅ [BuildTable-2 Pos ${position}] VERIFIED - tray: ${inputValue}, byUser: ${isVerifiedByUser}, inDB: ${isVerifiedInDB}`);
               } else {
                 inputValue = tray.tray_id || '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
                 console.log(`⏳ [BuildTable-2 Pos ${position}] NOT verified - tray: ${inputValue}`);
               }
   
               html += `
                 <tr>
                   <td>${displaySNo}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td style="position:relative; white-space:nowrap;">
                     <span style="display:inline-flex; align-items:center;">
                       <input type="number" 
                              class="form-control tray-qty-input" 
                              value="${tray.tray_quantity || ''}" 
                              readonly 
                              style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                              data-initial="${tray.tray_quantity || ''}"
                              ${isTopTray ? 'data-top-tray="1"' : ''} 
                       />
                      
                     </span>
                   </td>
                 </tr>
               `;
             });
           } else {
             // Fallback: Use the old method if API data is not available
             let totalRows = noOfTrays;
             for (let i = 0; i < totalRows; i++) {
               const position = i + 1;
               const verification = this.verificationData[position];
               const isVerified = verification ? verification.is_verified : false;
               const verificationStatus = verification ? verification.verification_status : null;
               const verifiedTrayId = verification ? verification.tray_id : '';
               const trayQty = trayQtyList[i] || trayCapacity;
               
               let inputValue, inputStyle, verificationIndicator;
               
               if (isVerified) {
                 inputValue = verifiedTrayId;
                 inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                 verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
               } else {
                 inputValue = '';
                 inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                 verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
               }
               
               html += `
                 <tr>
                   <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                   <td>
                     <input type="text" 
                            class="form-control" 
                            value="${inputValue}" 
                            readonly 
                            style="${inputStyle}"
                            data-position="${position}" />
                     ${verificationIndicator}
                   </td>
                   <td>
                     <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                   </td>
                 </tr>
               `;
             }
           }
           
           html += `
               </tbody>
             </table>
           `;
           return html;
         }
   
         // Store data in modal for later use
         modal.buildTableHTML = buildTableHTML;
         modal.traysData = traysData;
         modal.verificationData = verificationData;
         modal.noOfTrays = noOfTrays;
         modal.trayQtyList = trayQtyList;
         modal.trayCapacity = trayCapacity;
         modal.isQtyVerified = isQtyVerified;
         modal.stockLotId = stockLotId;
   
         // Initially show table
         detailsDiv.innerHTML = modal.buildTableHTML(false);
   
         // Show the modal
         if (modal) modal.style.display = "block";
         modal.classList.add("open");
   
         // Check verification status after modal opens
         setTimeout(() => {
           if (!modal.isQtyVerified) {
             checkVerificationStatusAndShowButtons();
           } else {
             removeDraftCancelButtons();
           }
         }, 200);
       });
     });
   
     // ✅ Re-attach Hold Toggle functionality after table refresh
     console.log('Calling attachHoldToggleListeners after table refresh...');
     if (typeof attachHoldToggleListeners === 'function') {
       attachHoldToggleListeners();
     } else {
       console.error('attachHoldToggleListeners function not found!');
     }
   
     // Re-attach other event listeners if needed (accept buttons, delete buttons, etc.)
     reattachOtherEventListeners();
   }
   })
   .catch(error => {
   console.error('Error refreshing table data:', error);
   // Silent error - no user notification
   });
   }
   
   // Helper function to reattach other event listeners
   function reattachOtherEventListeners() {
   // Re-attach Accept button listeners
   document.addEventListener('click', function(e) {
   if (e.target.closest('.btn-twitter')) {
     // Your existing accept button logic here
   }
   });
   
   // Re-attach Delete button listeners
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
   btn.addEventListener('click', function(e) {
     // Your existing delete button logic here
   });
   });
   
   // Re-attach any other dynamic event listeners as needed
   }
   // Helper function to reattach other event listeners
   function reattachOtherEventListeners() {
   // Re-attach Accept button listeners
   document.addEventListener('click', function(e) {
   if (e.target.closest('.btn-twitter')) {
     // Your existing accept button logic here
   }
   });
   
   // Re-attach Delete button listeners
   document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
   btn.addEventListener('click', function(e) {
     // Your existing delete button logic here
   });
   });
   
   // Re-attach any other dynamic event listeners as needed
   }
   
   // ✅ UPDATED: Modified saveTopTrayScan to handle empty tray_id properly
   function saveTopTrayScan(lotId, topTrayQty, isDraft) {
   
   const topTrayInput = document.getElementById('topTrayIdInput');
   const trayId = topTrayInput ? topTrayInput.value.trim() : '';
   
   // ✅ FIXED: Check if we have delink trays as alternative
   const delinkInputs = document.querySelectorAll('.delink-tray-input');
   const hasDelinkTrays = Array.from(delinkInputs).some(input => input.value.trim());
   
   // ✅ UPDATED: Allow draft saving if EITHER top tray ID OR delink trays are provided
   if (!trayId && !hasDelinkTrays) {
   showAcceptedTrayMessage('Please scan at least one tray ID (either Top Tray or Delink)', '#dc3545');
   return;
   }
   
   // ✅ REMOVED: No longer block delink-only operations for draft saves
   // Allow delink-only operations for drafts, but maybe restrict for final submission
   if (!isDraft && !trayId && hasDelinkTrays) {
   showAcceptedTrayMessage('Final submission requires a top tray ID. You can save as draft with delink trays only.', '#dc3545');
   return;
   }
   
   // ✅ FIXED: Proceed with save - backend will handle all validation
   proceedWithSave();
   
   function proceedWithSave() {
   // ✅ NEW: Collect delink tray data with detailed logging
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  const delinkTrays = [];
  let allDelinkFilled = true;
  
  delinkInputs.forEach((input, index) => {
    const delinkTrayId = input.value.trim();
    const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
    delinkTrays.push({
      tray_id: delinkTrayId,
      tray_qty: expectedQty,
      position: index
    });
    // Check if any delink tray is empty
    if (!delinkTrayId) {
      allDelinkFilled = false;
    }
  });
  
  // For final submit (not draft), require all delink trays to be filled if any are present
  if (!isDraft && delinkInputs.length > 0 && !allDelinkFilled) {
    showAcceptedTrayMessage('Please fill all Delink Tray IDs before submitting.', '#dc3545');
    return;
  }
  
  // ...proceedWithSave()...
   
   // ✅ UPDATED: Build payload more carefully
   const payload = {
     lot_id: lotId,
     draft_save: isDraft,
     delink_trays: delinkTrays
   };
   
   // ✅ FIXED: Only include tray_id and tray_qty if we actually have a top tray
   if (trayId) {
     payload.tray_id = trayId;
     payload.tray_qty = topTrayQty;
   }
   
   console.log('Sending payload:', payload); // ✅ Debug log
   
   // ✅ NEW: Show appropriate loading message based on what's being saved
   if (!isDraft) {
     if (trayId && delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Processing top tray scan and ${delinkTrays.length} delink operations...`, '#007bff');
     } else if (trayId) {
       showAcceptedTrayMessage('⏳ Processing top tray scan...', '#007bff');
     } else if (delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Processing ${delinkTrays.length} delink operations...`, '#007bff');
     }
   } else {
     // Draft save messages
     if (trayId && delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Saving draft with top tray and ${delinkTrays.length} delink tray(s)...`, '#007bff');
     } else if (trayId) {
       showAcceptedTrayMessage('⏳ Saving draft with top tray scan...', '#007bff');
     } else if (delinkTrays.length > 0) {
       showAcceptedTrayMessage(`⏳ Saving draft with ${delinkTrays.length} delink tray(s)...`, '#007bff');
     }
   }
   
   fetch('/inputscreening/save_single_top_tray_scan/', {
     method: 'POST',
     headers: {
       'Content-Type': 'application/json',
       'X-CSRFToken': getCookie('csrftoken')
     },
     body: JSON.stringify(payload)
   })
   .then(res => {
     return res.json();
   })
   .then(data => {
     console.log('Server response:', data); // ✅ Debug log
     
     if (data.success) {
       let message = data.message;
       
       // ✅ NEW: Show detailed success message based on what was saved
       if (!isDraft) {
         if (trayId && data.delink_count > 0) {
           message = `✅ Top tray scan completed. ${data.delink_count} tray(s) marked for delink.`;
         } else if (trayId) {
           message = '✅ Top tray scan completed successfully.';
         } else if (data.delink_count > 0) {
           message = `✅ ${data.delink_count} tray(s) marked for delink.`;
         }
       } else {
         // Draft save success messages
         if (trayId && data.delink_count > 0) {
           message = `✅ Draft saved with top tray and ${data.delink_count} delink tray(s).`;
         } else if (trayId) {
           message = '✅ Draft saved with top tray scan.';
         } else if (data.delink_count > 0) {
           message = `✅ Draft saved with ${data.delink_count} delink tray(s).`;
         } else {
           message = '✅ Draft saved successfully.';
         }
       }
       
       showAcceptedTrayMessage(message, '#28a745');
   
       setTimeout(() => {
         window.location.reload();
       }, 1500);
   
       return;
       
     } else {
       showAcceptedTrayMessage(data.error || 'Failed to save', '#dc3545');
     }
   })
   .catch(error => {
     console.error('Network error:', error); // ✅ Debug log
     showAcceptedTrayMessage('Network error occurred', '#dc3545');
   });
   }
   }
   
   // ✅ EXISTING: Show message helper
     function showAcceptedTrayMessage(message, color) {
       const msgDiv = document.getElementById("acceptedTrayMsg");
       if (msgDiv) {
         msgDiv.style.color = color;
         msgDiv.textContent = message;
         setTimeout(() => {
           msgDiv.textContent = "";
         }, 3000);
       }
     }
   
     // ✅ UPDATED: Enhanced delink tray validation using delink_check_tray_id endpoint
     function addDelinkTrayValidation(lotId) {
       console.log('🔧 Adding delink tray validation for lot:', lotId);
       
document.querySelectorAll('.delink-tray-input').forEach(function(input, idx, allInputs) {
  // Remove existing event listeners
  if (input._blurHandler) input.removeEventListener('blur', input._blurHandler);
  if (input._inputHandler) input.removeEventListener('input', input._inputHandler);
  if (input._keydownHandler) input.removeEventListener('keydown', input._keydownHandler);

  // Track validation state for each input
  input._hasError = false;
  input._isValidating = false;

  // Input event for counter update

  input._inputHandler = function() {
    this._hasError = false;
    const errorSpan = this.parentElement.querySelector('.delink-tray-error');
    if (errorSpan) {
      errorSpan.style.display = 'none';
      errorSpan.textContent = '';
    }
    updateDelinkScanCounter();

    // --- DUPLICATE CHECK: Show instantly during input ---
    const trayId = this.value.trim();
    let isDuplicate = false;
    document.querySelectorAll('.delink-tray-input').forEach(function(otherInput) {
      if (otherInput !== input && otherInput.value.trim() === trayId && trayId) {
        isDuplicate = true;
      }
    });
    if (isDuplicate) {
      this._hasError = true;
      if (errorSpan) {
        errorSpan.innerHTML = `❌ Duplicate`;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#dc3545';
        errorSpan.style.backgroundColor = '#f8d7da';
        errorSpan.style.padding = '4px 8px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '11px';
      }
      this.style.backgroundColor = '#f8d7da';
      this.style.borderColor = '#dc3545';
      this.style.color = '#721c24';
      return;
    }

    // --- NEW: On-the-fly validation as user types ---
    if (trayId) {
      this._isValidating = true;
      fetch(`/inputscreening/delink_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => {
          this._isValidating = false;
          if (errorSpan) {
            if (data.exists && data.valid_for_delink) {
              errorSpan.innerHTML = `✅ ${data.status_message || 'Available for Delink'}`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#155724';
              errorSpan.style.backgroundColor = '#d4edda';
              this.style.backgroundColor = '#d4edda';
              this.style.borderColor = '#28a745';
              this.style.color = '#155724';
              // --- IMMEDIATE FOCUS MOVE ON VALID ---
              const currentInput = this;
              const allInputs = document.querySelectorAll('.delink-tray-input');
              const currentIndex = Array.from(allInputs).indexOf(currentInput);
              for (let i = currentIndex + 1; i < allInputs.length; i++) {
                if (!allInputs[i].value.trim()) {
                  allInputs[i].focus();
                  allInputs[i].scrollIntoView({ behavior: 'smooth', block: 'center' });
                  break;
                }
              }
            } else {
              errorSpan.innerHTML = `❌ ${data.status_message || 'Invalid for Delink'}`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#721c24';
              errorSpan.style.backgroundColor = '#f8d7da';
              this.style.backgroundColor = '#f8d7da';
              this.style.borderColor = '#dc3545';
              this.style.color = '#721c24';
              // Auto-select if length >= 9 (after typing 9th char) and invalid
              if (this.value.trim().length >= 9) {
                setTimeout(() => {
                  this.focus();
                  this.select();
                }, 50);
              }
            }
          }
        })
        .catch(() => {
          this._isValidating = false;
          if (errorSpan) {
            errorSpan.innerHTML = '❌ Connection Error';
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
          }
        });
    } else {
      // Reset styles if input is empty
      this.style.backgroundColor = '';
      this.style.borderColor = '';
      this.style.color = '';
    }
  };



  
  input.addEventListener('input', input._inputHandler);

  // --- FIX: Validate on blur and on Tab key ---
  input._keydownHandler = function(e) {
    if (e.key === 'Tab') {
      // Validate when Tab is pressed
      this.dispatchEvent(new Event('blur'));
      // Allow tab navigation
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      // Prevent navigation if currently validating
      if (this._isValidating) {
        return;
      }
      // Prevent navigation if field is empty
      if (!this.value.trim()) {
        return;
      }
      // For fields with content, trigger validation and let blur handler handle focus
      this.dispatchEvent(new Event('blur'));
      return;
    }
  };
  input.addEventListener('keydown', input._keydownHandler);
         
         // ✅ UPDATED: Enhanced blur handler using delink_check_tray_id validation
         input._blurHandler = function() {
           const trayId = this.value.trim();
           const errorSpan = this.parentElement.querySelector('.delink-tray-error');
           this._hasError = false;
         
           // Clear any existing error messages
           if (errorSpan) {
             errorSpan.textContent = '';
             errorSpan.style.display = 'none';
           }
         
           if (!trayId) {
             updateDelinkScanCounter();
             return;
           }
         
           this._isValidating = true;
           console.log(`🔍 [Delink Validation] Validating tray ID: ${trayId} for lot: ${lotId}`);
         
           // Check for duplicates within current form (delink inputs only)
           let isDuplicate = false;
           document.querySelectorAll('.delink-tray-input').forEach(function(otherInput) {
             if (otherInput !== input && otherInput.value.trim() === trayId) {
               isDuplicate = true;
             }
           });
         
           if (isDuplicate) {
             this._hasError = true;
             this._isValidating = false;
             console.log(`❌ [Delink Validation] Duplicate tray ID detected: ${trayId}`);
             
             if (errorSpan) {
               errorSpan.innerHTML = `❌ Duplicate`;
               errorSpan.style.display = 'block';
               errorSpan.style.color = '#dc3545';
               errorSpan.style.backgroundColor = '#f8d7da';
               errorSpan.style.padding = '4px 8px';
               errorSpan.style.borderRadius = '4px';
               errorSpan.style.fontSize = '11px';
             }
             
             setTimeout(() => {
               this.value = '';
               this._hasError = false;
               if (errorSpan) errorSpan.style.display = 'none';
               this.focus();
               updateDelinkScanCounter();
             }, 1500);
             return;
           }
     
           // ✅ NEW: Use delink_check_tray_id endpoint for validation
           const queryParams = new URLSearchParams({
             tray_id: trayId,
             lot_id: lotId
           }).toString();
           
           fetch(`/inputscreening/delink_check_tray_id/?${queryParams}`)
             .then(res => res.json())
             .then(data => {
               this._isValidating = false;
               
               console.log(`🔍 [Delink Validation] Server response for ${trayId}:`, data);
         
               if (errorSpan) {
                 if (data.exists && data.valid_for_delink) {
                   console.log(`✅ [Delink Validation] SUCCESS: ${trayId} is valid for delink`);
                   // ✅ SUCCESS: Valid tray for delink
                   this._hasError = false;
                   
                   let successMessage = `✅ ${data.status_message || 'Available for Delink'}`;
                   
                   errorSpan.innerHTML = successMessage;
                   errorSpan.style.display = 'block';
                   errorSpan.style.color = '#155724';
                   errorSpan.style.backgroundColor = '#d4edda';
                   errorSpan.style.border = '1px solid #c3e6cb';
                   errorSpan.style.padding = '4px 8px';
                   errorSpan.style.borderRadius = '4px';
                   errorSpan.style.fontSize = '11px';
                   
                   // ✅ Update input styling for valid tray
                   this.style.backgroundColor = '#d4edda';
                   this.style.borderColor = '#28a745';
                   this.style.color = '#155724';
                   
                   // ✅ Move focus to next empty input box after successful validation
                   const currentInput = this;
                   setTimeout(() => {
                     if (errorSpan) errorSpan.style.display = 'none';
                     updateDelinkScanCounter();
                     
                     const allInputs = document.querySelectorAll('.delink-tray-input');
                     const currentIndex = Array.from(allInputs).indexOf(currentInput);
                     for (let i = currentIndex + 1; i < allInputs.length; i++) {
                       if (!allInputs[i].value.trim()) {
                         allInputs[i].focus();
                         allInputs[i].scrollIntoView({ behavior: 'smooth', block: 'center' });
                         break;
                       }
                     }
                   }, 100);
                   
                 } else {
                   // ❌ ERROR: Invalid tray for delink
                  this._hasError = true;
                  
                  let errorMessage = `❌ ${data.status_message || 'Invalid for Delink'}`;
                  
                  // ✅ Specific error handling based on tray status
                  if (data.tray_status === 'not_verified') {
                    errorMessage = '❌ Tray id is not verified';
                  } else if (data.tray_status === 'different_lot') {
                    errorMessage = '❌ Different Lot';
                  } else if (data.tray_status === 'already_rejected') {
                    errorMessage = '❌ Already Rejected';
                  } else if (data.tray_status === 'already_delinked') {
                    errorMessage = '❌ Already Delinked';
                  } else if (data.error === 'Tray ID not found') {
                    errorMessage = '❌ Not Found';
                  }
                  
                  errorSpan.innerHTML = errorMessage;
                  errorSpan.style.display = 'block';
                  errorSpan.style.color = '#721c24';
                  errorSpan.style.backgroundColor = '#f8d7da';
                  errorSpan.style.border = '1px solid #f5c6cb';
                  errorSpan.style.padding = '4px 8px';
                  errorSpan.style.borderRadius = '4px';
                  errorSpan.style.fontSize = '11px';
                  
                  // ✅ Update input styling for invalid tray
                  this.style.backgroundColor = '#f8d7da';
                  this.style.borderColor = '#dc3545';
                  this.style.color = '#721c24';
                  
                  // ✅ Do NOT clear the value or hide the error. Just select all and keep focus.
                  const currentInput = this;
                  console.log(`🔄 [Delink Validation] Setting up auto-select for invalid tray: ${trayId}`);
                  setTimeout(() => {
                    console.log(`🎯 [Delink Validation] Executing auto-select for invalid tray: ${trayId}`);
                    currentInput.focus();
                    currentInput.select();
                    updateDelinkScanCounter();
                  }, 100);
                 }
               } else {
                 updateDelinkScanCounter();
               }
             })
             .catch(error => {
               this._isValidating = false;
               this._hasError = true;
               console.error(`❌ [Delink Validation] Network error for ${trayId}:`, error);
               
               if (errorSpan) {
                 errorSpan.innerHTML = '❌ Connection Error';
                 errorSpan.style.display = 'block';
                 errorSpan.style.color = '#721c24';
                 errorSpan.style.backgroundColor = '#f8d7da';
                 errorSpan.style.padding = '4px 8px';
                 errorSpan.style.borderRadius = '4px';
                 errorSpan.style.fontSize = '11px';
                 
                 setTimeout(() => {
                   this.value = '';
                   this._hasError = false;
                   this.style.backgroundColor = '';
                   this.style.borderColor = '#ddd';
                   this.style.color = '';
                   if (errorSpan) errorSpan.style.display = 'none';
                   this.focus();
                   updateDelinkScanCounter();
                 }, 2000);
               } else {
                 updateDelinkScanCounter();
               }
             });
         };
         input.addEventListener('blur', input._blurHandler);
       });
  



       
       // ✅ Also add input event listener for duplicate checking with top tray
       document.querySelectorAll('.delink-tray-input').forEach(input => {
         input.addEventListener('input', checkForDuplicateTrayId);
       });
     
       console.log('✅ [Delink Validation] Event listeners attached successfully');
     }
   
   // Place this function after both above functions:
   function checkForDuplicateTrayId() {
   const topTrayInput = document.getElementById('topTrayIdInput');
   const delinkInputs = document.querySelectorAll('.delink-tray-input');
   const submitBtn = document.getElementById('acceptedTraySubmitBtn');
   const draftBtn = document.getElementById('acceptedTrayDraftBtn');
   const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
   const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
   const errorDiv = document.getElementById('topTrayError');
   let duplicate = false;
   
   if (topTrayInput && topTrayInput.value.trim()) {
   delinkInputs.forEach(input => {
     if (input.value.trim() && input.value.trim() === topTrayInput.value.trim()) {
       duplicate = true;
     }
   });
   }
   
   if (duplicate) {
   // ✅ FIXED: Only disable submit buttons, keep draft buttons enabled
   if (submitBtn) submitBtn.disabled = true;
   if (finalSubmitBtn) finalSubmitBtn.disabled = true;
   // Keep draft buttons enabled
   if (draftBtn) draftBtn.disabled = false;
   if (updateDraftBtn) updateDraftBtn.disabled = false;
  if (errorDiv) {
    errorDiv.textContent = '❌ Same tray cannot be used for both Delink and Top Tray';
    errorDiv.style.display = 'block';
    errorDiv.style.color = '#dc3545';
    errorDiv.style.backgroundColor = '#f8d7da';
    errorDiv.style.padding = '4px 8px';
    errorDiv.style.borderRadius = '4px';
    errorDiv.style.fontSize = '11px';
    // Focus and select the input (assuming you have a reference to the input)
    setTimeout(() => {
      if (topTrayInput) {
        topTrayInput.focus();
        topTrayInput.select();
      }
    }, 100);
  }
   } else {
   if (submitBtn) submitBtn.disabled = false;
   if (draftBtn) draftBtn.disabled = false;
   if (updateDraftBtn) updateDraftBtn.disabled = false;
   if (finalSubmitBtn) finalSubmitBtn.disabled = false;
   if (errorDiv) errorDiv.style.display = 'none';
   }
   }
   
     // ✅ NEW: Update delink scan counter
     function updateDelinkScanCounter() {
       const counter = document.getElementById('delinkScanCounter');
       if (!counter) return;
       
       const totalQuantity = parseInt(counter.getAttribute('data-total-quantity')) || 0;
       let scannedQuantity = 0;
       
       // Calculate total scanned quantity
       document.querySelectorAll('.delink-tray-input').forEach(input => {
         const trayId = input.value.trim();
         const hasError = input.parentElement.querySelector('.delink-tray-error').style.display === 'block';
         
         // Only count if tray ID is filled and has no errors
         if (trayId && !hasError) {
           // Get the expected quantity for this row
           const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
           scannedQuantity += expectedQty;
         }
       });
       
       // Update counter display
       counter.textContent = `${scannedQuantity}/${totalQuantity}`;
       
       // Update color based on progress
       if (scannedQuantity === totalQuantity && totalQuantity > 0) {
         counter.style.color = '#28a745'; // Green when complete
       } else if (scannedQuantity > 0) {
         counter.style.color = '#ffc107'; // Yellow when in progress
       } else {
         counter.style.color = '#dc3545'; // Red when not started
       }
       
     }
   
     // Helper function to get CSRF token
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   
     // ✅ MISSING FUNCTIONS: Add the missing utility functions
     function updateUIForBatchRejection(batchId) {
       // Update UI after batch rejection if needed
     }

     
     // New Popup Modal close events
     closeNewPopupBtn.addEventListener("click", () => {
       newPopupModal.classList.remove("open");
     });
    
   });
   
   // ✅ NEW: Add CSS for draft mode animations and grid styling
   const draftModeCSS = `
     <style>
       @keyframes draftModeGlow {
         from { box-shadow: 0 0 5px rgba(243, 156, 18, 0.3); }
         to { box-shadow: 0 0 15px rgba(243, 156, 18, 0.6); }
       }
       
       .row-has-draft {
         background-color: #fff3cd !important;
         border-left: 4px solid #f39c12 !important;
       }
       
       .table-grid {
         display: grid;
         grid-template-columns: auto 1fr auto;
         gap: 0;
       }
       
       .table-grid > div {
         border: 1px solid #ccc;
         padding: 8px;
         background: #fff;
       }
       
       .table-grid > div:first-child,
       .table-grid > div:nth-child(3n+1) {
         background: #f8f9fa;
         font-weight: bold;
       }
       
       /* Enhanced styling for single top tray scan */
       .top-tray-input-section {
         border: 2px solid #e0e0e0;
         border-radius: 8px;
         background: #f9f9f9;
         padding: 4px;
         margin: 15px 0;
       }
       
       .top-tray-input-section.has-value {
         border-color: #28a745;
         background: #f8fff9;
       }
       
       .top-tray-input-section.has-error {
         border-color: #dc3545;
         background: #fff5f5;
       }
       
       .scan-counter {
         background: #f8f9fa;
         padding: 6px 12px;
         border-radius: 20px;
         border: 1px solid #dee2e6;
         font-size: 14px;
         font-weight: 600;
       }
       
       .scan-counter.complete {
         background: #d4edda;
         border-color: #28a745;
         color: #155724;
       }
       
       .scan-counter.progress {
         background: #fff3cd;
         border-color: #ffc107;
         color: #856404;
       }
       
       .scan-counter.pending {
         background: #f8d7da;
         border-color: #dc3545;
         color: #721c24;
       }
       
       /* Button styling improvements */
       .action-button {
         padding: 8px 16px;
         border: none;
         border-radius: 30px;
         font-weight: 500;
         transition: all 0.3s ease;
         cursor: pointer;
       }
       
       .action-button:hover:not(:disabled) {
         transform: translateY(-1px);
         box-shadow: 0 4px 8px rgba(0,0,0,0.15);
       }
       
       .action-button:disabled {
         opacity: 0.6;
         cursor: not-allowed;
       }
       
       /* Error and success message styling */
       .status-message {
         padding: 4px 8px;
         border-radius: 4px;
         font-size: 12px;
         margin-top: 4px;
         display: inline-block;
       }
       
       .status-message.success {
         color: #155724;
         background-color: #d4edda;
         border: 1px solid #c3e6cb;
       }
       
       .status-message.error {
         color: #721c24;
         background-color: #f8d7da;
         border: 1px solid #f5c6cb;
       }
       
       /* Loading spinner */
       .loading-spinner {
         display: inline-block;
         width: 16px;
         height: 16px;
         border: 2px solid #f3f3f3;
         border-top: 2px solid #007bff;
         border-radius: 50%;
         animation: spin 1s linear infinite;
       }
       
       @keyframes spin {
         0% { transform: rotate(0deg); }
         100% { transform: rotate(360deg); }
       }
       
       /* Responsive improvements */
       @media (max-width: 768px) {
         .top-tray-input-section {
           flex-direction: column;
           gap: 10px;
         }
         
         .top-tray-input-section > div {
           width: 100% !important;
         }
         
         .scan-counter {
           font-size: 12px;
           padding: 4px 8px;
         }
       }
     </style>
   `;
   
   document.head.insertAdjacentHTML('beforeend', draftModeCSS);
</script>

<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     let openRemarkTooltip = null; // Global reference to track open tooltip

     // Helper function to close remark tooltip completely
     function closeRemarkTooltip(tooltip, trigger) {
       if (tooltip) {
         console.log('🔴 Closing remark tooltip completely');

         // Remove pinned class
         tooltip.classList.remove("pinned");

         // Hide the entire tooltip completely
         tooltip.style.opacity = "0";
         tooltip.style.pointerEvents = "none";
         tooltip.style.visibility = "hidden";
         tooltip.style.display = "none";

         // Hide close button
         const closeBtn = tooltip.querySelector('.remark-close-btn');
         if (closeBtn) closeBtn.style.display = 'none';

         // Remove visual indicator from trigger
         if (trigger) {
           trigger.style.backgroundColor = '';
           trigger.style.borderRadius = '';
         }

         // Clear global reference
         openRemarkTooltip = null;

         console.log('✅ Remark tooltip completely closed');
       }
     }

     var triggers = document.querySelectorAll(".remark-tooltip-trigger");
     triggers.forEach(function (trigger) {
       var tooltip = trigger.querySelector(".remark-tooltip");
       var sendButton = tooltip ? tooltip.querySelector("button:not(.remark-close-btn)") : null;
       var closeButton = tooltip ? tooltip.querySelector(".remark-close-btn") : null;
       var textarea = tooltip ? tooltip.querySelector("textarea") : null;

       function showTooltip() {
         tooltip.style.display = "block";
         tooltip.style.opacity = "1";
         tooltip.style.visibility = "visible";
         tooltip.style.pointerEvents = "auto";

         var rect = tooltip.getBoundingClientRect();
         if (rect.right > window.innerWidth) {
           tooltip.style.left = "auto";
           tooltip.style.right = "0";
           tooltip.style.transform = "none";
         }
         if (rect.left < 0) {
           tooltip.style.left = "0";
           tooltip.style.transform = "none";
         }
       }

       function hideTooltip() {
         if (!tooltip.classList.contains("pinned")) {
           tooltip.style.opacity = "0";
           tooltip.style.pointerEvents = "none";
           tooltip.style.visibility = "hidden";
           tooltip.style.display = "none";

           // Hide close button
           if (closeButton) closeButton.style.display = 'none';
         }
       }

       // Hover behavior (only when not pinned)
       trigger.addEventListener("mouseenter", function() {
         if (!tooltip.classList.contains("pinned")) {
           showTooltip();
           if (closeButton) closeButton.style.display = 'block';
         }
       });

       trigger.addEventListener("mouseleave", function () {
         if (!tooltip.classList.contains("pinned")) {
           setTimeout(function () {
             if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
               hideTooltip();
             }
           }, 100);
         }
       });

       if (tooltip) {
         tooltip.addEventListener("mouseenter", function() {
           if (!tooltip.classList.contains("pinned")) {
             showTooltip();
             if (closeButton) closeButton.style.display = 'block';
           }
         });

         tooltip.addEventListener("mouseleave", function () {
           if (!tooltip.classList.contains("pinned")) {
             setTimeout(function () {
               if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
                 hideTooltip();
               }
             }, 100);
           }
         });
       }

       // Click to pin/unpin tooltip (like model-image-tooltip)
       trigger.addEventListener("click", function (e) {
         e.preventDefault();
         e.stopPropagation();

         if (tooltip) {
           // Close any previously opened remark tooltip
           if (openRemarkTooltip && openRemarkTooltip !== tooltip) {
             const prevTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
             closeRemarkTooltip(openRemarkTooltip, prevTrigger);
           }

           // Toggle pinned state
           if (tooltip.classList.contains("pinned")) {
             // If already pinned, close it
             closeRemarkTooltip(tooltip, trigger);
           } else {
             // Pin the tooltip open
             tooltip.classList.add("pinned");
             showTooltip();
             openRemarkTooltip = tooltip;

             // Show close button
             if (closeButton) closeButton.style.display = 'block';

             // Add visual indicator that tooltip is pinned
             trigger.style.backgroundColor = '#e3f2fd';
             trigger.style.borderRadius = '4px';

             // Focus the textarea
             if (textarea && !textarea.readOnly) {
               textarea.focus();
             }
           }
         }
       });

       // Close button functionality
       if (closeButton) {
         closeButton.addEventListener('click', function(e) {
           e.stopPropagation();
           console.log('🔴 Remark close button clicked');
           closeRemarkTooltip(tooltip, trigger);
         });

         // Hover effects for close button
         closeButton.addEventListener('mouseenter', function() {
           closeButton.style.backgroundColor = '#c82333';
           closeButton.style.transform = 'scale(1.05)';
         });

         closeButton.addEventListener('mouseleave', function() {
           closeButton.style.backgroundColor = '#dc3545';
           closeButton.style.transform = 'scale(1)';
         });
       }

       // Keep tooltip open while typing in textarea
       if (textarea) {
         textarea.addEventListener('input', function() {
           if (!tooltip.classList.contains("pinned")) {
             // If user starts typing without clicking, pin the tooltip
             tooltip.classList.add("pinned");
             openRemarkTooltip = tooltip;
             trigger.style.backgroundColor = '#e3f2fd';
             trigger.style.borderRadius = '4px';
             if (closeButton) closeButton.style.display = 'block';
           }
         });
       }

       // Send button functionality
       if (sendButton) {
         sendButton.addEventListener("click", function (e) {
           e.preventDefault();
           // Find the textarea and get its value
           var remark = textarea ? textarea.value.trim() : "";
           if (!remark) {
             Swal.fire('Error', 'Please enter a remark before sending.', 'error');
             return;
           }
           // Find the batch_id from the row (tr) data attribute or from a hidden field
           var row = trigger.closest("tr");
           var batchId = row ? row.getAttribute('data-batch-id') : null;
           if (!batchId) {
             Swal.fire('Error', 'Batch ID not found.', 'error');
             return;
           }
           fetch('/inputscreening/save_ip_pick_remark/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify({
               batch_id: batchId,
               remark: remark
             })
           })
           .then(res => res.json())
           .then(data => {
             if (data.success) {
               Swal.fire({
                 icon: 'success',
                 title: 'Remark saved!',
                 timer: 1200,
                 showConfirmButton: false
               }).then(() => {
                 // Make the textarea readonly
                 if (textarea) {
                   textarea.setAttribute("readonly", true);
                 }

                 // Replace send button with info message
                 if (sendButton && tooltip) {
                   const infoDiv = document.createElement("div");
                   infoDiv.style.marginTop = "40px";
                   infoDiv.style.color = "#31708f";
                   infoDiv.style.background = "#d9edf7";
                   infoDiv.style.border = "1px solid #bce8f1";
                   infoDiv.style.borderRadius = "4px";
                   infoDiv.style.padding = "8px 12px";
                   infoDiv.style.fontSize = "10px";
                   infoDiv.style.textAlign = "left";
                   infoDiv.innerHTML = `
                     <i class="fa fa-info-circle"></i>
                     Remark already saved and cannot be edited.
                   `;
                   sendButton.parentNode.replaceChild(infoDiv, sendButton);
                 }

                  // Find the chat icon <img> inside this trigger
                   const chatImg = trigger.querySelector('img[alt="Chat"]');
                   if (chatImg) {
                     chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                     chatImg.style.opacity = "1";
                   }

                 // Close the tooltip after saving
                 closeRemarkTooltip(tooltip, trigger);
               });

             } else {
               Swal.fire('Error', data.error || 'Failed to save remark', 'error');
             }
           })
           .catch(() => {
             Swal.fire('Error', 'Network error', 'error');
           });
         });
       }
     });

     // Close remark tooltip when clicking outside
     document.addEventListener("click", function (e) {
       if (openRemarkTooltip && !e.target.closest('.remark-tooltip') && !e.target.closest('.remark-tooltip-trigger')) {
         const openTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
         closeRemarkTooltip(openRemarkTooltip, openTrigger);
       }
     });

     // Close remark tooltip with ESC key
     document.addEventListener("keydown", function (e) {
       if (e.key === "Escape" && openRemarkTooltip) {
         const openTrigger = openRemarkTooltip.closest('.remark-tooltip-trigger');
         closeRemarkTooltip(openRemarkTooltip, openTrigger);
         console.log('✅ Remark tooltip closed with ESC key');
       }
     });

     // Prevent tooltip from closing when clicking inside it
     document.querySelectorAll(".remark-tooltip").forEach(function (tooltip) {
       tooltip.addEventListener("click", function (e) {
         e.stopPropagation();
       });
     });
   });       function getCookie(name) {
     let cookieValue = null;
     if (document.cookie && document.cookie !== '') {
       const cookies = document.cookie.split(';');
       for (let i = 0; i < cookies.length; i++) {
         const cookie = cookies[i].trim();
         if (cookie.substring(0, name.length + 1) === (name + '=')) {
           cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
           break;
         }
       }
     }
     return cookieValue;
   }
</script>

<!-- Active table row highlight -->
<script nonce="{{ csp_nonce }}">
   // Row highlight & position swap for tray-scan-btn-Jig, tray-scan-btn (Set Top Tray/Reject), and btn-twitter (Accept)
   document.addEventListener("DOMContentLoaded", function() {
     // Add highlight style if not present
     if (!document.getElementById('dp-row-action-highlight-style')) {
       var style = document.createElement('style');
       style.id = 'dp-row-action-highlight-style';
       style.innerHTML = `
         .dp-row-action-highlight {
           transition: box-shadow 1.3s;
           background-color: #fff5bd !important;
           animation: highlightAnimation 2s ease-in-out;
         }
       `;
       document.head.appendChild(style);
     }
   
     let originalRowIndex = null;
     let movedRow = null;
     let placeholderRow = null;

     // Function to handle row highlighting and movement
     function handleRowHighlight(event) {
       // Remove highlight from all rows
       document.querySelectorAll('tbody tr').forEach(function(row) {
         row.classList.remove('dp-row-action-highlight');
       });
       // Move the clicked row to the top and highlight
       var row = event.target.closest('tr');
       if (row && row.parentNode) {
         const tbody = row.parentNode;
         // Only move if not already at top
         if (tbody.firstElementChild !== row) {
           // If a previous move exists, restore it first
           if (movedRow && placeholderRow && placeholderRow.parentNode) {
             placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
             placeholderRow.parentNode.removeChild(placeholderRow);
             movedRow.classList.remove('dp-row-action-highlight');
             movedRow = null;
             placeholderRow = null;
             originalRowIndex = null;
           }
           // Store original index and row
           originalRowIndex = Array.from(tbody.children).indexOf(row);
           movedRow = row;
           // Insert a placeholder at the original position
           placeholderRow = document.createElement('tr');
           placeholderRow.style.display = 'none';
           tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
           // Move row to top
           tbody.insertBefore(row, tbody.firstElementChild);
         }
         row.classList.add('dp-row-action-highlight');
       }
     }

     // Function to restore row position and remove highlight
     function restoreRowPosition() {
       if (movedRow && placeholderRow && placeholderRow.parentNode) {
         placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
         placeholderRow.parentNode.removeChild(placeholderRow);
         movedRow.classList.remove('dp-row-action-highlight');
         movedRow = null;
         placeholderRow = null;
         originalRowIndex = null;
       }
       // Also remove highlight from any row just in case
       document.querySelectorAll('tbody tr').forEach(function(row) {
         row.classList.remove('dp-row-action-highlight');
         row.classList.remove('highlighted-tray-scan');
       });
     }

     // Add event listeners for View buttons (tray-scan-btn-Jig)
     document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
       link.addEventListener('click', handleRowHighlight);
     });

     // Add event listeners for Set Top Tray/Reject buttons (tray-scan-btn)
     document.querySelectorAll('.tray-scan-btn').forEach(function(button) {
       button.addEventListener('click', handleRowHighlight);
     });

     // Add event listeners for Accept buttons (btn-twitter)
     document.querySelectorAll('.btn-twitter').forEach(function(button) {
       // Only add listener if it's an Accept button (contains "Accept" text)
       if (button.textContent.includes('Accept')) {
         button.addEventListener('click', handleRowHighlight);
       }
     });

     // On modal close events, restore row to original position and remove highlight
     
     // For View modal (trayScanModal_DayPlanning)
     var closeViewBtn = document.getElementById('closeTrayScanModal_DayPlanning');
     if (closeViewBtn) {
       closeViewBtn.addEventListener('click', restoreRowPosition);
     }

     // For Reject modal (trayScanModal)
     var closeRejectBtn = document.getElementById('closeTrayScanModal');
     if (closeRejectBtn) {
       closeRejectBtn.addEventListener('click', function() {
         // ✅ ADDITIONAL: Auto-save before restoring position
         console.log('🔄 [closeRejectBtn] Additional auto-save trigger');
         if (typeof window.triggerAutoSave === 'function') {
           window.triggerAutoSave();
         }
         
         restoreRowPosition();
       });
     }

     // For Accept/Set Top Tray modal (newPopupModal)
     var closeAcceptBtn = document.getElementById('closeNewPopupModal');
     if (closeAcceptBtn) {
       closeAcceptBtn.addEventListener('click', restoreRowPosition);
     }

      // ✅ ENHANCED: Handle dynamically created elements and modal backdrops
      document.addEventListener('click', function(event) {
        if (event.target.id === 'closeAcceptedTrayModal') {
          console.log('🔴 Dynamic accepted tray modal close button clicked - delegating to main handler');
          // Delegate to centralized handler to prevent conflicts
          closeAcceptedTrayModalHandler();
          return; // Prevent further execution
        }
        
        // Check if clicked element is a modal backdrop
        if (event.target.classList.contains('tray-scan-modal') || 
            event.target.classList.contains('tray-scan-modal-DayPlanning') || 
            event.target.classList.contains('new-popup-modal')) {
          console.log('🔴 Modal backdrop clicked');
          restoreRowPosition();
          

        }
        
        // Handle dynamically created cancel buttons
        if (event.target.textContent === 'Cancel' ||
            event.target.classList.contains('cancel-btn')) {
          console.log('🔴 Dynamic cancel button clicked');
          restoreRowPosition();
          
          // ✅ ADDED: Refresh page after restoring row position
          setTimeout(() => {
            window.location.reload();
          }, 300);
        }
      });
   });
</script>

<script nonce="{{ csp_nonce }}">
// ========== HOLD/UNHOLD TOGGLE FUNCTIONALITY ==========
document.addEventListener("DOMContentLoaded", function () {
  console.log('🔄 Initializing Hold/Unhold toggle functionality');

  // Global state to track hold/unhold operations
  window.holdToggleState = {
    currentHoldCell: null,
    intendedState: null,
    currentBatchId: null,
    currentLotId: null,
    rowIdentifier: null
  };

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Function to handle hold toggle button clicks
  function attachHoldToggleListeners() {
    console.log('🔗 Attaching hold toggle listeners');
    
    document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
      // Remove any existing event listeners by cloning the node
      const newBtn = btn.cloneNode(true);
      if (btn.parentNode) {
        btn.parentNode.replaceChild(newBtn, btn);
      }
      
      // Add new event listener
      newBtn.addEventListener('click', function (e) {
        e.preventDefault();
        
        console.log('🎯 Hold toggle clicked');
        
        const holdCell = newBtn.closest('td');
        const row = holdCell.closest('tr');
        
        // Store state globally with all needed data
        window.holdToggleState = {
          currentHoldCell: holdCell,
          intendedState: newBtn.checked,
          currentBatchId: row.getAttribute('data-batch-id'),
          currentLotId: row.getAttribute('data-stock-lot-id'),
          rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
        };
        
        console.log('📝 Hold toggle state:', window.holdToggleState);
        
        // Update modal title based on intended action
        const modalTitle = window.holdToggleState.intendedState ? 'Release Reason' : 'Hold Reason';
        document.getElementById('holdRemarkModal').querySelector('h5').textContent = modalTitle;
        
        // Clear and show modal
        document.getElementById('holdRemarkInput').value = '';
        document.getElementById('holdRemarkError').textContent = '';
        document.getElementById('holdRemarkModal').style.display = 'flex';
        document.getElementById('holdRemarkInput').focus();
      });
    });
  }

  // Save hold/unhold reason
  function setupSaveButton() {
    const saveBtn = document.getElementById('saveHoldRemarkBtn');
    if (saveBtn && !window.holdSaveHandlerAttached) {
      window.holdSaveHandlerAttached = true;
      
      saveBtn.onclick = function () {
        console.log('💾 Save button clicked, current state:', window.holdToggleState);
        
        const remark = document.getElementById('holdRemarkInput').value.trim();
        const errorDiv = document.getElementById('holdRemarkError');
        
        // Validation
        if (!remark) {
          errorDiv.textContent = 'Remark is required!';
          return;
        }
        
        if (remark.length > 50) {
          errorDiv.textContent = 'Remark must be 50 characters or less!';
          return;
        }
        
        if (!window.holdToggleState.currentLotId) {
          errorDiv.textContent = 'Lot ID not found!';
          return;
        }
      
        const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
        
        console.log('📡 Sending API request:', {
          lot_id: window.holdToggleState.currentLotId,
          remark: remark,
          action: action
        });

        // Disable save button during request
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
      
        fetch('/inputscreening/ip_save_hold_unhold_reason/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            lot_id: window.holdToggleState.currentLotId,
            remark: remark,
            action: action
          })
        })
        .then(res => res.json())
        .then(data => {
          console.log('📥 Server response:', data);
          
          // Re-enable save button
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
          
          if (data.success) {
            // Close modal first
            document.getElementById('holdRemarkModal').style.display = 'none';
            
            // Show success message
            if (typeof Swal !== 'undefined') {
              Swal.fire({
                icon: 'success',
                title: action === 'hold' ? 'Row hold successfully!' : 'Row released successfully!',
                timer: 1500,
                showConfirmButton: false
              });
            }
            
            // Update UI immediately
            updateRowUI(window.holdToggleState.currentLotId, action, remark);
            
            // Refresh page after a short delay
            setTimeout(() => {
              location.reload();
            }, 1500);
            
          } else {
            errorDiv.textContent = data.error || 'Failed to save reason!';
          }
        })
        .catch((error) => {
          console.error('❌ Request failed:', error);
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
          errorDiv.textContent = 'Network error occurred!';
        });
      };
    }
  }

  // Close modal handler
  function setupCloseButton() {
    const closeBtn = document.getElementById('closeHoldRemarkModal');
    if (closeBtn && !window.holdCloseHandlerAttached) {
      window.holdCloseHandlerAttached = true;
      
      closeBtn.onclick = function () {
        console.log('❌ Close button clicked');
        document.getElementById('holdRemarkModal').style.display = 'none';
        
        // Reset toggle to original state
        if (window.holdToggleState.currentHoldCell) {
          const toggle = window.holdToggleState.currentHoldCell.querySelector('.hold-toggle-btn');
          if (toggle) {
            toggle.checked = !window.holdToggleState.intendedState; // Revert to original state
          }
        }
        
        // Clear state
        window.holdToggleState = {
          currentHoldCell: null,
          intendedState: null,
          currentBatchId: null,
          currentLotId: null,
          rowIdentifier: null
        };
      };
    }
  }

  // Update row UI after successful hold/unhold operation
  function updateRowUI(lotId, action, remark) {
    console.log('🎨 Updating row UI for lot:', lotId, 'action:', action);
    
    const currentRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
    if (!currentRow) {
      console.log('❌ Row not found for lot ID:', lotId);
      return;
    }
    
    const toggle = currentRow.querySelector('.hold-toggle-btn');
    const icon = currentRow.querySelector('.hold-remark-icon');
    
    if (action === 'hold') {
      // Hold the row
      if (toggle) toggle.checked = false;
      currentRow.classList.add('row-inactive');
      
      // Blur all cells except the first one (S.No column)
      currentRow.querySelectorAll('td').forEach((td, idx) => {
        if (idx > 0) {
          td.classList.add('row-inactive-blur');
        } else {
          td.classList.remove('row-inactive-blur'); // Keep S.No column unblurred
        }
      });
      
      // Show remark icon
      if (icon) {
        icon.style.display = 'inline-block';
        icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />`;
        icon.setAttribute('title', 'Holding Reason: ' + remark);
      }
      
      console.log('✅ Row hold successfully');
    } else {
      // Unhold/Release the row
      if (toggle) toggle.checked = true;
      currentRow.classList.remove('row-inactive');
      
      // Remove blur from all cells
      currentRow.querySelectorAll('td').forEach(td => {
        td.classList.remove('row-inactive-blur');
      });
      
      // Update remark icon to show release reason or hide it
      if (icon) {
        icon.style.display = 'inline-block';
        icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />`;
        icon.setAttribute('title', 'Release Reason: ' + remark);
      }
      
      console.log('✅ Row released successfully');
    }
  }

  // Helper function to get CSRF token
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }

  // Initialize all functionality
  attachHoldToggleListeners();
  setupSaveButton();
  setupCloseButton();
  
  console.log('✅ Hold/Unhold functionality initialized successfully');
});
</script>

<!-- Script for restricting pointer events when modals are open -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     // List all modal IDs you use
     const modalIds = [
       "trayScanModal_DayPlanning",
       "trayScanModal",
       "newPopupModal",
       "imageSliderModal",
       "holdRemarkModal"
     ];
   
     function isAnyModalOpen() {
       return modalIds.some(id => {
         const el = document.getElementById(id);
         return el && (el.style.display === "block" || el.classList.contains("open") || el.style.display === "flex");
       });
     }
   
     function setBodyModalState(active) {
       if (active) {
         document.body.style.overflow = "hidden";
         document.body.style.pointerEvents = "none";
         // Allow pointer events for modals only
         modalIds.forEach(id => {
           const el = document.getElementById(id);
           if (el) el.style.pointerEvents = "auto";
         });
         // Restrict pointer events for holding rows but preserve cursor style
         document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
           el.style.cursor = "pointer";
         });
       } else {
         document.body.style.overflow = "";
         document.body.style.pointerEvents = "";
         modalIds.forEach(id => {
           const el = document.getElementById(id);
           if (el) el.style.pointerEvents = "";
         });
         // Restore pointer events for holding rows but preserve cursor style
         document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
           el.style.cursor = "pointer";
         });
       }
     }
   
     // Observe modal open/close changes
     const observer = new MutationObserver(() => {
       setBodyModalState(isAnyModalOpen());
     });
   
     modalIds.forEach(id => {
       const el = document.getElementById(id);
       if (el) observer.observe(el, { attributes: true, attributeFilter: ["style", "class"] });
     });
   
     // Also check on click (for dynamic changes)
     document.addEventListener("click", function () {
       setTimeout(() => setBodyModalState(isAnyModalOpen()), 50);
     });
   
     // Always restrict pointer events for holding rows, even if no modal is open
     setTimeout(() => {
       document.querySelectorAll('tr.row-inactive, tr.row-inactive *').forEach(el => {
         el.style.cursor = "pointer";
       });
     }, 100);
   });
</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
   document.addEventListener("DOMContentLoaded", function () {
     let openTooltip = null;
   
     // Helper function to completely close a tooltip
     function closeTooltip(tooltip, trigger) {
       if (tooltip) {
         console.log('🔴 Closing tooltip completely');
         
         // Remove pinned class
         tooltip.classList.remove("pinned");
         
         // Hide the entire tooltip completely
         tooltip.style.opacity = "0";
         tooltip.style.pointerEvents = "none";
         tooltip.style.visibility = "hidden";
         tooltip.style.display = "none"; // ✅ ADDED: Force display none
         
         // Hide buttons
         const infoBtn = tooltip.querySelector('.info-btn');
         const closeBtn = tooltip.querySelector('.close-btn');
         if (infoBtn) infoBtn.style.display = 'none';
         if (closeBtn) closeBtn.style.display = 'none';
         
         // Remove visual indicator from trigger
         if (trigger) {
           trigger.style.backgroundColor = '';
           trigger.style.borderRadius = '';
         }
         
         // Clear global reference
         openTooltip = null;
         
         console.log('✅ Tooltip completely closed');
       }
     }
   
     
  document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
  
     // Tooltip show/hide logic
     document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
       const tooltip = trigger.querySelector(".model-image-tooltip");
   
       trigger.addEventListener("mouseenter", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.display = "flex"; // ✅ ADDED: Reset display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Show Info and Close buttons on hover
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         }
       });
   
       trigger.addEventListener("mouseleave", function () {
         if (tooltip && !tooltip.classList.contains("pinned")) {
           tooltip.style.opacity = "0";
           tooltip.style.pointerEvents = "none";
           
           // Hide Info and Close buttons when not hovering and not pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'none';
           if (closeBtn) closeBtn.style.display = 'none';
         }
       });
   
       // Keep tooltip visible when hovering over it
       if (tooltip) {
         tooltip.addEventListener("mouseenter", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.display = "flex"; // ✅ ADDED: Reset display
             tooltip.style.visibility = "visible"; // ✅ ADDED: Reset visibility
           }
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           
           // Keep buttons visible when hovering over tooltip
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
         });
   
         tooltip.addEventListener("mouseleave", function () {
           if (!tooltip.classList.contains("pinned")) {
             tooltip.style.opacity = "0";
             tooltip.style.pointerEvents = "none";
             
             // Hide buttons when leaving tooltip and not pinned
             const infoBtn = tooltip.querySelector('.info-btn');
             const closeBtn = tooltip.querySelector('.close-btn');
             if (infoBtn) infoBtn.style.display = 'none';
             if (closeBtn) closeBtn.style.display = 'none';
           }
         });
       }
   
       trigger.addEventListener("click", function (e) {
         e.stopPropagation();
   
         if (tooltip) {
           // Close any previously opened tooltip
           if (openTooltip && openTooltip !== tooltip) {
             const prevTrigger = openTooltip.closest('.model-hover-trigger');
             closeTooltip(openTooltip, prevTrigger);
           }
   
           tooltip.classList.add("pinned");
           tooltip.style.display = "flex"; // ✅ ADDED: Ensure display
           tooltip.style.visibility = "visible"; // ✅ ADDED: Ensure visibility
           tooltip.style.opacity = "1";
           tooltip.style.pointerEvents = "auto";
           openTooltip = tooltip;
           
           // Keep buttons visible when pinned
           const infoBtn = tooltip.querySelector('.info-btn');
           const closeBtn = tooltip.querySelector('.close-btn');
           if (infoBtn) infoBtn.style.display = 'block';
           if (closeBtn) closeBtn.style.display = 'block';
   
           // Add visual indicator that tooltip is pinned
           trigger.style.backgroundColor = '#e3f2fd';
           trigger.style.borderRadius = '4px';
         }
       });
   
       // ✅ FIXED: Handle Close button click - Complete tooltip closure
       const closeBtn = tooltip?.querySelector('.close-btn');
       if (closeBtn) {
         // Initially hide the button
         closeBtn.style.display = 'none';
         
         closeBtn.addEventListener('click', function(e) {
           e.stopPropagation();
           console.log('🔴 Close button clicked');
           
           // Use the helper function to completely close tooltip
           closeTooltip(tooltip, trigger);
           
           // Feedback animation for close button
           closeBtn.style.transform = 'scale(0.9)';
           setTimeout(() => {
             if (closeBtn.style) {
               closeBtn.style.transform = 'scale(1)';
             }
           }, 150);
         });
         
         // ✅ Add hover effect for close button
         closeBtn.addEventListener('mouseenter', function() {
           closeBtn.style.backgroundColor = '#c82333';
           closeBtn.style.transform = 'scale(1.05)';
         });
         
         closeBtn.addEventListener('mouseleave', function() {
           closeBtn.style.backgroundColor = '#dc3545';
           closeBtn.style.transform = 'scale(1)';
         });
       }
     });
   
     // ✅ ENHANCED: Close tooltip when clicking outside
     document.addEventListener("click", function (e) {
       if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
       }
     });
   
     // ✅ Close tooltip with ESC key
     document.addEventListener("keydown", function (e) {
       if (e.key === "Escape" && openTooltip) {
         const openTrigger = openTooltip.closest('.model-hover-trigger');
         closeTooltip(openTooltip, openTrigger);
         console.log('✅ Tooltip closed with ESC key');
       }
     });
   
     // Prevent tooltip from closing when clicking inside it
     document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
       tooltip.addEventListener("click", function (e) {
         e.stopPropagation();
       });
     });
   });
</script>

<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
 -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    // Disable all actions except modal content and specific buttons
    document.querySelectorAll(
      'img[alt="Edit"], img[alt="Delete"], img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, .hold-toggle-btn, button:not(#closeTrayScanModal_DayPlanning):not(#trayValidateBtn):not(#trayScanRedoBtn):not(.tray-scan-btn):not(#draftButton):not(#proceedButton):not(#cancelButton):not(#scanButton), a:not(.tray-scan-btn-Jig)'
    ).forEach(function (el) {
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';
      if (el.classList.contains('hold-toggle-btn')) el.disabled = true;
    });

    // Ensure table scroll is always allowed
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  function unlockParentActions() {
    // Restore all actions
    document.querySelectorAll(
      'img[alt="Edit"], img[alt="Delete"], img[alt="Edit Disabled"], img[alt="Delete Disabled"], .fa-filter, .hold-toggle-btn, button, a'
    ).forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
      if (el.classList.contains('hold-toggle-btn')) el.disabled = false;
    });

    // Restore table scroll
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var rejectModal = document.getElementById("rejectionReasonModal"); // Replace with your modal ID
  var closeRejectBtn = document.getElementById("closeRejectionReasonModal"); // Replace with your close button ID

  // When Reject button is clicked, lock parent
  document.querySelectorAll('.tray-scan-btn').forEach(function (button) {
    button.addEventListener('click', function () {
      setTimeout(lockParentActions, 100);
    });
  });

  // When Reject modal closes, unlock parent
  if (closeRejectBtn) {
    closeRejectBtn.addEventListener('click', function () {
      setTimeout(unlockParentActions, 200);
    });
  }

  // Ensure the modal content remains editable
  if (rejectModal) {
    rejectModal.addEventListener('click', function (e) {
      e.stopPropagation(); // Prevent clicks inside the modal from propagating
    });
  }

  // ✅ GLOBAL INSTANT VALIDATION: Apply to any tray ID input field
  function addGlobalTrayIdInstantValidation() {
    // Apply to rejection window tray inputs
    document.querySelectorAll('.rejection-tray-id-input').forEach(input => {
      if (!input._hasInstantValidation) {
        addSingleTrayInstantValidation(input, 'rejection');
        input._hasInstantValidation = true;
      }
    });
    
    // Apply to any other tray ID inputs (top tray, etc.)
    document.querySelectorAll('input[placeholder*="Tray"], input[placeholder*="tray"], input[id*="tray"], input[name*="tray"]').forEach(input => {
      if (!input._hasInstantValidation && input.type === 'text') {
        addSingleTrayInstantValidation(input, 'general');
        input._hasInstantValidation = true;
      }
    });
  }

  // ✅ Single input validation function
  function addSingleTrayInstantValidation(input, type = 'general') {
    if (input._instantValidationHandler) {
      input.removeEventListener('input', input._instantValidationHandler);
    }

    input._instantValidationHandler = function() {
      const trayId = this.value.trim();
      if (!trayId) return;

      const lotId = getCurrentLotId();
      if (!lotId) return;

      let apiUrl = '';
      let queryParams = {};

      if (type === 'rejection') {
        const rejectionQty = parseInt(this.getAttribute('data-tray-qty')) || 0;
        const rejectionReasonId = this.getAttribute('data-reason-id') || '';
        const currentSessionAllocations = collectCurrentSessionAllocations();
        
        queryParams = {
          tray_id: trayId,
          lot_id: lotId,
          rejection_qty: rejectionQty,
          rejection_reason_id: rejectionReasonId,
          current_session_allocations: JSON.stringify(currentSessionAllocations)
        };
        apiUrl = '/inputscreening/reject_check_tray_id_simple/';
      } else {
        queryParams = {
          tray_id: trayId,
          lot_id: lotId
        };
        apiUrl = '/inputscreening/check_tray_id/';
      }

      // Visual feedback - processing
      this.style.borderColor = '#007bff';
      this.style.backgroundColor = '#e3f2fd';

      fetch(`${apiUrl}?${new URLSearchParams(queryParams)}`)
        .then(response => response.json())
        .then(data => {
          if ((type === 'rejection' && data.exists && data.valid_for_rejection) || 
              (type === 'general' && data.exists)) {
            // Valid
            this.style.borderColor = '#28a745';
            this.style.backgroundColor = '#d4edda';
          } else {
            // Invalid
            this.style.borderColor = '#dc3545';
            this.style.backgroundColor = '#f8d7da';
          }
        })
        .catch(() => {
          // Error - reset to neutral
          this.style.borderColor = '#ffc107';
          this.style.backgroundColor = '#fff3cd';
        });
    };

    input.addEventListener('input', input._instantValidationHandler);
  }

  // ✅ Apply global validation on page load and DOM changes
  addGlobalTrayIdInstantValidation();
  
  // ✅ Initialize form submission interception
  interceptFormSubmission();
  
  // ✅ Re-apply when new elements are added (for dynamic content)
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === 1) { // Element node
            setTimeout(addGlobalTrayIdInstantValidation, 100);
          }
        });
      }
    });
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
});
</script>

<!-- Script for updating Lot Status based on Accept button and verification status -->
<script nonce="{{ csp_nonce }}">
document.addEventListener('DOMContentLoaded', function () {

  function updateLotStatusIfAllVerified() {
    try {
      const table = document.getElementById('order-listing');
      if (!table) return;
      const headers = table.querySelectorAll('thead th');
      // find header index for "Lot Status" (case-insensitive)
      let lotStatusIndex = -1;
      headers.forEach((h, i) => {
        if (h.textContent && h.textContent.trim().toUpperCase().includes('LOT STATUS')) {
          lotStatusIndex = i;
        }
      });
      // Lot Status is the 18th column in this table -> zero-based index 17
      if (lotStatusIndex === -1) lotStatusIndex = 17;

      const rows = table.querySelectorAll('tbody tr');
      rows.forEach(row => {
        if (!row) return;
        const lotId = row.getAttribute('data-stock-lot-id') || row.getAttribute('data-lot-id');
        if (!lotId) return;

        // ✅ FIXED: Use actual database values from data attributes instead of unreliable heuristics
        const ipOnholdPicking = row.getAttribute('data-ip-onhold-picking') === 'True';
        const trayVerify = row.getAttribute('data-tray-verify') === 'True';
        const draftTrayVerify = row.getAttribute('data-draft-tray-verify') === 'True';
        const ipHoldLot = row.getAttribute('data-ip-hold-lot') === 'True';

        // Get lot status cell by header index (robust vs nth-child)
        const lotStatusCell = row.children[lotStatusIndex];

        if (lotStatusCell) {
          if (ipHoldLot) {
            // When ip_hold_lot is True, show "On Hold" status
            lotStatusCell.innerHTML = `
              <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                style="border: 1px solid #dc3545; background-color: #f8d7da; color: #721c24;
                font-size: 12px; white-space: nowrap; padding: 5px;">
                On Hold
              </div>
            `;
          } else if (draftTrayVerify) {
            // Show "Draft" status ONLY when user explicitly clicks Draft button
            lotStatusCell.innerHTML = `
              <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                style="border: 1px solid #4997ac; background-color: #d1f2f3; color: #03425d;
                font-size: 12px; white-space: nowrap; padding: 5px;">
                Draft
              </div>
            `;
          } else {
            // Default to "Yet to Start"
            lotStatusCell.innerHTML = `
              <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00;
                font-size: 13px; white-space: nowrap; padding: 0.3rem;">
                Yet to Start
              </div>
            `;
          }
        }
      });
    } catch (err) {
      console.error('updateLotStatusIfAllVerified error:', err);
    }
  }

  // existing calls/hooks remain intact
  updateLotStatusIfAllVerified();
  if (window.checkVerificationStatusAndShowButtons && typeof window.checkVerificationStatusAndShowButtons === 'function') {
    const original = window.checkVerificationStatusAndShowButtons;
    window.checkVerificationStatusAndShowButtons = function () {
      const result = original.apply(this, arguments);
      setTimeout(updateLotStatusIfAllVerified, 120);
      return result;
    };
  }
  const tbody = document.querySelector('#order-listing tbody');
  if (tbody) {
    const mo = new MutationObserver(() => {
      if (mo._timer) clearTimeout(mo._timer);
      mo._timer = setTimeout(() => {
        updateLotStatusIfAllVerified();
      }, 150);
    });
    mo.observe(tbody, { childList: true, subtree: true, characterData: true });
    window._IS_picktable_mutation_observer = mo;
  }
  const safetyInterval = setInterval(() => updateLotStatusIfAllVerified(), 5000);
  window.addEventListener('beforeunload', () => clearInterval(safetyInterval));
});
</script>

<!-- ✅ FIX: Force button accessibility after tray ID validation in draft scenario -->
<script nonce="{{ csp_nonce }}">
// ✅ CRITICAL FIX: Force button accessibility after tray ID validation in draft scenario
document.addEventListener('DOMContentLoaded', function() {
  // Monitor the accepted tray modal for changes
  const acceptedModal = document.getElementById('newPopupModal');
  if (acceptedModal) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          // When modal opens, force button accessibility
          if (acceptedModal.classList.contains('open')) {
            setTimeout(function() {
              // ✅ CRITICAL FIX: Force enable DRAFT buttons regardless of any validation state
              const draftButtons = [
                'acceptedTrayUpdateDraftBtn',
                'acceptedTrayDraftBtn'
              ];
              
              const cancelButtons = [
                'acceptedTrayCancelBtn'  // ✅ Always make cancel accessible
              ];
              
              // ✅ FORCE ENABLE DRAFT BUTTONS WITH MAXIMUM PRIORITY
              draftButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                  btn.disabled = false;  
                  btn.style.pointerEvents = 'auto !important';
                  btn.style.zIndex = '900004 !important';
                  btn.style.cursor = 'pointer !important';
                  btn.style.opacity = '1 !important';  
                  btn.style.filter = 'none !important';
                  btn.classList.remove('disabled');
                  btn.removeAttribute('aria-disabled');
                  // Remove any click preventDefault
                  btn.onclick = null;
                  console.log(`✅ FORCED DRAFT ACCESSIBILITY for button: ${btnId}`);
                }
              });
              
              // ✅ FORCE ENABLE CANCEL BUTTON
              cancelButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                  btn.disabled = false;  
                  btn.style.pointerEvents = 'auto !important';
                  btn.style.zIndex = '900005 !important'; // Higher than draft
                  btn.style.cursor = 'pointer !important';
                  btn.style.opacity = '1 !important';  
                  btn.style.filter = 'none !important';
                  btn.classList.remove('disabled');
                  btn.removeAttribute('aria-disabled');
                  console.log(`✅ FORCED CANCEL ACCESSIBILITY for button: ${btnId}`);
                }
              });
              
              // ✅ Handle submit buttons separately (they can be validation-dependent)
              const submitButtons = [
                'acceptedTrayFinalSubmitBtn', 
                'acceptedTraySubmitBtn'
              ];
              
              submitButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                  btn.style.pointerEvents = 'auto';
                  btn.style.zIndex = '900004';
                  btn.style.cursor = 'pointer';
                  // Don't force submit buttons to be enabled - let validation handle them
                  console.log(`✅ Enhanced accessibility for submit button: ${btnId}`);
                }
              });
              
            }, 100); // Small delay to ensure DOM updates
          }
        }
      });
    });
    
    observer.observe(acceptedModal, { attributes: true, attributeFilter: ['class'] });
  }
  
  // ✅ AGGRESSIVE FALLBACK: Force button accessibility on ANY interaction with the modal
  document.addEventListener('click', function(e) {
    if (e.target.closest('#newPopupModal')) {
      setTimeout(function() {
        const draftButtons = document.querySelectorAll('#acceptedTrayUpdateDraftBtn, #acceptedTrayDraftBtn, #acceptedTrayCancelBtn');
        draftButtons.forEach(btn => {
          btn.disabled = false;  
          btn.style.pointerEvents = 'auto !important';
          btn.style.zIndex = '900004 !important';
          btn.style.cursor = 'pointer !important';
          btn.style.opacity = '1 !important';
          btn.style.filter = 'none !important';
          btn.classList.remove('disabled');
        });
      }, 50);
    }
  });
  
  // ✅ ADDITIONAL FALLBACK: Force button accessibility on any input change in the modal
  document.addEventListener('input', function(e) {
    if (e.target.id === 'topTrayIdInput' || e.target.closest('#newPopupModal')) {
      setTimeout(function() {
        const draftButtons = document.querySelectorAll('#acceptedTrayUpdateDraftBtn, #acceptedTrayDraftBtn, #acceptedTrayCancelBtn');
        draftButtons.forEach(btn => {
          btn.disabled = false;  
          btn.style.pointerEvents = 'auto !important';
          btn.style.zIndex = '900004 !important';
          btn.style.cursor = 'pointer !important';
          btn.style.opacity = '1 !important';
          btn.style.filter = 'none !important';
          btn.classList.remove('disabled');
        });
      }, 50);
    }
  });
  
  // ✅ PERIODIC SAFETY CHECK: Ensure draft buttons remain accessible every 2 seconds when modal is open
  setInterval(function() {
    const acceptedModal = document.getElementById('newPopupModal');
    if (acceptedModal && acceptedModal.classList.contains('open')) {
      const draftButtons = document.querySelectorAll('#acceptedTrayUpdateDraftBtn, #acceptedTrayDraftBtn, #acceptedTrayCancelBtn');
      draftButtons.forEach(btn => {
        if (btn.disabled || btn.style.pointerEvents === 'none' || btn.style.opacity !== '1') {
          console.log('🔧 [Periodic Fix] Re-enabling draft button:', btn.id);
          btn.disabled = false;  
          btn.style.pointerEvents = 'auto !important';
          btn.style.zIndex = '900004 !important';
          btn.style.cursor = 'pointer !important';
          btn.style.opacity = '1 !important';
          btn.style.filter = 'none !important';
          btn.classList.remove('disabled');
        }
      });
    }
  }, 2000);
});

// ✅ GLOBAL SAFETY NET: Monitor ALL tray input changes with event delegation
document.addEventListener('input', function(event) {
  if (event.target.classList.contains('rejection-tray-id-input')) {
    const inputElement = event.target;
    const trayId = inputElement.value.trim();
    
    console.log('🔍 [Global Monitor] Tray input detected:', trayId);
    console.log('🔍 [Global Monitor] Input element:', inputElement);
    console.log('🔍 [Global Monitor] Has instant validation handler:', !!inputElement._instantValidationHandler);
    
    // Get error span
    const errorSpan = inputElement.parentElement.querySelector('.rejection-tray-error');
    
    // Clear previous state
    inputElement.style.borderColor = '#ced4da';
    inputElement.style.backgroundColor = '#ffffff';
    
    if (errorSpan) {
      errorSpan.style.display = 'none';
      errorSpan.textContent = '';
    }
    
    // Skip if empty
    if (!trayId) {
      console.log('🔍 [Global Monitor] Empty tray ID, skipping');
      return;
    }
    
    // ✅ IMMEDIATE VALIDATION: Check rejection reason conflict
    console.log('🔍 [Global Monitor] Running validation for:', trayId);
    const capacityValidation = validateTrayCapacityAcrossRejections(trayId, inputElement);
    
    if (!capacityValidation.valid) {
      console.log('❌ [Global Monitor] CONFLICT DETECTED:', capacityValidation.error);
      
      // Show error visually
      inputElement.style.borderColor = '#dc3545';
      inputElement.style.backgroundColor = '#f8d7da';
      
      if (errorSpan) {
        errorSpan.innerHTML = `❌ ${capacityValidation.error}`;
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#721c24';
        errorSpan.style.backgroundColor = '#f8d7da';
        errorSpan.style.border = '1px solid #f5c6cb';
        errorSpan.style.padding = '6px 10px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '12px';
        errorSpan.style.fontWeight = '500';
        errorSpan.style.marginTop = '4px';
      }
      
      // Auto-select if 9+ characters
      if (trayId.length >= 9) {
        setTimeout(() => {
          inputElement.select();
          console.log('🔍 [Global Monitor] Text auto-selected');
        }, 100);
      }
      
      return; // Stop here - don't proceed to full validation check
    } else {
      console.log('✅ [Global Monitor] No conflict - tray is available for this reason');
      
      // Show temporary success indicator
      inputElement.style.borderColor = '#28a745';
      inputElement.style.backgroundColor = '#d4edda';
      
      if (errorSpan) {
        errorSpan.innerHTML = '✓ Tray can be reused';
        errorSpan.style.display = 'block';
        errorSpan.style.color = '#155724';
        errorSpan.style.backgroundColor = '#d4edda';
        errorSpan.style.border = '1px solid #c3e6cb';
        errorSpan.style.padding = '4px 8px';
        errorSpan.style.borderRadius = '4px';
        errorSpan.style.fontSize = '11px';
        errorSpan.style.marginTop = '4px';
      }
    }
    
    // Debounced capacity validation
    clearTimeout(window.capacityCheckTimeout);
    window.capacityCheckTimeout = setTimeout(() => {
      const violation = validateAllTrayCapacities();
      if (violation) {
        console.log('❌ [Global Monitor] Capacity violation:', violation);
        showErrorMessage(violation);
      }
    }, 500); // 500ms delay to avoid excessive checks
  }
});

// ✅ ENHANCED: Monitor quantity input changes for instant calculations
document.addEventListener('input', function(event) {
  if (event.target.classList.contains('rejection-qty-input')) {
    const qtyInput = event.target;
    const qty = parseInt(qtyInput.value) || 0;
    const reasonId = qtyInput.getAttribute('data-reason-id');
    
    console.log('📊 [Qty Monitor] Quantity changed for reason', reasonId, '- new qty:', qty);
    
    // Trigger instant validation for all tray inputs
    document.querySelectorAll('.rejection-tray-id-input').forEach(trayInput => {
      const trayId = trayInput.value.trim();
      if (trayId) {
        console.log('🔍 [Qty Monitor] Re-validating tray:', trayId);
        const validation = validateTrayCapacityAcrossRejections(trayId, trayInput);
        
        const errorSpan = trayInput.parentElement.querySelector('.rejection-tray-error');
        
        if (!validation.valid) {
          trayInput.style.borderColor = '#dc3545';
          trayInput.style.backgroundColor = '#f8d7da';
          
          if (errorSpan) {
            errorSpan.innerHTML = `❌ ${validation.error}`;
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
          }
        } else {
          trayInput.style.borderColor = '#28a745';
          trayInput.style.backgroundColor = '#d4edda';
          
          if (errorSpan) {
            errorSpan.innerHTML = '✅ Reuse allowed';
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#155724';
          }
        }
      }
    });
  }
});

// ✅ GLOBAL SAFETY NET: Also monitor changes via other events
['change', 'blur', 'keyup'].forEach(eventType => {
  document.addEventListener(eventType, function(event) {
    if (event.target.classList.contains('rejection-tray-id-input')) {
      clearTimeout(window.capacityCheckTimeout);
      window.capacityCheckTimeout = setTimeout(() => {
        const violation = validateAllTrayCapacities();
        if (violation) {
          console.log(`❌ [Global Monitor - ${eventType}] Capacity violation:`, violation);
        }
      }, 500);
    }
  });
});

// ✅ WRAPPER FUNCTION: Validate all trays in the rejection table
function validateAllTrayCapacities() {
  console.log('🔧 [validateAllTrayCapacities] Starting validation check...');
  
  const allRows = document.querySelectorAll('#rejectionTableBody tr');
  
  for (let row of allRows) {
    const reasonId = row.querySelector('.rejection-reason-id')?.value;
    const trayIdCell = row.querySelector('td:nth-child(5)');
    
    if (!trayIdCell || !reasonId) continue;
    
    const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
    
    for (let input of trayInputs) {
      const trayId = input.value.trim();
      if (!trayId) continue;
      
      const validation = validateTrayCapacityAcrossRejections(trayId, input);
      if (!validation.valid) {
        console.log('❌ [validateAllTrayCapacities] Found violation:', validation.error);
        return validation.error;
      }
    }
  }
  
  console.log('✅ [validateAllTrayCapacities] All trays valid');
  return null;
}

// ✅ Make validation functions globally available for debugging and testing
window.validateTrayCapacityAcrossRejections = validateTrayCapacityAcrossRejections;
window.validateAllTrayCapacities = validateAllTrayCapacities;

// ✅ Test function for debugging tray capacity validation
window.testTrayCapacityValidation = function() {
  console.log('🧪 Testing tray capacity validation...');
  
  // Log current tray inputs and their values
  const allTrayInputs = document.querySelectorAll('.rejection-tray-id-input');
  console.log(`Found ${allTrayInputs.length} tray inputs:`);
  
  allTrayInputs.forEach((input, index) => {
    const row = input.closest('tr');
    const qtyInput = row.querySelector('.rejection-qty-input');
    const qty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
    const reasonCell = row.cells[2];
    const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
    
    console.log(`  ${index + 1}. Tray ID: "${input.value}", Reason: "${reasonText}", Qty: ${qty}`);
  });
  
  // Test the validation function
  const violation = validateAllTrayCapacities();
  if (violation) {
    console.log('❌ Capacity violation:', violation);
    showErrorMessage('TEST: ' + violation);
  } else {
    console.log('✅ No capacity violations detected');
    showErrorMessage('TEST: No capacity violations - all tray capacities are within limits', '#28a745');
  }
  
  return violation;
};

// ✅ Test function to simulate the exact scenario you described
window.testScenario310 = function() {
  console.log('🧪 Testing scenario: Tray JB-A00310 with 15+13=28 pieces (capacity 12)');
  
  try {
    // Find tray inputs with JB-A00310
    const trayInputs = Array.from(document.querySelectorAll('.rejection-tray-id-input'))
      .filter(input => input.value.trim() === 'JB-A00310');
    
    console.log(`Found ${trayInputs.length} inputs with tray ID JB-A00310`);
    
    if (trayInputs.length > 0) {
      const validationResult = validateTrayCapacityAcrossRejections('JB-A00310', trayInputs[0]);
      console.log('Validation result:', validationResult);
      
      if (!validationResult.valid) {
        console.log('❌ CORRECT: System detected the violation:', validationResult.error);
        showErrorMessage('TEST PASSED: ' + validationResult.error, '#28a745');
        return true;
      } else {
        console.log('❌ PROBLEM: System did not detect the violation!');
        showErrorMessage('TEST FAILED: System should have detected capacity violation for JB-A00310', '#dc3545');
        return false;
      }
    } else {
      console.log('No tray inputs found with JB-A00310');
      showErrorMessage('TEST: No tray inputs found with JB-A00310 - enter the scenario first', '#ffc107');
      return null;
    }
  } catch (error) {
    console.error('Test error:', error);
    showErrorMessage('TEST ERROR: ' + error.message, '#dc3545');
    return false;
  }
};

console.log('✅ Enhanced Tray Capacity Validation System Loaded');
console.log('📊 Available test functions:');
console.log('   - testTrayCapacityValidation() - General validation test');
console.log('   - testScenario310() - Test specific scenario with JB-A00310');
console.log('   - validateTrayCapacityAcrossRejections(trayId) - Check specific tray');
console.log('   - validateAllTrayCapacities() - Check all trays');
</script>

<!-- Script to change chat icon color based on remark presence -->
<script nonce="{{ csp_nonce }}">


document.addEventListener("DOMContentLoaded", function () {
  // For each chat icon with title="Add Remark" and correct src
  document.querySelectorAll('img[alt="Chat"][title="Add Remark"][src*="chat_icon.png"]').forEach(function(chatImg) {
    // Find the related remark text (from data-remark or hidden input)
    let remarkText = "";
    const row = chatImg.closest('tr');
    if (row) {
      // Try to get from a data-remark attribute
      remarkText = row.getAttribute('data-remark') || "";
      // Or from a cell with the remark, or a hidden input
      const remarkCell = row.querySelector('.remark-cell');
      if (remarkCell && remarkCell.textContent.trim()) {
        remarkText = remarkCell.textContent.trim();
      }
      const remarkInput = row.querySelector('input[type="hidden"].remark-hidden-input');
      if (remarkInput && remarkInput.value.trim()) {
        remarkText = remarkInput.value.trim();
      }
    }

    // Set icon color: green if remark exists, grey if not
    if (remarkText && remarkText.length > 0) {
      // Green filter
      chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
      chatImg.style.opacity = "1";
    } else {
      // Grey filter
      chatImg.style.filter = "grayscale(1) brightness(0.8)";
      chatImg.style.opacity = "0.6";
    }
  });
});

</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // Find all Draft buttons (by id or class, update selector as needed)
  document.querySelectorAll('button[id*="Draft"],button[class*="Draft"]').forEach(function(btn) {
    // Prevent duplicate listeners
    btn.removeEventListener('click', window.__draftBtnLoadingHandler);
    window.__draftBtnLoadingHandler = function(e) {
      // Show overlay
      var overlay = document.getElementById('draftLoadingOverlay');
      if (overlay) overlay.style.display = 'flex';
      // When AJAX completes, hide overlay (listen for global AJAX stop or patch your draft save callback)
      // If using fetch/XHR, patch your draft save callback to hide overlay
      // Example: window.hideDraftOverlay = function() { overlay.style.display = 'none'; };
    };
    btn.addEventListener('click', window.__draftBtnLoadingHandler);
  });

  // Example: globally hide overlay on AJAX complete (if using jQuery)
  if (window.jQuery) {
    $(document).ajaxStop(function() {
      var overlay = document.getElementById('draftLoadingOverlay');
      if (overlay) overlay.style.display = 'none';
    });
  }
});
</script>



/* <!-- Script to handle redo tray verification --> */
<script nonce="{{ csp_nonce }}">
document.addEventListener('DOMContentLoaded', function() {
    var redoBtn = document.querySelector('img[src*="redo2.png"]');
    if (redoBtn) {
        redoBtn.addEventListener('click', function() {
            const modal = document.getElementById("trayScanModal_DayPlanning");
            const lotId = modal.dataset.lotId;
            if (!lotId) {
                alert('Lot ID not found.');
                return;
            }
            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }
            fetch('/inputscreening/reset_tray_verification_for_lot/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ lot_id: lotId })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    // Fetch updated verification status
                    return fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(lotId)}`);
                } else {
                    alert('Failed to reset tray verification: ' + data.error);
                    throw new Error('Reset failed');
                }
            })
            .then(res => res.json())
            .then(data => {
                const verificationData = data.verification_data || {};
                // Update UI based on fetched data
                const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
                const rows = detailsDiv.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const input = row.querySelector('input[type="text"]');
                    const indicator = row.querySelector('small');
                    const trayId = input ? input.value.trim() : '';
                    const isVerified = verificationData[trayId] || false;
                    if (input) {
                        if (isVerified) {
                            input.style.backgroundColor = '#d4edda';
                            input.style.borderColor = '#28a745';
                            input.style.color = '#155724';
                        } else {
                            input.style.backgroundColor = '#fff3cd';
                            input.style.borderColor = '#ffc107';
                            input.style.color = '#856404';
                        }
                    }
                    if (indicator) {
                        if (isVerified) {
                            indicator.textContent = '✅ Verified';
                            indicator.style.color = '#155724';
                        } else {
                            indicator.textContent = '⏳ Not Verified';
                            indicator.style.color = '#856404';
                        }
                    }
                });
            })
            .catch(err => console.error('Error resetting verification:', err));
        });
    }
});
</script>
{% endblock %}{% endblock content %}